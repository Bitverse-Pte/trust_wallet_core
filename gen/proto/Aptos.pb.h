// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Aptos.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Aptos_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Aptos_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Aptos_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Aptos_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Aptos_2eproto;
namespace TW {
namespace Aptos {
namespace Proto {
class CancelOfferNftMessage;
struct CancelOfferNftMessageDefaultTypeInternal;
extern CancelOfferNftMessageDefaultTypeInternal _CancelOfferNftMessage_default_instance_;
class ClaimNftMessage;
struct ClaimNftMessageDefaultTypeInternal;
extern ClaimNftMessageDefaultTypeInternal _ClaimNftMessage_default_instance_;
class CreateAccountMessage;
struct CreateAccountMessageDefaultTypeInternal;
extern CreateAccountMessageDefaultTypeInternal _CreateAccountMessage_default_instance_;
class LiquidStaking;
struct LiquidStakingDefaultTypeInternal;
extern LiquidStakingDefaultTypeInternal _LiquidStaking_default_instance_;
class ManagedTokensRegisterMessage;
struct ManagedTokensRegisterMessageDefaultTypeInternal;
extern ManagedTokensRegisterMessageDefaultTypeInternal _ManagedTokensRegisterMessage_default_instance_;
class NftMessage;
struct NftMessageDefaultTypeInternal;
extern NftMessageDefaultTypeInternal _NftMessage_default_instance_;
class OfferNftMessage;
struct OfferNftMessageDefaultTypeInternal;
extern OfferNftMessageDefaultTypeInternal _OfferNftMessage_default_instance_;
class SigningInput;
struct SigningInputDefaultTypeInternal;
extern SigningInputDefaultTypeInternal _SigningInput_default_instance_;
class SigningOutput;
struct SigningOutputDefaultTypeInternal;
extern SigningOutputDefaultTypeInternal _SigningOutput_default_instance_;
class StructTag;
struct StructTagDefaultTypeInternal;
extern StructTagDefaultTypeInternal _StructTag_default_instance_;
class TokenTransferCoinsMessage;
struct TokenTransferCoinsMessageDefaultTypeInternal;
extern TokenTransferCoinsMessageDefaultTypeInternal _TokenTransferCoinsMessage_default_instance_;
class TokenTransferMessage;
struct TokenTransferMessageDefaultTypeInternal;
extern TokenTransferMessageDefaultTypeInternal _TokenTransferMessage_default_instance_;
class TortugaClaim;
struct TortugaClaimDefaultTypeInternal;
extern TortugaClaimDefaultTypeInternal _TortugaClaim_default_instance_;
class TortugaStake;
struct TortugaStakeDefaultTypeInternal;
extern TortugaStakeDefaultTypeInternal _TortugaStake_default_instance_;
class TortugaUnstake;
struct TortugaUnstakeDefaultTypeInternal;
extern TortugaUnstakeDefaultTypeInternal _TortugaUnstake_default_instance_;
class TransactionAuthenticator;
struct TransactionAuthenticatorDefaultTypeInternal;
extern TransactionAuthenticatorDefaultTypeInternal _TransactionAuthenticator_default_instance_;
class TransferMessage;
struct TransferMessageDefaultTypeInternal;
extern TransferMessageDefaultTypeInternal _TransferMessage_default_instance_;
}  // namespace Proto
}  // namespace Aptos
}  // namespace TW
PROTOBUF_NAMESPACE_OPEN
template<> ::TW::Aptos::Proto::CancelOfferNftMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::CancelOfferNftMessage>(Arena*);
template<> ::TW::Aptos::Proto::ClaimNftMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::ClaimNftMessage>(Arena*);
template<> ::TW::Aptos::Proto::CreateAccountMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::CreateAccountMessage>(Arena*);
template<> ::TW::Aptos::Proto::LiquidStaking* Arena::CreateMaybeMessage<::TW::Aptos::Proto::LiquidStaking>(Arena*);
template<> ::TW::Aptos::Proto::ManagedTokensRegisterMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::ManagedTokensRegisterMessage>(Arena*);
template<> ::TW::Aptos::Proto::NftMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::NftMessage>(Arena*);
template<> ::TW::Aptos::Proto::OfferNftMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::OfferNftMessage>(Arena*);
template<> ::TW::Aptos::Proto::SigningInput* Arena::CreateMaybeMessage<::TW::Aptos::Proto::SigningInput>(Arena*);
template<> ::TW::Aptos::Proto::SigningOutput* Arena::CreateMaybeMessage<::TW::Aptos::Proto::SigningOutput>(Arena*);
template<> ::TW::Aptos::Proto::StructTag* Arena::CreateMaybeMessage<::TW::Aptos::Proto::StructTag>(Arena*);
template<> ::TW::Aptos::Proto::TokenTransferCoinsMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TokenTransferCoinsMessage>(Arena*);
template<> ::TW::Aptos::Proto::TokenTransferMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TokenTransferMessage>(Arena*);
template<> ::TW::Aptos::Proto::TortugaClaim* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TortugaClaim>(Arena*);
template<> ::TW::Aptos::Proto::TortugaStake* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TortugaStake>(Arena*);
template<> ::TW::Aptos::Proto::TortugaUnstake* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TortugaUnstake>(Arena*);
template<> ::TW::Aptos::Proto::TransactionAuthenticator* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TransactionAuthenticator>(Arena*);
template<> ::TW::Aptos::Proto::TransferMessage* Arena::CreateMaybeMessage<::TW::Aptos::Proto::TransferMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TW {
namespace Aptos {
namespace Proto {

// ===================================================================

class TransferMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TransferMessage) */ {
 public:
  inline TransferMessage() : TransferMessage(nullptr) {}
  ~TransferMessage() override;
  explicit constexpr TransferMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferMessage(const TransferMessage& from);
  TransferMessage(TransferMessage&& from) noexcept
    : TransferMessage() {
    *this = ::std::move(from);
  }

  inline TransferMessage& operator=(const TransferMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferMessage& operator=(TransferMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferMessage* internal_default_instance() {
    return reinterpret_cast<const TransferMessage*>(
               &_TransferMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransferMessage& a, TransferMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TransferMessage";
  }
  protected:
  explicit TransferMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string to = 1;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TransferMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class StructTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.StructTag) */ {
 public:
  inline StructTag() : StructTag(nullptr) {}
  ~StructTag() override;
  explicit constexpr StructTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructTag(const StructTag& from);
  StructTag(StructTag&& from) noexcept
    : StructTag() {
    *this = ::std::move(from);
  }

  inline StructTag& operator=(const StructTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructTag& operator=(StructTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructTag* internal_default_instance() {
    return reinterpret_cast<const StructTag*>(
               &_StructTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StructTag& a, StructTag& b) {
    a.Swap(&b);
  }
  inline void Swap(StructTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StructTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StructTag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.StructTag";
  }
  protected:
  explicit StructTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAddressFieldNumber = 1,
    kModuleFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // string account_address = 1;
  void clear_account_address();
  const std::string& account_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* account_address);
  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(const std::string& value);
  std::string* _internal_mutable_account_address();
  public:

  // string module = 2;
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.StructTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class TokenTransferMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TokenTransferMessage) */ {
 public:
  inline TokenTransferMessage() : TokenTransferMessage(nullptr) {}
  ~TokenTransferMessage() override;
  explicit constexpr TokenTransferMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenTransferMessage(const TokenTransferMessage& from);
  TokenTransferMessage(TokenTransferMessage&& from) noexcept
    : TokenTransferMessage() {
    *this = ::std::move(from);
  }

  inline TokenTransferMessage& operator=(const TokenTransferMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenTransferMessage& operator=(TokenTransferMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenTransferMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenTransferMessage* internal_default_instance() {
    return reinterpret_cast<const TokenTransferMessage*>(
               &_TokenTransferMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TokenTransferMessage& a, TokenTransferMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenTransferMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenTransferMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenTransferMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenTransferMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenTransferMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenTransferMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenTransferMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TokenTransferMessage";
  }
  protected:
  explicit TokenTransferMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kFunctionFieldNumber = 3,
    kAmountFieldNumber = 2,
  };
  // string to = 1;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // .TW.Aptos.Proto.StructTag function = 3;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::TW::Aptos::Proto::StructTag& function() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::StructTag* release_function();
  ::TW::Aptos::Proto::StructTag* mutable_function();
  void set_allocated_function(::TW::Aptos::Proto::StructTag* function);
  private:
  const ::TW::Aptos::Proto::StructTag& _internal_function() const;
  ::TW::Aptos::Proto::StructTag* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::TW::Aptos::Proto::StructTag* function);
  ::TW::Aptos::Proto::StructTag* unsafe_arena_release_function();

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TokenTransferMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::TW::Aptos::Proto::StructTag* function_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class TokenTransferCoinsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TokenTransferCoinsMessage) */ {
 public:
  inline TokenTransferCoinsMessage() : TokenTransferCoinsMessage(nullptr) {}
  ~TokenTransferCoinsMessage() override;
  explicit constexpr TokenTransferCoinsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenTransferCoinsMessage(const TokenTransferCoinsMessage& from);
  TokenTransferCoinsMessage(TokenTransferCoinsMessage&& from) noexcept
    : TokenTransferCoinsMessage() {
    *this = ::std::move(from);
  }

  inline TokenTransferCoinsMessage& operator=(const TokenTransferCoinsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenTransferCoinsMessage& operator=(TokenTransferCoinsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenTransferCoinsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenTransferCoinsMessage* internal_default_instance() {
    return reinterpret_cast<const TokenTransferCoinsMessage*>(
               &_TokenTransferCoinsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TokenTransferCoinsMessage& a, TokenTransferCoinsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenTransferCoinsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenTransferCoinsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenTransferCoinsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenTransferCoinsMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenTransferCoinsMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenTransferCoinsMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenTransferCoinsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TokenTransferCoinsMessage";
  }
  protected:
  explicit TokenTransferCoinsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kFunctionFieldNumber = 3,
    kAmountFieldNumber = 2,
  };
  // string to = 1;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // .TW.Aptos.Proto.StructTag function = 3;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::TW::Aptos::Proto::StructTag& function() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::StructTag* release_function();
  ::TW::Aptos::Proto::StructTag* mutable_function();
  void set_allocated_function(::TW::Aptos::Proto::StructTag* function);
  private:
  const ::TW::Aptos::Proto::StructTag& _internal_function() const;
  ::TW::Aptos::Proto::StructTag* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::TW::Aptos::Proto::StructTag* function);
  ::TW::Aptos::Proto::StructTag* unsafe_arena_release_function();

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TokenTransferCoinsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::TW::Aptos::Proto::StructTag* function_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class ManagedTokensRegisterMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.ManagedTokensRegisterMessage) */ {
 public:
  inline ManagedTokensRegisterMessage() : ManagedTokensRegisterMessage(nullptr) {}
  ~ManagedTokensRegisterMessage() override;
  explicit constexpr ManagedTokensRegisterMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManagedTokensRegisterMessage(const ManagedTokensRegisterMessage& from);
  ManagedTokensRegisterMessage(ManagedTokensRegisterMessage&& from) noexcept
    : ManagedTokensRegisterMessage() {
    *this = ::std::move(from);
  }

  inline ManagedTokensRegisterMessage& operator=(const ManagedTokensRegisterMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManagedTokensRegisterMessage& operator=(ManagedTokensRegisterMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManagedTokensRegisterMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManagedTokensRegisterMessage* internal_default_instance() {
    return reinterpret_cast<const ManagedTokensRegisterMessage*>(
               &_ManagedTokensRegisterMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ManagedTokensRegisterMessage& a, ManagedTokensRegisterMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ManagedTokensRegisterMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManagedTokensRegisterMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManagedTokensRegisterMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManagedTokensRegisterMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManagedTokensRegisterMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ManagedTokensRegisterMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManagedTokensRegisterMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.ManagedTokensRegisterMessage";
  }
  protected:
  explicit ManagedTokensRegisterMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionFieldNumber = 1,
  };
  // .TW.Aptos.Proto.StructTag function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::TW::Aptos::Proto::StructTag& function() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::StructTag* release_function();
  ::TW::Aptos::Proto::StructTag* mutable_function();
  void set_allocated_function(::TW::Aptos::Proto::StructTag* function);
  private:
  const ::TW::Aptos::Proto::StructTag& _internal_function() const;
  ::TW::Aptos::Proto::StructTag* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::TW::Aptos::Proto::StructTag* function);
  ::TW::Aptos::Proto::StructTag* unsafe_arena_release_function();

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.ManagedTokensRegisterMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TW::Aptos::Proto::StructTag* function_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.CreateAccountMessage) */ {
 public:
  inline CreateAccountMessage() : CreateAccountMessage(nullptr) {}
  ~CreateAccountMessage() override;
  explicit constexpr CreateAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountMessage(const CreateAccountMessage& from);
  CreateAccountMessage(CreateAccountMessage&& from) noexcept
    : CreateAccountMessage() {
    *this = ::std::move(from);
  }

  inline CreateAccountMessage& operator=(const CreateAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountMessage& operator=(CreateAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountMessage* internal_default_instance() {
    return reinterpret_cast<const CreateAccountMessage*>(
               &_CreateAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateAccountMessage& a, CreateAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateAccountMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.CreateAccountMessage";
  }
  protected:
  explicit CreateAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthKeyFieldNumber = 1,
  };
  // string auth_key = 1;
  void clear_auth_key();
  const std::string& auth_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_key();
  PROTOBUF_NODISCARD std::string* release_auth_key();
  void set_allocated_auth_key(std::string* auth_key);
  private:
  const std::string& _internal_auth_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_key(const std::string& value);
  std::string* _internal_mutable_auth_key();
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.CreateAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class OfferNftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.OfferNftMessage) */ {
 public:
  inline OfferNftMessage() : OfferNftMessage(nullptr) {}
  ~OfferNftMessage() override;
  explicit constexpr OfferNftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfferNftMessage(const OfferNftMessage& from);
  OfferNftMessage(OfferNftMessage&& from) noexcept
    : OfferNftMessage() {
    *this = ::std::move(from);
  }

  inline OfferNftMessage& operator=(const OfferNftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfferNftMessage& operator=(OfferNftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfferNftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfferNftMessage* internal_default_instance() {
    return reinterpret_cast<const OfferNftMessage*>(
               &_OfferNftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OfferNftMessage& a, OfferNftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OfferNftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfferNftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfferNftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfferNftMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfferNftMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OfferNftMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfferNftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.OfferNftMessage";
  }
  protected:
  explicit OfferNftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kCollectionNameFieldNumber = 3,
    kNameFieldNumber = 4,
    kPropertyVersionFieldNumber = 5,
    kAmountFieldNumber = 6,
  };
  // string receiver = 1;
  void clear_receiver();
  const std::string& receiver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* receiver);
  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(const std::string& value);
  std::string* _internal_mutable_receiver();
  public:

  // string creator = 2;
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // string collectionName = 3;
  void clear_collectionname();
  const std::string& collectionname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collectionname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collectionname();
  PROTOBUF_NODISCARD std::string* release_collectionname();
  void set_allocated_collectionname(std::string* collectionname);
  private:
  const std::string& _internal_collectionname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collectionname(const std::string& value);
  std::string* _internal_mutable_collectionname();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 property_version = 5;
  void clear_property_version();
  uint64_t property_version() const;
  void set_property_version(uint64_t value);
  private:
  uint64_t _internal_property_version() const;
  void _internal_set_property_version(uint64_t value);
  public:

  // uint64 amount = 6;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.OfferNftMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collectionname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t property_version_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class CancelOfferNftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.CancelOfferNftMessage) */ {
 public:
  inline CancelOfferNftMessage() : CancelOfferNftMessage(nullptr) {}
  ~CancelOfferNftMessage() override;
  explicit constexpr CancelOfferNftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOfferNftMessage(const CancelOfferNftMessage& from);
  CancelOfferNftMessage(CancelOfferNftMessage&& from) noexcept
    : CancelOfferNftMessage() {
    *this = ::std::move(from);
  }

  inline CancelOfferNftMessage& operator=(const CancelOfferNftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOfferNftMessage& operator=(CancelOfferNftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOfferNftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOfferNftMessage* internal_default_instance() {
    return reinterpret_cast<const CancelOfferNftMessage*>(
               &_CancelOfferNftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CancelOfferNftMessage& a, CancelOfferNftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOfferNftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOfferNftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOfferNftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOfferNftMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOfferNftMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelOfferNftMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOfferNftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.CancelOfferNftMessage";
  }
  protected:
  explicit CancelOfferNftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kCollectionNameFieldNumber = 3,
    kNameFieldNumber = 4,
    kPropertyVersionFieldNumber = 5,
  };
  // string receiver = 1;
  void clear_receiver();
  const std::string& receiver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* receiver);
  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(const std::string& value);
  std::string* _internal_mutable_receiver();
  public:

  // string creator = 2;
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // string collectionName = 3;
  void clear_collectionname();
  const std::string& collectionname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collectionname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collectionname();
  PROTOBUF_NODISCARD std::string* release_collectionname();
  void set_allocated_collectionname(std::string* collectionname);
  private:
  const std::string& _internal_collectionname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collectionname(const std::string& value);
  std::string* _internal_mutable_collectionname();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 property_version = 5;
  void clear_property_version();
  uint64_t property_version() const;
  void set_property_version(uint64_t value);
  private:
  uint64_t _internal_property_version() const;
  void _internal_set_property_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.CancelOfferNftMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collectionname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t property_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class ClaimNftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.ClaimNftMessage) */ {
 public:
  inline ClaimNftMessage() : ClaimNftMessage(nullptr) {}
  ~ClaimNftMessage() override;
  explicit constexpr ClaimNftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClaimNftMessage(const ClaimNftMessage& from);
  ClaimNftMessage(ClaimNftMessage&& from) noexcept
    : ClaimNftMessage() {
    *this = ::std::move(from);
  }

  inline ClaimNftMessage& operator=(const ClaimNftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClaimNftMessage& operator=(ClaimNftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClaimNftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClaimNftMessage* internal_default_instance() {
    return reinterpret_cast<const ClaimNftMessage*>(
               &_ClaimNftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClaimNftMessage& a, ClaimNftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClaimNftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClaimNftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClaimNftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClaimNftMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClaimNftMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClaimNftMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimNftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.ClaimNftMessage";
  }
  protected:
  explicit ClaimNftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kCollectionNameFieldNumber = 3,
    kNameFieldNumber = 4,
    kPropertyVersionFieldNumber = 5,
  };
  // string sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // string creator = 2;
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // string collectionName = 3;
  void clear_collectionname();
  const std::string& collectionname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collectionname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collectionname();
  PROTOBUF_NODISCARD std::string* release_collectionname();
  void set_allocated_collectionname(std::string* collectionname);
  private:
  const std::string& _internal_collectionname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collectionname(const std::string& value);
  std::string* _internal_mutable_collectionname();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 property_version = 5;
  void clear_property_version();
  uint64_t property_version() const;
  void set_property_version(uint64_t value);
  private:
  uint64_t _internal_property_version() const;
  void _internal_set_property_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.ClaimNftMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collectionname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t property_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class TortugaClaim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TortugaClaim) */ {
 public:
  inline TortugaClaim() : TortugaClaim(nullptr) {}
  ~TortugaClaim() override;
  explicit constexpr TortugaClaim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TortugaClaim(const TortugaClaim& from);
  TortugaClaim(TortugaClaim&& from) noexcept
    : TortugaClaim() {
    *this = ::std::move(from);
  }

  inline TortugaClaim& operator=(const TortugaClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline TortugaClaim& operator=(TortugaClaim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TortugaClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const TortugaClaim* internal_default_instance() {
    return reinterpret_cast<const TortugaClaim*>(
               &_TortugaClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TortugaClaim& a, TortugaClaim& b) {
    a.Swap(&b);
  }
  inline void Swap(TortugaClaim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TortugaClaim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TortugaClaim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TortugaClaim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TortugaClaim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TortugaClaim& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TortugaClaim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TortugaClaim";
  }
  protected:
  explicit TortugaClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // uint64 idx = 1;
  void clear_idx();
  uint64_t idx() const;
  void set_idx(uint64_t value);
  private:
  uint64_t _internal_idx() const;
  void _internal_set_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TortugaClaim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class TortugaStake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TortugaStake) */ {
 public:
  inline TortugaStake() : TortugaStake(nullptr) {}
  ~TortugaStake() override;
  explicit constexpr TortugaStake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TortugaStake(const TortugaStake& from);
  TortugaStake(TortugaStake&& from) noexcept
    : TortugaStake() {
    *this = ::std::move(from);
  }

  inline TortugaStake& operator=(const TortugaStake& from) {
    CopyFrom(from);
    return *this;
  }
  inline TortugaStake& operator=(TortugaStake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TortugaStake& default_instance() {
    return *internal_default_instance();
  }
  static inline const TortugaStake* internal_default_instance() {
    return reinterpret_cast<const TortugaStake*>(
               &_TortugaStake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TortugaStake& a, TortugaStake& b) {
    a.Swap(&b);
  }
  inline void Swap(TortugaStake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TortugaStake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TortugaStake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TortugaStake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TortugaStake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TortugaStake& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TortugaStake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TortugaStake";
  }
  protected:
  explicit TortugaStake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
  };
  // uint64 amount = 1;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TortugaStake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class TortugaUnstake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TortugaUnstake) */ {
 public:
  inline TortugaUnstake() : TortugaUnstake(nullptr) {}
  ~TortugaUnstake() override;
  explicit constexpr TortugaUnstake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TortugaUnstake(const TortugaUnstake& from);
  TortugaUnstake(TortugaUnstake&& from) noexcept
    : TortugaUnstake() {
    *this = ::std::move(from);
  }

  inline TortugaUnstake& operator=(const TortugaUnstake& from) {
    CopyFrom(from);
    return *this;
  }
  inline TortugaUnstake& operator=(TortugaUnstake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TortugaUnstake& default_instance() {
    return *internal_default_instance();
  }
  static inline const TortugaUnstake* internal_default_instance() {
    return reinterpret_cast<const TortugaUnstake*>(
               &_TortugaUnstake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TortugaUnstake& a, TortugaUnstake& b) {
    a.Swap(&b);
  }
  inline void Swap(TortugaUnstake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TortugaUnstake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TortugaUnstake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TortugaUnstake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TortugaUnstake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TortugaUnstake& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TortugaUnstake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TortugaUnstake";
  }
  protected:
  explicit TortugaUnstake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
  };
  // uint64 amount = 1;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TortugaUnstake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class LiquidStaking final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.LiquidStaking) */ {
 public:
  inline LiquidStaking() : LiquidStaking(nullptr) {}
  ~LiquidStaking() override;
  explicit constexpr LiquidStaking(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiquidStaking(const LiquidStaking& from);
  LiquidStaking(LiquidStaking&& from) noexcept
    : LiquidStaking() {
    *this = ::std::move(from);
  }

  inline LiquidStaking& operator=(const LiquidStaking& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiquidStaking& operator=(LiquidStaking&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiquidStaking& default_instance() {
    return *internal_default_instance();
  }
  enum LiquidStakeTransactionPayloadCase {
    kStake = 2,
    kUnstake = 3,
    kClaim = 4,
    LIQUID_STAKE_TRANSACTION_PAYLOAD_NOT_SET = 0,
  };

  static inline const LiquidStaking* internal_default_instance() {
    return reinterpret_cast<const LiquidStaking*>(
               &_LiquidStaking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LiquidStaking& a, LiquidStaking& b) {
    a.Swap(&b);
  }
  inline void Swap(LiquidStaking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiquidStaking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiquidStaking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiquidStaking>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiquidStaking& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiquidStaking& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiquidStaking* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.LiquidStaking";
  }
  protected:
  explicit LiquidStaking(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmartContractAddressFieldNumber = 1,
    kStakeFieldNumber = 2,
    kUnstakeFieldNumber = 3,
    kClaimFieldNumber = 4,
  };
  // string smart_contract_address = 1;
  void clear_smart_contract_address();
  const std::string& smart_contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract_address();
  PROTOBUF_NODISCARD std::string* release_smart_contract_address();
  void set_allocated_smart_contract_address(std::string* smart_contract_address);
  private:
  const std::string& _internal_smart_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract_address(const std::string& value);
  std::string* _internal_mutable_smart_contract_address();
  public:

  // .TW.Aptos.Proto.TortugaStake stake = 2;
  bool has_stake() const;
  private:
  bool _internal_has_stake() const;
  public:
  void clear_stake();
  const ::TW::Aptos::Proto::TortugaStake& stake() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TortugaStake* release_stake();
  ::TW::Aptos::Proto::TortugaStake* mutable_stake();
  void set_allocated_stake(::TW::Aptos::Proto::TortugaStake* stake);
  private:
  const ::TW::Aptos::Proto::TortugaStake& _internal_stake() const;
  ::TW::Aptos::Proto::TortugaStake* _internal_mutable_stake();
  public:
  void unsafe_arena_set_allocated_stake(
      ::TW::Aptos::Proto::TortugaStake* stake);
  ::TW::Aptos::Proto::TortugaStake* unsafe_arena_release_stake();

  // .TW.Aptos.Proto.TortugaUnstake unstake = 3;
  bool has_unstake() const;
  private:
  bool _internal_has_unstake() const;
  public:
  void clear_unstake();
  const ::TW::Aptos::Proto::TortugaUnstake& unstake() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TortugaUnstake* release_unstake();
  ::TW::Aptos::Proto::TortugaUnstake* mutable_unstake();
  void set_allocated_unstake(::TW::Aptos::Proto::TortugaUnstake* unstake);
  private:
  const ::TW::Aptos::Proto::TortugaUnstake& _internal_unstake() const;
  ::TW::Aptos::Proto::TortugaUnstake* _internal_mutable_unstake();
  public:
  void unsafe_arena_set_allocated_unstake(
      ::TW::Aptos::Proto::TortugaUnstake* unstake);
  ::TW::Aptos::Proto::TortugaUnstake* unsafe_arena_release_unstake();

  // .TW.Aptos.Proto.TortugaClaim claim = 4;
  bool has_claim() const;
  private:
  bool _internal_has_claim() const;
  public:
  void clear_claim();
  const ::TW::Aptos::Proto::TortugaClaim& claim() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TortugaClaim* release_claim();
  ::TW::Aptos::Proto::TortugaClaim* mutable_claim();
  void set_allocated_claim(::TW::Aptos::Proto::TortugaClaim* claim);
  private:
  const ::TW::Aptos::Proto::TortugaClaim& _internal_claim() const;
  ::TW::Aptos::Proto::TortugaClaim* _internal_mutable_claim();
  public:
  void unsafe_arena_set_allocated_claim(
      ::TW::Aptos::Proto::TortugaClaim* claim);
  ::TW::Aptos::Proto::TortugaClaim* unsafe_arena_release_claim();

  void clear_liquid_stake_transaction_payload();
  LiquidStakeTransactionPayloadCase liquid_stake_transaction_payload_case() const;
  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.LiquidStaking)
 private:
  class _Internal;
  void set_has_stake();
  void set_has_unstake();
  void set_has_claim();

  inline bool has_liquid_stake_transaction_payload() const;
  inline void clear_has_liquid_stake_transaction_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_address_;
  union LiquidStakeTransactionPayloadUnion {
    constexpr LiquidStakeTransactionPayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Aptos::Proto::TortugaStake* stake_;
    ::TW::Aptos::Proto::TortugaUnstake* unstake_;
    ::TW::Aptos::Proto::TortugaClaim* claim_;
  } liquid_stake_transaction_payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class NftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.NftMessage) */ {
 public:
  inline NftMessage() : NftMessage(nullptr) {}
  ~NftMessage() override;
  explicit constexpr NftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NftMessage(const NftMessage& from);
  NftMessage(NftMessage&& from) noexcept
    : NftMessage() {
    *this = ::std::move(from);
  }

  inline NftMessage& operator=(const NftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NftMessage& operator=(NftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NftMessage& default_instance() {
    return *internal_default_instance();
  }
  enum NftTransactionPayloadCase {
    kOfferNft = 1,
    kCancelOfferNft = 2,
    kClaimNft = 3,
    NFT_TRANSACTION_PAYLOAD_NOT_SET = 0,
  };

  static inline const NftMessage* internal_default_instance() {
    return reinterpret_cast<const NftMessage*>(
               &_NftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NftMessage& a, NftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NftMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NftMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NftMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.NftMessage";
  }
  protected:
  explicit NftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfferNftFieldNumber = 1,
    kCancelOfferNftFieldNumber = 2,
    kClaimNftFieldNumber = 3,
  };
  // .TW.Aptos.Proto.OfferNftMessage offer_nft = 1;
  bool has_offer_nft() const;
  private:
  bool _internal_has_offer_nft() const;
  public:
  void clear_offer_nft();
  const ::TW::Aptos::Proto::OfferNftMessage& offer_nft() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::OfferNftMessage* release_offer_nft();
  ::TW::Aptos::Proto::OfferNftMessage* mutable_offer_nft();
  void set_allocated_offer_nft(::TW::Aptos::Proto::OfferNftMessage* offer_nft);
  private:
  const ::TW::Aptos::Proto::OfferNftMessage& _internal_offer_nft() const;
  ::TW::Aptos::Proto::OfferNftMessage* _internal_mutable_offer_nft();
  public:
  void unsafe_arena_set_allocated_offer_nft(
      ::TW::Aptos::Proto::OfferNftMessage* offer_nft);
  ::TW::Aptos::Proto::OfferNftMessage* unsafe_arena_release_offer_nft();

  // .TW.Aptos.Proto.CancelOfferNftMessage cancel_offer_nft = 2;
  bool has_cancel_offer_nft() const;
  private:
  bool _internal_has_cancel_offer_nft() const;
  public:
  void clear_cancel_offer_nft();
  const ::TW::Aptos::Proto::CancelOfferNftMessage& cancel_offer_nft() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::CancelOfferNftMessage* release_cancel_offer_nft();
  ::TW::Aptos::Proto::CancelOfferNftMessage* mutable_cancel_offer_nft();
  void set_allocated_cancel_offer_nft(::TW::Aptos::Proto::CancelOfferNftMessage* cancel_offer_nft);
  private:
  const ::TW::Aptos::Proto::CancelOfferNftMessage& _internal_cancel_offer_nft() const;
  ::TW::Aptos::Proto::CancelOfferNftMessage* _internal_mutable_cancel_offer_nft();
  public:
  void unsafe_arena_set_allocated_cancel_offer_nft(
      ::TW::Aptos::Proto::CancelOfferNftMessage* cancel_offer_nft);
  ::TW::Aptos::Proto::CancelOfferNftMessage* unsafe_arena_release_cancel_offer_nft();

  // .TW.Aptos.Proto.ClaimNftMessage claim_nft = 3;
  bool has_claim_nft() const;
  private:
  bool _internal_has_claim_nft() const;
  public:
  void clear_claim_nft();
  const ::TW::Aptos::Proto::ClaimNftMessage& claim_nft() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::ClaimNftMessage* release_claim_nft();
  ::TW::Aptos::Proto::ClaimNftMessage* mutable_claim_nft();
  void set_allocated_claim_nft(::TW::Aptos::Proto::ClaimNftMessage* claim_nft);
  private:
  const ::TW::Aptos::Proto::ClaimNftMessage& _internal_claim_nft() const;
  ::TW::Aptos::Proto::ClaimNftMessage* _internal_mutable_claim_nft();
  public:
  void unsafe_arena_set_allocated_claim_nft(
      ::TW::Aptos::Proto::ClaimNftMessage* claim_nft);
  ::TW::Aptos::Proto::ClaimNftMessage* unsafe_arena_release_claim_nft();

  void clear_nft_transaction_payload();
  NftTransactionPayloadCase nft_transaction_payload_case() const;
  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.NftMessage)
 private:
  class _Internal;
  void set_has_offer_nft();
  void set_has_cancel_offer_nft();
  void set_has_claim_nft();

  inline bool has_nft_transaction_payload() const;
  inline void clear_has_nft_transaction_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union NftTransactionPayloadUnion {
    constexpr NftTransactionPayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Aptos::Proto::OfferNftMessage* offer_nft_;
    ::TW::Aptos::Proto::CancelOfferNftMessage* cancel_offer_nft_;
    ::TW::Aptos::Proto::ClaimNftMessage* claim_nft_;
  } nft_transaction_payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class SigningInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.SigningInput) */ {
 public:
  inline SigningInput() : SigningInput(nullptr) {}
  ~SigningInput() override;
  explicit constexpr SigningInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningInput(const SigningInput& from);
  SigningInput(SigningInput&& from) noexcept
    : SigningInput() {
    *this = ::std::move(from);
  }

  inline SigningInput& operator=(const SigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningInput& operator=(SigningInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningInput& default_instance() {
    return *internal_default_instance();
  }
  enum TransactionPayloadCase {
    kTransfer = 9,
    kTokenTransfer = 10,
    kCreateAccount = 11,
    kNftMessage = 12,
    kRegisterToken = 13,
    kLiquidStakingMessage = 14,
    kTokenTransferCoins = 15,
    TRANSACTION_PAYLOAD_NOT_SET = 0,
  };

  static inline const SigningInput* internal_default_instance() {
    return reinterpret_cast<const SigningInput*>(
               &_SigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SigningInput& a, SigningInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.SigningInput";
  }
  protected:
  explicit SigningInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kPrivateKeyFieldNumber = 7,
    kAnyEncodedFieldNumber = 8,
    kSequenceNumberFieldNumber = 2,
    kMaxGasAmountFieldNumber = 3,
    kGasUnitPriceFieldNumber = 4,
    kExpirationTimestampSecsFieldNumber = 5,
    kChainIdFieldNumber = 6,
    kTransferFieldNumber = 9,
    kTokenTransferFieldNumber = 10,
    kCreateAccountFieldNumber = 11,
    kNftMessageFieldNumber = 12,
    kRegisterTokenFieldNumber = 13,
    kLiquidStakingMessageFieldNumber = 14,
    kTokenTransferCoinsFieldNumber = 15,
  };
  // string sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // bytes private_key = 7;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // string any_encoded = 8;
  void clear_any_encoded();
  const std::string& any_encoded() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_any_encoded(ArgT0&& arg0, ArgT... args);
  std::string* mutable_any_encoded();
  PROTOBUF_NODISCARD std::string* release_any_encoded();
  void set_allocated_any_encoded(std::string* any_encoded);
  private:
  const std::string& _internal_any_encoded() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_any_encoded(const std::string& value);
  std::string* _internal_mutable_any_encoded();
  public:

  // int64 sequence_number = 2;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // uint64 max_gas_amount = 3;
  void clear_max_gas_amount();
  uint64_t max_gas_amount() const;
  void set_max_gas_amount(uint64_t value);
  private:
  uint64_t _internal_max_gas_amount() const;
  void _internal_set_max_gas_amount(uint64_t value);
  public:

  // uint64 gas_unit_price = 4;
  void clear_gas_unit_price();
  uint64_t gas_unit_price() const;
  void set_gas_unit_price(uint64_t value);
  private:
  uint64_t _internal_gas_unit_price() const;
  void _internal_set_gas_unit_price(uint64_t value);
  public:

  // uint64 expiration_timestamp_secs = 5;
  void clear_expiration_timestamp_secs();
  uint64_t expiration_timestamp_secs() const;
  void set_expiration_timestamp_secs(uint64_t value);
  private:
  uint64_t _internal_expiration_timestamp_secs() const;
  void _internal_set_expiration_timestamp_secs(uint64_t value);
  public:

  // uint32 chain_id = 6;
  void clear_chain_id();
  uint32_t chain_id() const;
  void set_chain_id(uint32_t value);
  private:
  uint32_t _internal_chain_id() const;
  void _internal_set_chain_id(uint32_t value);
  public:

  // .TW.Aptos.Proto.TransferMessage transfer = 9;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::TW::Aptos::Proto::TransferMessage& transfer() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TransferMessage* release_transfer();
  ::TW::Aptos::Proto::TransferMessage* mutable_transfer();
  void set_allocated_transfer(::TW::Aptos::Proto::TransferMessage* transfer);
  private:
  const ::TW::Aptos::Proto::TransferMessage& _internal_transfer() const;
  ::TW::Aptos::Proto::TransferMessage* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::TW::Aptos::Proto::TransferMessage* transfer);
  ::TW::Aptos::Proto::TransferMessage* unsafe_arena_release_transfer();

  // .TW.Aptos.Proto.TokenTransferMessage token_transfer = 10;
  bool has_token_transfer() const;
  private:
  bool _internal_has_token_transfer() const;
  public:
  void clear_token_transfer();
  const ::TW::Aptos::Proto::TokenTransferMessage& token_transfer() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TokenTransferMessage* release_token_transfer();
  ::TW::Aptos::Proto::TokenTransferMessage* mutable_token_transfer();
  void set_allocated_token_transfer(::TW::Aptos::Proto::TokenTransferMessage* token_transfer);
  private:
  const ::TW::Aptos::Proto::TokenTransferMessage& _internal_token_transfer() const;
  ::TW::Aptos::Proto::TokenTransferMessage* _internal_mutable_token_transfer();
  public:
  void unsafe_arena_set_allocated_token_transfer(
      ::TW::Aptos::Proto::TokenTransferMessage* token_transfer);
  ::TW::Aptos::Proto::TokenTransferMessage* unsafe_arena_release_token_transfer();

  // .TW.Aptos.Proto.CreateAccountMessage create_account = 11;
  bool has_create_account() const;
  private:
  bool _internal_has_create_account() const;
  public:
  void clear_create_account();
  const ::TW::Aptos::Proto::CreateAccountMessage& create_account() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::CreateAccountMessage* release_create_account();
  ::TW::Aptos::Proto::CreateAccountMessage* mutable_create_account();
  void set_allocated_create_account(::TW::Aptos::Proto::CreateAccountMessage* create_account);
  private:
  const ::TW::Aptos::Proto::CreateAccountMessage& _internal_create_account() const;
  ::TW::Aptos::Proto::CreateAccountMessage* _internal_mutable_create_account();
  public:
  void unsafe_arena_set_allocated_create_account(
      ::TW::Aptos::Proto::CreateAccountMessage* create_account);
  ::TW::Aptos::Proto::CreateAccountMessage* unsafe_arena_release_create_account();

  // .TW.Aptos.Proto.NftMessage nft_message = 12;
  bool has_nft_message() const;
  private:
  bool _internal_has_nft_message() const;
  public:
  void clear_nft_message();
  const ::TW::Aptos::Proto::NftMessage& nft_message() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::NftMessage* release_nft_message();
  ::TW::Aptos::Proto::NftMessage* mutable_nft_message();
  void set_allocated_nft_message(::TW::Aptos::Proto::NftMessage* nft_message);
  private:
  const ::TW::Aptos::Proto::NftMessage& _internal_nft_message() const;
  ::TW::Aptos::Proto::NftMessage* _internal_mutable_nft_message();
  public:
  void unsafe_arena_set_allocated_nft_message(
      ::TW::Aptos::Proto::NftMessage* nft_message);
  ::TW::Aptos::Proto::NftMessage* unsafe_arena_release_nft_message();

  // .TW.Aptos.Proto.ManagedTokensRegisterMessage register_token = 13;
  bool has_register_token() const;
  private:
  bool _internal_has_register_token() const;
  public:
  void clear_register_token();
  const ::TW::Aptos::Proto::ManagedTokensRegisterMessage& register_token() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::ManagedTokensRegisterMessage* release_register_token();
  ::TW::Aptos::Proto::ManagedTokensRegisterMessage* mutable_register_token();
  void set_allocated_register_token(::TW::Aptos::Proto::ManagedTokensRegisterMessage* register_token);
  private:
  const ::TW::Aptos::Proto::ManagedTokensRegisterMessage& _internal_register_token() const;
  ::TW::Aptos::Proto::ManagedTokensRegisterMessage* _internal_mutable_register_token();
  public:
  void unsafe_arena_set_allocated_register_token(
      ::TW::Aptos::Proto::ManagedTokensRegisterMessage* register_token);
  ::TW::Aptos::Proto::ManagedTokensRegisterMessage* unsafe_arena_release_register_token();

  // .TW.Aptos.Proto.LiquidStaking liquid_staking_message = 14;
  bool has_liquid_staking_message() const;
  private:
  bool _internal_has_liquid_staking_message() const;
  public:
  void clear_liquid_staking_message();
  const ::TW::Aptos::Proto::LiquidStaking& liquid_staking_message() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::LiquidStaking* release_liquid_staking_message();
  ::TW::Aptos::Proto::LiquidStaking* mutable_liquid_staking_message();
  void set_allocated_liquid_staking_message(::TW::Aptos::Proto::LiquidStaking* liquid_staking_message);
  private:
  const ::TW::Aptos::Proto::LiquidStaking& _internal_liquid_staking_message() const;
  ::TW::Aptos::Proto::LiquidStaking* _internal_mutable_liquid_staking_message();
  public:
  void unsafe_arena_set_allocated_liquid_staking_message(
      ::TW::Aptos::Proto::LiquidStaking* liquid_staking_message);
  ::TW::Aptos::Proto::LiquidStaking* unsafe_arena_release_liquid_staking_message();

  // .TW.Aptos.Proto.TokenTransferCoinsMessage token_transfer_coins = 15;
  bool has_token_transfer_coins() const;
  private:
  bool _internal_has_token_transfer_coins() const;
  public:
  void clear_token_transfer_coins();
  const ::TW::Aptos::Proto::TokenTransferCoinsMessage& token_transfer_coins() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TokenTransferCoinsMessage* release_token_transfer_coins();
  ::TW::Aptos::Proto::TokenTransferCoinsMessage* mutable_token_transfer_coins();
  void set_allocated_token_transfer_coins(::TW::Aptos::Proto::TokenTransferCoinsMessage* token_transfer_coins);
  private:
  const ::TW::Aptos::Proto::TokenTransferCoinsMessage& _internal_token_transfer_coins() const;
  ::TW::Aptos::Proto::TokenTransferCoinsMessage* _internal_mutable_token_transfer_coins();
  public:
  void unsafe_arena_set_allocated_token_transfer_coins(
      ::TW::Aptos::Proto::TokenTransferCoinsMessage* token_transfer_coins);
  ::TW::Aptos::Proto::TokenTransferCoinsMessage* unsafe_arena_release_token_transfer_coins();

  void clear_transaction_payload();
  TransactionPayloadCase transaction_payload_case() const;
  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.SigningInput)
 private:
  class _Internal;
  void set_has_transfer();
  void set_has_token_transfer();
  void set_has_create_account();
  void set_has_nft_message();
  void set_has_register_token();
  void set_has_liquid_staking_message();
  void set_has_token_transfer_coins();

  inline bool has_transaction_payload() const;
  inline void clear_has_transaction_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr any_encoded_;
  int64_t sequence_number_;
  uint64_t max_gas_amount_;
  uint64_t gas_unit_price_;
  uint64_t expiration_timestamp_secs_;
  uint32_t chain_id_;
  union TransactionPayloadUnion {
    constexpr TransactionPayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Aptos::Proto::TransferMessage* transfer_;
    ::TW::Aptos::Proto::TokenTransferMessage* token_transfer_;
    ::TW::Aptos::Proto::CreateAccountMessage* create_account_;
    ::TW::Aptos::Proto::NftMessage* nft_message_;
    ::TW::Aptos::Proto::ManagedTokensRegisterMessage* register_token_;
    ::TW::Aptos::Proto::LiquidStaking* liquid_staking_message_;
    ::TW::Aptos::Proto::TokenTransferCoinsMessage* token_transfer_coins_;
  } transaction_payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class TransactionAuthenticator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.TransactionAuthenticator) */ {
 public:
  inline TransactionAuthenticator() : TransactionAuthenticator(nullptr) {}
  ~TransactionAuthenticator() override;
  explicit constexpr TransactionAuthenticator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionAuthenticator(const TransactionAuthenticator& from);
  TransactionAuthenticator(TransactionAuthenticator&& from) noexcept
    : TransactionAuthenticator() {
    *this = ::std::move(from);
  }

  inline TransactionAuthenticator& operator=(const TransactionAuthenticator& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionAuthenticator& operator=(TransactionAuthenticator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionAuthenticator& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionAuthenticator* internal_default_instance() {
    return reinterpret_cast<const TransactionAuthenticator*>(
               &_TransactionAuthenticator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransactionAuthenticator& a, TransactionAuthenticator& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionAuthenticator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionAuthenticator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionAuthenticator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionAuthenticator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionAuthenticator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionAuthenticator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionAuthenticator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.TransactionAuthenticator";
  }
  protected:
  explicit TransactionAuthenticator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes public_key = 2;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.TransactionAuthenticator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// -------------------------------------------------------------------

class SigningOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Aptos.Proto.SigningOutput) */ {
 public:
  inline SigningOutput() : SigningOutput(nullptr) {}
  ~SigningOutput() override;
  explicit constexpr SigningOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningOutput(const SigningOutput& from);
  SigningOutput(SigningOutput&& from) noexcept
    : SigningOutput() {
    *this = ::std::move(from);
  }

  inline SigningOutput& operator=(const SigningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningOutput& operator=(SigningOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningOutput* internal_default_instance() {
    return reinterpret_cast<const SigningOutput*>(
               &_SigningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SigningOutput& a, SigningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Aptos.Proto.SigningOutput";
  }
  protected:
  explicit SigningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawTxnFieldNumber = 1,
    kEncodedFieldNumber = 3,
    kJsonFieldNumber = 4,
    kErrorMessageFieldNumber = 6,
    kAuthenticatorFieldNumber = 2,
    kErrorFieldNumber = 5,
  };
  // bytes raw_txn = 1;
  void clear_raw_txn();
  const std::string& raw_txn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_txn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_txn();
  PROTOBUF_NODISCARD std::string* release_raw_txn();
  void set_allocated_raw_txn(std::string* raw_txn);
  private:
  const std::string& _internal_raw_txn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_txn(const std::string& value);
  std::string* _internal_mutable_raw_txn();
  public:

  // bytes encoded = 3;
  void clear_encoded();
  const std::string& encoded() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded();
  PROTOBUF_NODISCARD std::string* release_encoded();
  void set_allocated_encoded(std::string* encoded);
  private:
  const std::string& _internal_encoded() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded(const std::string& value);
  std::string* _internal_mutable_encoded();
  public:

  // string json = 4;
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // string error_message = 6;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .TW.Aptos.Proto.TransactionAuthenticator authenticator = 2;
  bool has_authenticator() const;
  private:
  bool _internal_has_authenticator() const;
  public:
  void clear_authenticator();
  const ::TW::Aptos::Proto::TransactionAuthenticator& authenticator() const;
  PROTOBUF_NODISCARD ::TW::Aptos::Proto::TransactionAuthenticator* release_authenticator();
  ::TW::Aptos::Proto::TransactionAuthenticator* mutable_authenticator();
  void set_allocated_authenticator(::TW::Aptos::Proto::TransactionAuthenticator* authenticator);
  private:
  const ::TW::Aptos::Proto::TransactionAuthenticator& _internal_authenticator() const;
  ::TW::Aptos::Proto::TransactionAuthenticator* _internal_mutable_authenticator();
  public:
  void unsafe_arena_set_allocated_authenticator(
      ::TW::Aptos::Proto::TransactionAuthenticator* authenticator);
  ::TW::Aptos::Proto::TransactionAuthenticator* unsafe_arena_release_authenticator();

  // .TW.Common.Proto.SigningError error = 5;
  void clear_error();
  ::TW::Common::Proto::SigningError error() const;
  void set_error(::TW::Common::Proto::SigningError value);
  private:
  ::TW::Common::Proto::SigningError _internal_error() const;
  void _internal_set_error(::TW::Common::Proto::SigningError value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Aptos.Proto.SigningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_txn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::TW::Aptos::Proto::TransactionAuthenticator* authenticator_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Aptos_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransferMessage

// string to = 1;
inline void TransferMessage::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& TransferMessage::to() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TransferMessage.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferMessage::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TransferMessage.to)
}
inline std::string* TransferMessage::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TransferMessage.to)
  return _s;
}
inline const std::string& TransferMessage::_internal_to() const {
  return to_.Get();
}
inline void TransferMessage::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferMessage::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferMessage::release_to() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TransferMessage.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TransferMessage.to)
}

// uint64 amount = 2;
inline void TransferMessage::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TransferMessage::_internal_amount() const {
  return amount_;
}
inline uint64_t TransferMessage::amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TransferMessage.amount)
  return _internal_amount();
}
inline void TransferMessage::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TransferMessage::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TransferMessage.amount)
}

// -------------------------------------------------------------------

// StructTag

// string account_address = 1;
inline void StructTag::clear_account_address() {
  account_address_.ClearToEmpty();
}
inline const std::string& StructTag::account_address() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.StructTag.account_address)
  return _internal_account_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructTag::set_account_address(ArgT0&& arg0, ArgT... args) {
 
 account_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.StructTag.account_address)
}
inline std::string* StructTag::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.StructTag.account_address)
  return _s;
}
inline const std::string& StructTag::_internal_account_address() const {
  return account_address_.Get();
}
inline void StructTag::_internal_set_account_address(const std::string& value) {
  
  account_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructTag::_internal_mutable_account_address() {
  
  return account_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructTag::release_account_address() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.StructTag.account_address)
  return account_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructTag::set_allocated_account_address(std::string* account_address) {
  if (account_address != nullptr) {
    
  } else {
    
  }
  account_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.StructTag.account_address)
}

// string module = 2;
inline void StructTag::clear_module() {
  module_.ClearToEmpty();
}
inline const std::string& StructTag::module() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.StructTag.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructTag::set_module(ArgT0&& arg0, ArgT... args) {
 
 module_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.StructTag.module)
}
inline std::string* StructTag::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.StructTag.module)
  return _s;
}
inline const std::string& StructTag::_internal_module() const {
  return module_.Get();
}
inline void StructTag::_internal_set_module(const std::string& value) {
  
  module_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructTag::_internal_mutable_module() {
  
  return module_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructTag::release_module() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.StructTag.module)
  return module_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructTag::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  module_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), module,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    module_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.StructTag.module)
}

// string name = 3;
inline void StructTag::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& StructTag::name() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.StructTag.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructTag::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.StructTag.name)
}
inline std::string* StructTag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.StructTag.name)
  return _s;
}
inline const std::string& StructTag::_internal_name() const {
  return name_.Get();
}
inline void StructTag::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StructTag::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StructTag::release_name() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.StructTag.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StructTag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.StructTag.name)
}

// -------------------------------------------------------------------

// TokenTransferMessage

// string to = 1;
inline void TokenTransferMessage::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& TokenTransferMessage::to() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TokenTransferMessage.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenTransferMessage::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TokenTransferMessage.to)
}
inline std::string* TokenTransferMessage::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TokenTransferMessage.to)
  return _s;
}
inline const std::string& TokenTransferMessage::_internal_to() const {
  return to_.Get();
}
inline void TokenTransferMessage::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenTransferMessage::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenTransferMessage::release_to() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TokenTransferMessage.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenTransferMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TokenTransferMessage.to)
}

// uint64 amount = 2;
inline void TokenTransferMessage::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TokenTransferMessage::_internal_amount() const {
  return amount_;
}
inline uint64_t TokenTransferMessage::amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TokenTransferMessage.amount)
  return _internal_amount();
}
inline void TokenTransferMessage::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TokenTransferMessage::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TokenTransferMessage.amount)
}

// .TW.Aptos.Proto.StructTag function = 3;
inline bool TokenTransferMessage::_internal_has_function() const {
  return this != internal_default_instance() && function_ != nullptr;
}
inline bool TokenTransferMessage::has_function() const {
  return _internal_has_function();
}
inline void TokenTransferMessage::clear_function() {
  if (GetArenaForAllocation() == nullptr && function_ != nullptr) {
    delete function_;
  }
  function_ = nullptr;
}
inline const ::TW::Aptos::Proto::StructTag& TokenTransferMessage::_internal_function() const {
  const ::TW::Aptos::Proto::StructTag* p = function_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Aptos::Proto::StructTag&>(
      ::TW::Aptos::Proto::_StructTag_default_instance_);
}
inline const ::TW::Aptos::Proto::StructTag& TokenTransferMessage::function() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TokenTransferMessage.function)
  return _internal_function();
}
inline void TokenTransferMessage::unsafe_arena_set_allocated_function(
    ::TW::Aptos::Proto::StructTag* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_);
  }
  function_ = function;
  if (function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.TokenTransferMessage.function)
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferMessage::release_function() {
  
  ::TW::Aptos::Proto::StructTag* temp = function_;
  function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferMessage::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TokenTransferMessage.function)
  
  ::TW::Aptos::Proto::StructTag* temp = function_;
  function_ = nullptr;
  return temp;
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferMessage::_internal_mutable_function() {
  
  if (function_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Aptos::Proto::StructTag>(GetArenaForAllocation());
    function_ = p;
  }
  return function_;
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferMessage::mutable_function() {
  ::TW::Aptos::Proto::StructTag* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TokenTransferMessage.function)
  return _msg;
}
inline void TokenTransferMessage::set_allocated_function(::TW::Aptos::Proto::StructTag* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Aptos::Proto::StructTag>::GetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  function_ = function;
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TokenTransferMessage.function)
}

// -------------------------------------------------------------------

// TokenTransferCoinsMessage

// string to = 1;
inline void TokenTransferCoinsMessage::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& TokenTransferCoinsMessage::to() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TokenTransferCoinsMessage.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenTransferCoinsMessage::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TokenTransferCoinsMessage.to)
}
inline std::string* TokenTransferCoinsMessage::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TokenTransferCoinsMessage.to)
  return _s;
}
inline const std::string& TokenTransferCoinsMessage::_internal_to() const {
  return to_.Get();
}
inline void TokenTransferCoinsMessage::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenTransferCoinsMessage::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenTransferCoinsMessage::release_to() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TokenTransferCoinsMessage.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenTransferCoinsMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TokenTransferCoinsMessage.to)
}

// uint64 amount = 2;
inline void TokenTransferCoinsMessage::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TokenTransferCoinsMessage::_internal_amount() const {
  return amount_;
}
inline uint64_t TokenTransferCoinsMessage::amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TokenTransferCoinsMessage.amount)
  return _internal_amount();
}
inline void TokenTransferCoinsMessage::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TokenTransferCoinsMessage::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TokenTransferCoinsMessage.amount)
}

// .TW.Aptos.Proto.StructTag function = 3;
inline bool TokenTransferCoinsMessage::_internal_has_function() const {
  return this != internal_default_instance() && function_ != nullptr;
}
inline bool TokenTransferCoinsMessage::has_function() const {
  return _internal_has_function();
}
inline void TokenTransferCoinsMessage::clear_function() {
  if (GetArenaForAllocation() == nullptr && function_ != nullptr) {
    delete function_;
  }
  function_ = nullptr;
}
inline const ::TW::Aptos::Proto::StructTag& TokenTransferCoinsMessage::_internal_function() const {
  const ::TW::Aptos::Proto::StructTag* p = function_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Aptos::Proto::StructTag&>(
      ::TW::Aptos::Proto::_StructTag_default_instance_);
}
inline const ::TW::Aptos::Proto::StructTag& TokenTransferCoinsMessage::function() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TokenTransferCoinsMessage.function)
  return _internal_function();
}
inline void TokenTransferCoinsMessage::unsafe_arena_set_allocated_function(
    ::TW::Aptos::Proto::StructTag* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_);
  }
  function_ = function;
  if (function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.TokenTransferCoinsMessage.function)
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferCoinsMessage::release_function() {
  
  ::TW::Aptos::Proto::StructTag* temp = function_;
  function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferCoinsMessage::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TokenTransferCoinsMessage.function)
  
  ::TW::Aptos::Proto::StructTag* temp = function_;
  function_ = nullptr;
  return temp;
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferCoinsMessage::_internal_mutable_function() {
  
  if (function_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Aptos::Proto::StructTag>(GetArenaForAllocation());
    function_ = p;
  }
  return function_;
}
inline ::TW::Aptos::Proto::StructTag* TokenTransferCoinsMessage::mutable_function() {
  ::TW::Aptos::Proto::StructTag* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TokenTransferCoinsMessage.function)
  return _msg;
}
inline void TokenTransferCoinsMessage::set_allocated_function(::TW::Aptos::Proto::StructTag* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Aptos::Proto::StructTag>::GetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  function_ = function;
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TokenTransferCoinsMessage.function)
}

// -------------------------------------------------------------------

// ManagedTokensRegisterMessage

// .TW.Aptos.Proto.StructTag function = 1;
inline bool ManagedTokensRegisterMessage::_internal_has_function() const {
  return this != internal_default_instance() && function_ != nullptr;
}
inline bool ManagedTokensRegisterMessage::has_function() const {
  return _internal_has_function();
}
inline void ManagedTokensRegisterMessage::clear_function() {
  if (GetArenaForAllocation() == nullptr && function_ != nullptr) {
    delete function_;
  }
  function_ = nullptr;
}
inline const ::TW::Aptos::Proto::StructTag& ManagedTokensRegisterMessage::_internal_function() const {
  const ::TW::Aptos::Proto::StructTag* p = function_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Aptos::Proto::StructTag&>(
      ::TW::Aptos::Proto::_StructTag_default_instance_);
}
inline const ::TW::Aptos::Proto::StructTag& ManagedTokensRegisterMessage::function() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.ManagedTokensRegisterMessage.function)
  return _internal_function();
}
inline void ManagedTokensRegisterMessage::unsafe_arena_set_allocated_function(
    ::TW::Aptos::Proto::StructTag* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_);
  }
  function_ = function;
  if (function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.ManagedTokensRegisterMessage.function)
}
inline ::TW::Aptos::Proto::StructTag* ManagedTokensRegisterMessage::release_function() {
  
  ::TW::Aptos::Proto::StructTag* temp = function_;
  function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Aptos::Proto::StructTag* ManagedTokensRegisterMessage::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.ManagedTokensRegisterMessage.function)
  
  ::TW::Aptos::Proto::StructTag* temp = function_;
  function_ = nullptr;
  return temp;
}
inline ::TW::Aptos::Proto::StructTag* ManagedTokensRegisterMessage::_internal_mutable_function() {
  
  if (function_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Aptos::Proto::StructTag>(GetArenaForAllocation());
    function_ = p;
  }
  return function_;
}
inline ::TW::Aptos::Proto::StructTag* ManagedTokensRegisterMessage::mutable_function() {
  ::TW::Aptos::Proto::StructTag* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.ManagedTokensRegisterMessage.function)
  return _msg;
}
inline void ManagedTokensRegisterMessage::set_allocated_function(::TW::Aptos::Proto::StructTag* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Aptos::Proto::StructTag>::GetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  function_ = function;
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.ManagedTokensRegisterMessage.function)
}

// -------------------------------------------------------------------

// CreateAccountMessage

// string auth_key = 1;
inline void CreateAccountMessage::clear_auth_key() {
  auth_key_.ClearToEmpty();
}
inline const std::string& CreateAccountMessage::auth_key() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.CreateAccountMessage.auth_key)
  return _internal_auth_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountMessage::set_auth_key(ArgT0&& arg0, ArgT... args) {
 
 auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.CreateAccountMessage.auth_key)
}
inline std::string* CreateAccountMessage::mutable_auth_key() {
  std::string* _s = _internal_mutable_auth_key();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.CreateAccountMessage.auth_key)
  return _s;
}
inline const std::string& CreateAccountMessage::_internal_auth_key() const {
  return auth_key_.Get();
}
inline void CreateAccountMessage::_internal_set_auth_key(const std::string& value) {
  
  auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::_internal_mutable_auth_key() {
  
  return auth_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::release_auth_key() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.CreateAccountMessage.auth_key)
  return auth_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateAccountMessage::set_allocated_auth_key(std::string* auth_key) {
  if (auth_key != nullptr) {
    
  } else {
    
  }
  auth_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.CreateAccountMessage.auth_key)
}

// -------------------------------------------------------------------

// OfferNftMessage

// string receiver = 1;
inline void OfferNftMessage::clear_receiver() {
  receiver_.ClearToEmpty();
}
inline const std::string& OfferNftMessage::receiver() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.OfferNftMessage.receiver)
  return _internal_receiver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfferNftMessage::set_receiver(ArgT0&& arg0, ArgT... args) {
 
 receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.OfferNftMessage.receiver)
}
inline std::string* OfferNftMessage::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.OfferNftMessage.receiver)
  return _s;
}
inline const std::string& OfferNftMessage::_internal_receiver() const {
  return receiver_.Get();
}
inline void OfferNftMessage::_internal_set_receiver(const std::string& value) {
  
  receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::_internal_mutable_receiver() {
  
  return receiver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::release_receiver() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.OfferNftMessage.receiver)
  return receiver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OfferNftMessage::set_allocated_receiver(std::string* receiver) {
  if (receiver != nullptr) {
    
  } else {
    
  }
  receiver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receiver_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receiver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.OfferNftMessage.receiver)
}

// string creator = 2;
inline void OfferNftMessage::clear_creator() {
  creator_.ClearToEmpty();
}
inline const std::string& OfferNftMessage::creator() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.OfferNftMessage.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfferNftMessage::set_creator(ArgT0&& arg0, ArgT... args) {
 
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.OfferNftMessage.creator)
}
inline std::string* OfferNftMessage::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.OfferNftMessage.creator)
  return _s;
}
inline const std::string& OfferNftMessage::_internal_creator() const {
  return creator_.Get();
}
inline void OfferNftMessage::_internal_set_creator(const std::string& value) {
  
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::_internal_mutable_creator() {
  
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::release_creator() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.OfferNftMessage.creator)
  return creator_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OfferNftMessage::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    
  } else {
    
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.OfferNftMessage.creator)
}

// string collectionName = 3;
inline void OfferNftMessage::clear_collectionname() {
  collectionname_.ClearToEmpty();
}
inline const std::string& OfferNftMessage::collectionname() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.OfferNftMessage.collectionName)
  return _internal_collectionname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfferNftMessage::set_collectionname(ArgT0&& arg0, ArgT... args) {
 
 collectionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.OfferNftMessage.collectionName)
}
inline std::string* OfferNftMessage::mutable_collectionname() {
  std::string* _s = _internal_mutable_collectionname();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.OfferNftMessage.collectionName)
  return _s;
}
inline const std::string& OfferNftMessage::_internal_collectionname() const {
  return collectionname_.Get();
}
inline void OfferNftMessage::_internal_set_collectionname(const std::string& value) {
  
  collectionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::_internal_mutable_collectionname() {
  
  return collectionname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::release_collectionname() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.OfferNftMessage.collectionName)
  return collectionname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OfferNftMessage::set_allocated_collectionname(std::string* collectionname) {
  if (collectionname != nullptr) {
    
  } else {
    
  }
  collectionname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collectionname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collectionname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    collectionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.OfferNftMessage.collectionName)
}

// string name = 4;
inline void OfferNftMessage::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& OfferNftMessage::name() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.OfferNftMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfferNftMessage::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.OfferNftMessage.name)
}
inline std::string* OfferNftMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.OfferNftMessage.name)
  return _s;
}
inline const std::string& OfferNftMessage::_internal_name() const {
  return name_.Get();
}
inline void OfferNftMessage::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OfferNftMessage::release_name() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.OfferNftMessage.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OfferNftMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.OfferNftMessage.name)
}

// uint64 property_version = 5;
inline void OfferNftMessage::clear_property_version() {
  property_version_ = uint64_t{0u};
}
inline uint64_t OfferNftMessage::_internal_property_version() const {
  return property_version_;
}
inline uint64_t OfferNftMessage::property_version() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.OfferNftMessage.property_version)
  return _internal_property_version();
}
inline void OfferNftMessage::_internal_set_property_version(uint64_t value) {
  
  property_version_ = value;
}
inline void OfferNftMessage::set_property_version(uint64_t value) {
  _internal_set_property_version(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.OfferNftMessage.property_version)
}

// uint64 amount = 6;
inline void OfferNftMessage::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t OfferNftMessage::_internal_amount() const {
  return amount_;
}
inline uint64_t OfferNftMessage::amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.OfferNftMessage.amount)
  return _internal_amount();
}
inline void OfferNftMessage::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void OfferNftMessage::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.OfferNftMessage.amount)
}

// -------------------------------------------------------------------

// CancelOfferNftMessage

// string receiver = 1;
inline void CancelOfferNftMessage::clear_receiver() {
  receiver_.ClearToEmpty();
}
inline const std::string& CancelOfferNftMessage::receiver() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.CancelOfferNftMessage.receiver)
  return _internal_receiver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOfferNftMessage::set_receiver(ArgT0&& arg0, ArgT... args) {
 
 receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.CancelOfferNftMessage.receiver)
}
inline std::string* CancelOfferNftMessage::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.CancelOfferNftMessage.receiver)
  return _s;
}
inline const std::string& CancelOfferNftMessage::_internal_receiver() const {
  return receiver_.Get();
}
inline void CancelOfferNftMessage::_internal_set_receiver(const std::string& value) {
  
  receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::_internal_mutable_receiver() {
  
  return receiver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::release_receiver() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.CancelOfferNftMessage.receiver)
  return receiver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOfferNftMessage::set_allocated_receiver(std::string* receiver) {
  if (receiver != nullptr) {
    
  } else {
    
  }
  receiver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receiver_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receiver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.CancelOfferNftMessage.receiver)
}

// string creator = 2;
inline void CancelOfferNftMessage::clear_creator() {
  creator_.ClearToEmpty();
}
inline const std::string& CancelOfferNftMessage::creator() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.CancelOfferNftMessage.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOfferNftMessage::set_creator(ArgT0&& arg0, ArgT... args) {
 
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.CancelOfferNftMessage.creator)
}
inline std::string* CancelOfferNftMessage::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.CancelOfferNftMessage.creator)
  return _s;
}
inline const std::string& CancelOfferNftMessage::_internal_creator() const {
  return creator_.Get();
}
inline void CancelOfferNftMessage::_internal_set_creator(const std::string& value) {
  
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::_internal_mutable_creator() {
  
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::release_creator() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.CancelOfferNftMessage.creator)
  return creator_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOfferNftMessage::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    
  } else {
    
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.CancelOfferNftMessage.creator)
}

// string collectionName = 3;
inline void CancelOfferNftMessage::clear_collectionname() {
  collectionname_.ClearToEmpty();
}
inline const std::string& CancelOfferNftMessage::collectionname() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.CancelOfferNftMessage.collectionName)
  return _internal_collectionname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOfferNftMessage::set_collectionname(ArgT0&& arg0, ArgT... args) {
 
 collectionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.CancelOfferNftMessage.collectionName)
}
inline std::string* CancelOfferNftMessage::mutable_collectionname() {
  std::string* _s = _internal_mutable_collectionname();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.CancelOfferNftMessage.collectionName)
  return _s;
}
inline const std::string& CancelOfferNftMessage::_internal_collectionname() const {
  return collectionname_.Get();
}
inline void CancelOfferNftMessage::_internal_set_collectionname(const std::string& value) {
  
  collectionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::_internal_mutable_collectionname() {
  
  return collectionname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::release_collectionname() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.CancelOfferNftMessage.collectionName)
  return collectionname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOfferNftMessage::set_allocated_collectionname(std::string* collectionname) {
  if (collectionname != nullptr) {
    
  } else {
    
  }
  collectionname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collectionname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collectionname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    collectionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.CancelOfferNftMessage.collectionName)
}

// string name = 4;
inline void CancelOfferNftMessage::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CancelOfferNftMessage::name() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.CancelOfferNftMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOfferNftMessage::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.CancelOfferNftMessage.name)
}
inline std::string* CancelOfferNftMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.CancelOfferNftMessage.name)
  return _s;
}
inline const std::string& CancelOfferNftMessage::_internal_name() const {
  return name_.Get();
}
inline void CancelOfferNftMessage::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOfferNftMessage::release_name() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.CancelOfferNftMessage.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOfferNftMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.CancelOfferNftMessage.name)
}

// uint64 property_version = 5;
inline void CancelOfferNftMessage::clear_property_version() {
  property_version_ = uint64_t{0u};
}
inline uint64_t CancelOfferNftMessage::_internal_property_version() const {
  return property_version_;
}
inline uint64_t CancelOfferNftMessage::property_version() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.CancelOfferNftMessage.property_version)
  return _internal_property_version();
}
inline void CancelOfferNftMessage::_internal_set_property_version(uint64_t value) {
  
  property_version_ = value;
}
inline void CancelOfferNftMessage::set_property_version(uint64_t value) {
  _internal_set_property_version(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.CancelOfferNftMessage.property_version)
}

// -------------------------------------------------------------------

// ClaimNftMessage

// string sender = 1;
inline void ClaimNftMessage::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& ClaimNftMessage::sender() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.ClaimNftMessage.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimNftMessage::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.ClaimNftMessage.sender)
}
inline std::string* ClaimNftMessage::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.ClaimNftMessage.sender)
  return _s;
}
inline const std::string& ClaimNftMessage::_internal_sender() const {
  return sender_.Get();
}
inline void ClaimNftMessage::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::release_sender() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.ClaimNftMessage.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClaimNftMessage::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.ClaimNftMessage.sender)
}

// string creator = 2;
inline void ClaimNftMessage::clear_creator() {
  creator_.ClearToEmpty();
}
inline const std::string& ClaimNftMessage::creator() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.ClaimNftMessage.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimNftMessage::set_creator(ArgT0&& arg0, ArgT... args) {
 
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.ClaimNftMessage.creator)
}
inline std::string* ClaimNftMessage::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.ClaimNftMessage.creator)
  return _s;
}
inline const std::string& ClaimNftMessage::_internal_creator() const {
  return creator_.Get();
}
inline void ClaimNftMessage::_internal_set_creator(const std::string& value) {
  
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::_internal_mutable_creator() {
  
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::release_creator() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.ClaimNftMessage.creator)
  return creator_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClaimNftMessage::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    
  } else {
    
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.ClaimNftMessage.creator)
}

// string collectionName = 3;
inline void ClaimNftMessage::clear_collectionname() {
  collectionname_.ClearToEmpty();
}
inline const std::string& ClaimNftMessage::collectionname() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.ClaimNftMessage.collectionName)
  return _internal_collectionname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimNftMessage::set_collectionname(ArgT0&& arg0, ArgT... args) {
 
 collectionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.ClaimNftMessage.collectionName)
}
inline std::string* ClaimNftMessage::mutable_collectionname() {
  std::string* _s = _internal_mutable_collectionname();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.ClaimNftMessage.collectionName)
  return _s;
}
inline const std::string& ClaimNftMessage::_internal_collectionname() const {
  return collectionname_.Get();
}
inline void ClaimNftMessage::_internal_set_collectionname(const std::string& value) {
  
  collectionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::_internal_mutable_collectionname() {
  
  return collectionname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::release_collectionname() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.ClaimNftMessage.collectionName)
  return collectionname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClaimNftMessage::set_allocated_collectionname(std::string* collectionname) {
  if (collectionname != nullptr) {
    
  } else {
    
  }
  collectionname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collectionname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collectionname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    collectionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.ClaimNftMessage.collectionName)
}

// string name = 4;
inline void ClaimNftMessage::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ClaimNftMessage::name() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.ClaimNftMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimNftMessage::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.ClaimNftMessage.name)
}
inline std::string* ClaimNftMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.ClaimNftMessage.name)
  return _s;
}
inline const std::string& ClaimNftMessage::_internal_name() const {
  return name_.Get();
}
inline void ClaimNftMessage::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClaimNftMessage::release_name() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.ClaimNftMessage.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClaimNftMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.ClaimNftMessage.name)
}

// uint64 property_version = 5;
inline void ClaimNftMessage::clear_property_version() {
  property_version_ = uint64_t{0u};
}
inline uint64_t ClaimNftMessage::_internal_property_version() const {
  return property_version_;
}
inline uint64_t ClaimNftMessage::property_version() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.ClaimNftMessage.property_version)
  return _internal_property_version();
}
inline void ClaimNftMessage::_internal_set_property_version(uint64_t value) {
  
  property_version_ = value;
}
inline void ClaimNftMessage::set_property_version(uint64_t value) {
  _internal_set_property_version(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.ClaimNftMessage.property_version)
}

// -------------------------------------------------------------------

// TortugaClaim

// uint64 idx = 1;
inline void TortugaClaim::clear_idx() {
  idx_ = uint64_t{0u};
}
inline uint64_t TortugaClaim::_internal_idx() const {
  return idx_;
}
inline uint64_t TortugaClaim::idx() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TortugaClaim.idx)
  return _internal_idx();
}
inline void TortugaClaim::_internal_set_idx(uint64_t value) {
  
  idx_ = value;
}
inline void TortugaClaim::set_idx(uint64_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TortugaClaim.idx)
}

// -------------------------------------------------------------------

// TortugaStake

// uint64 amount = 1;
inline void TortugaStake::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TortugaStake::_internal_amount() const {
  return amount_;
}
inline uint64_t TortugaStake::amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TortugaStake.amount)
  return _internal_amount();
}
inline void TortugaStake::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TortugaStake::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TortugaStake.amount)
}

// -------------------------------------------------------------------

// TortugaUnstake

// uint64 amount = 1;
inline void TortugaUnstake::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TortugaUnstake::_internal_amount() const {
  return amount_;
}
inline uint64_t TortugaUnstake::amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TortugaUnstake.amount)
  return _internal_amount();
}
inline void TortugaUnstake::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TortugaUnstake::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TortugaUnstake.amount)
}

// -------------------------------------------------------------------

// LiquidStaking

// string smart_contract_address = 1;
inline void LiquidStaking::clear_smart_contract_address() {
  smart_contract_address_.ClearToEmpty();
}
inline const std::string& LiquidStaking::smart_contract_address() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.LiquidStaking.smart_contract_address)
  return _internal_smart_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiquidStaking::set_smart_contract_address(ArgT0&& arg0, ArgT... args) {
 
 smart_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.LiquidStaking.smart_contract_address)
}
inline std::string* LiquidStaking::mutable_smart_contract_address() {
  std::string* _s = _internal_mutable_smart_contract_address();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.LiquidStaking.smart_contract_address)
  return _s;
}
inline const std::string& LiquidStaking::_internal_smart_contract_address() const {
  return smart_contract_address_.Get();
}
inline void LiquidStaking::_internal_set_smart_contract_address(const std::string& value) {
  
  smart_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LiquidStaking::_internal_mutable_smart_contract_address() {
  
  return smart_contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LiquidStaking::release_smart_contract_address() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.LiquidStaking.smart_contract_address)
  return smart_contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LiquidStaking::set_allocated_smart_contract_address(std::string* smart_contract_address) {
  if (smart_contract_address != nullptr) {
    
  } else {
    
  }
  smart_contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smart_contract_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smart_contract_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smart_contract_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.LiquidStaking.smart_contract_address)
}

// .TW.Aptos.Proto.TortugaStake stake = 2;
inline bool LiquidStaking::_internal_has_stake() const {
  return liquid_stake_transaction_payload_case() == kStake;
}
inline bool LiquidStaking::has_stake() const {
  return _internal_has_stake();
}
inline void LiquidStaking::set_has_stake() {
  _oneof_case_[0] = kStake;
}
inline void LiquidStaking::clear_stake() {
  if (_internal_has_stake()) {
    if (GetArenaForAllocation() == nullptr) {
      delete liquid_stake_transaction_payload_.stake_;
    }
    clear_has_liquid_stake_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::TortugaStake* LiquidStaking::release_stake() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.LiquidStaking.stake)
  if (_internal_has_stake()) {
    clear_has_liquid_stake_transaction_payload();
      ::TW::Aptos::Proto::TortugaStake* temp = liquid_stake_transaction_payload_.stake_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    liquid_stake_transaction_payload_.stake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::TortugaStake& LiquidStaking::_internal_stake() const {
  return _internal_has_stake()
      ? *liquid_stake_transaction_payload_.stake_
      : reinterpret_cast< ::TW::Aptos::Proto::TortugaStake&>(::TW::Aptos::Proto::_TortugaStake_default_instance_);
}
inline const ::TW::Aptos::Proto::TortugaStake& LiquidStaking::stake() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.LiquidStaking.stake)
  return _internal_stake();
}
inline ::TW::Aptos::Proto::TortugaStake* LiquidStaking::unsafe_arena_release_stake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.LiquidStaking.stake)
  if (_internal_has_stake()) {
    clear_has_liquid_stake_transaction_payload();
    ::TW::Aptos::Proto::TortugaStake* temp = liquid_stake_transaction_payload_.stake_;
    liquid_stake_transaction_payload_.stake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiquidStaking::unsafe_arena_set_allocated_stake(::TW::Aptos::Proto::TortugaStake* stake) {
  clear_liquid_stake_transaction_payload();
  if (stake) {
    set_has_stake();
    liquid_stake_transaction_payload_.stake_ = stake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.LiquidStaking.stake)
}
inline ::TW::Aptos::Proto::TortugaStake* LiquidStaking::_internal_mutable_stake() {
  if (!_internal_has_stake()) {
    clear_liquid_stake_transaction_payload();
    set_has_stake();
    liquid_stake_transaction_payload_.stake_ = CreateMaybeMessage< ::TW::Aptos::Proto::TortugaStake >(GetArenaForAllocation());
  }
  return liquid_stake_transaction_payload_.stake_;
}
inline ::TW::Aptos::Proto::TortugaStake* LiquidStaking::mutable_stake() {
  ::TW::Aptos::Proto::TortugaStake* _msg = _internal_mutable_stake();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.LiquidStaking.stake)
  return _msg;
}

// .TW.Aptos.Proto.TortugaUnstake unstake = 3;
inline bool LiquidStaking::_internal_has_unstake() const {
  return liquid_stake_transaction_payload_case() == kUnstake;
}
inline bool LiquidStaking::has_unstake() const {
  return _internal_has_unstake();
}
inline void LiquidStaking::set_has_unstake() {
  _oneof_case_[0] = kUnstake;
}
inline void LiquidStaking::clear_unstake() {
  if (_internal_has_unstake()) {
    if (GetArenaForAllocation() == nullptr) {
      delete liquid_stake_transaction_payload_.unstake_;
    }
    clear_has_liquid_stake_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::TortugaUnstake* LiquidStaking::release_unstake() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.LiquidStaking.unstake)
  if (_internal_has_unstake()) {
    clear_has_liquid_stake_transaction_payload();
      ::TW::Aptos::Proto::TortugaUnstake* temp = liquid_stake_transaction_payload_.unstake_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    liquid_stake_transaction_payload_.unstake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::TortugaUnstake& LiquidStaking::_internal_unstake() const {
  return _internal_has_unstake()
      ? *liquid_stake_transaction_payload_.unstake_
      : reinterpret_cast< ::TW::Aptos::Proto::TortugaUnstake&>(::TW::Aptos::Proto::_TortugaUnstake_default_instance_);
}
inline const ::TW::Aptos::Proto::TortugaUnstake& LiquidStaking::unstake() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.LiquidStaking.unstake)
  return _internal_unstake();
}
inline ::TW::Aptos::Proto::TortugaUnstake* LiquidStaking::unsafe_arena_release_unstake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.LiquidStaking.unstake)
  if (_internal_has_unstake()) {
    clear_has_liquid_stake_transaction_payload();
    ::TW::Aptos::Proto::TortugaUnstake* temp = liquid_stake_transaction_payload_.unstake_;
    liquid_stake_transaction_payload_.unstake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiquidStaking::unsafe_arena_set_allocated_unstake(::TW::Aptos::Proto::TortugaUnstake* unstake) {
  clear_liquid_stake_transaction_payload();
  if (unstake) {
    set_has_unstake();
    liquid_stake_transaction_payload_.unstake_ = unstake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.LiquidStaking.unstake)
}
inline ::TW::Aptos::Proto::TortugaUnstake* LiquidStaking::_internal_mutable_unstake() {
  if (!_internal_has_unstake()) {
    clear_liquid_stake_transaction_payload();
    set_has_unstake();
    liquid_stake_transaction_payload_.unstake_ = CreateMaybeMessage< ::TW::Aptos::Proto::TortugaUnstake >(GetArenaForAllocation());
  }
  return liquid_stake_transaction_payload_.unstake_;
}
inline ::TW::Aptos::Proto::TortugaUnstake* LiquidStaking::mutable_unstake() {
  ::TW::Aptos::Proto::TortugaUnstake* _msg = _internal_mutable_unstake();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.LiquidStaking.unstake)
  return _msg;
}

// .TW.Aptos.Proto.TortugaClaim claim = 4;
inline bool LiquidStaking::_internal_has_claim() const {
  return liquid_stake_transaction_payload_case() == kClaim;
}
inline bool LiquidStaking::has_claim() const {
  return _internal_has_claim();
}
inline void LiquidStaking::set_has_claim() {
  _oneof_case_[0] = kClaim;
}
inline void LiquidStaking::clear_claim() {
  if (_internal_has_claim()) {
    if (GetArenaForAllocation() == nullptr) {
      delete liquid_stake_transaction_payload_.claim_;
    }
    clear_has_liquid_stake_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::TortugaClaim* LiquidStaking::release_claim() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.LiquidStaking.claim)
  if (_internal_has_claim()) {
    clear_has_liquid_stake_transaction_payload();
      ::TW::Aptos::Proto::TortugaClaim* temp = liquid_stake_transaction_payload_.claim_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    liquid_stake_transaction_payload_.claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::TortugaClaim& LiquidStaking::_internal_claim() const {
  return _internal_has_claim()
      ? *liquid_stake_transaction_payload_.claim_
      : reinterpret_cast< ::TW::Aptos::Proto::TortugaClaim&>(::TW::Aptos::Proto::_TortugaClaim_default_instance_);
}
inline const ::TW::Aptos::Proto::TortugaClaim& LiquidStaking::claim() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.LiquidStaking.claim)
  return _internal_claim();
}
inline ::TW::Aptos::Proto::TortugaClaim* LiquidStaking::unsafe_arena_release_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.LiquidStaking.claim)
  if (_internal_has_claim()) {
    clear_has_liquid_stake_transaction_payload();
    ::TW::Aptos::Proto::TortugaClaim* temp = liquid_stake_transaction_payload_.claim_;
    liquid_stake_transaction_payload_.claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LiquidStaking::unsafe_arena_set_allocated_claim(::TW::Aptos::Proto::TortugaClaim* claim) {
  clear_liquid_stake_transaction_payload();
  if (claim) {
    set_has_claim();
    liquid_stake_transaction_payload_.claim_ = claim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.LiquidStaking.claim)
}
inline ::TW::Aptos::Proto::TortugaClaim* LiquidStaking::_internal_mutable_claim() {
  if (!_internal_has_claim()) {
    clear_liquid_stake_transaction_payload();
    set_has_claim();
    liquid_stake_transaction_payload_.claim_ = CreateMaybeMessage< ::TW::Aptos::Proto::TortugaClaim >(GetArenaForAllocation());
  }
  return liquid_stake_transaction_payload_.claim_;
}
inline ::TW::Aptos::Proto::TortugaClaim* LiquidStaking::mutable_claim() {
  ::TW::Aptos::Proto::TortugaClaim* _msg = _internal_mutable_claim();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.LiquidStaking.claim)
  return _msg;
}

inline bool LiquidStaking::has_liquid_stake_transaction_payload() const {
  return liquid_stake_transaction_payload_case() != LIQUID_STAKE_TRANSACTION_PAYLOAD_NOT_SET;
}
inline void LiquidStaking::clear_has_liquid_stake_transaction_payload() {
  _oneof_case_[0] = LIQUID_STAKE_TRANSACTION_PAYLOAD_NOT_SET;
}
inline LiquidStaking::LiquidStakeTransactionPayloadCase LiquidStaking::liquid_stake_transaction_payload_case() const {
  return LiquidStaking::LiquidStakeTransactionPayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NftMessage

// .TW.Aptos.Proto.OfferNftMessage offer_nft = 1;
inline bool NftMessage::_internal_has_offer_nft() const {
  return nft_transaction_payload_case() == kOfferNft;
}
inline bool NftMessage::has_offer_nft() const {
  return _internal_has_offer_nft();
}
inline void NftMessage::set_has_offer_nft() {
  _oneof_case_[0] = kOfferNft;
}
inline void NftMessage::clear_offer_nft() {
  if (_internal_has_offer_nft()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nft_transaction_payload_.offer_nft_;
    }
    clear_has_nft_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::OfferNftMessage* NftMessage::release_offer_nft() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.NftMessage.offer_nft)
  if (_internal_has_offer_nft()) {
    clear_has_nft_transaction_payload();
      ::TW::Aptos::Proto::OfferNftMessage* temp = nft_transaction_payload_.offer_nft_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nft_transaction_payload_.offer_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::OfferNftMessage& NftMessage::_internal_offer_nft() const {
  return _internal_has_offer_nft()
      ? *nft_transaction_payload_.offer_nft_
      : reinterpret_cast< ::TW::Aptos::Proto::OfferNftMessage&>(::TW::Aptos::Proto::_OfferNftMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::OfferNftMessage& NftMessage::offer_nft() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.NftMessage.offer_nft)
  return _internal_offer_nft();
}
inline ::TW::Aptos::Proto::OfferNftMessage* NftMessage::unsafe_arena_release_offer_nft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.NftMessage.offer_nft)
  if (_internal_has_offer_nft()) {
    clear_has_nft_transaction_payload();
    ::TW::Aptos::Proto::OfferNftMessage* temp = nft_transaction_payload_.offer_nft_;
    nft_transaction_payload_.offer_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NftMessage::unsafe_arena_set_allocated_offer_nft(::TW::Aptos::Proto::OfferNftMessage* offer_nft) {
  clear_nft_transaction_payload();
  if (offer_nft) {
    set_has_offer_nft();
    nft_transaction_payload_.offer_nft_ = offer_nft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.NftMessage.offer_nft)
}
inline ::TW::Aptos::Proto::OfferNftMessage* NftMessage::_internal_mutable_offer_nft() {
  if (!_internal_has_offer_nft()) {
    clear_nft_transaction_payload();
    set_has_offer_nft();
    nft_transaction_payload_.offer_nft_ = CreateMaybeMessage< ::TW::Aptos::Proto::OfferNftMessage >(GetArenaForAllocation());
  }
  return nft_transaction_payload_.offer_nft_;
}
inline ::TW::Aptos::Proto::OfferNftMessage* NftMessage::mutable_offer_nft() {
  ::TW::Aptos::Proto::OfferNftMessage* _msg = _internal_mutable_offer_nft();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.NftMessage.offer_nft)
  return _msg;
}

// .TW.Aptos.Proto.CancelOfferNftMessage cancel_offer_nft = 2;
inline bool NftMessage::_internal_has_cancel_offer_nft() const {
  return nft_transaction_payload_case() == kCancelOfferNft;
}
inline bool NftMessage::has_cancel_offer_nft() const {
  return _internal_has_cancel_offer_nft();
}
inline void NftMessage::set_has_cancel_offer_nft() {
  _oneof_case_[0] = kCancelOfferNft;
}
inline void NftMessage::clear_cancel_offer_nft() {
  if (_internal_has_cancel_offer_nft()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nft_transaction_payload_.cancel_offer_nft_;
    }
    clear_has_nft_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::CancelOfferNftMessage* NftMessage::release_cancel_offer_nft() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.NftMessage.cancel_offer_nft)
  if (_internal_has_cancel_offer_nft()) {
    clear_has_nft_transaction_payload();
      ::TW::Aptos::Proto::CancelOfferNftMessage* temp = nft_transaction_payload_.cancel_offer_nft_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nft_transaction_payload_.cancel_offer_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::CancelOfferNftMessage& NftMessage::_internal_cancel_offer_nft() const {
  return _internal_has_cancel_offer_nft()
      ? *nft_transaction_payload_.cancel_offer_nft_
      : reinterpret_cast< ::TW::Aptos::Proto::CancelOfferNftMessage&>(::TW::Aptos::Proto::_CancelOfferNftMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::CancelOfferNftMessage& NftMessage::cancel_offer_nft() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.NftMessage.cancel_offer_nft)
  return _internal_cancel_offer_nft();
}
inline ::TW::Aptos::Proto::CancelOfferNftMessage* NftMessage::unsafe_arena_release_cancel_offer_nft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.NftMessage.cancel_offer_nft)
  if (_internal_has_cancel_offer_nft()) {
    clear_has_nft_transaction_payload();
    ::TW::Aptos::Proto::CancelOfferNftMessage* temp = nft_transaction_payload_.cancel_offer_nft_;
    nft_transaction_payload_.cancel_offer_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NftMessage::unsafe_arena_set_allocated_cancel_offer_nft(::TW::Aptos::Proto::CancelOfferNftMessage* cancel_offer_nft) {
  clear_nft_transaction_payload();
  if (cancel_offer_nft) {
    set_has_cancel_offer_nft();
    nft_transaction_payload_.cancel_offer_nft_ = cancel_offer_nft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.NftMessage.cancel_offer_nft)
}
inline ::TW::Aptos::Proto::CancelOfferNftMessage* NftMessage::_internal_mutable_cancel_offer_nft() {
  if (!_internal_has_cancel_offer_nft()) {
    clear_nft_transaction_payload();
    set_has_cancel_offer_nft();
    nft_transaction_payload_.cancel_offer_nft_ = CreateMaybeMessage< ::TW::Aptos::Proto::CancelOfferNftMessage >(GetArenaForAllocation());
  }
  return nft_transaction_payload_.cancel_offer_nft_;
}
inline ::TW::Aptos::Proto::CancelOfferNftMessage* NftMessage::mutable_cancel_offer_nft() {
  ::TW::Aptos::Proto::CancelOfferNftMessage* _msg = _internal_mutable_cancel_offer_nft();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.NftMessage.cancel_offer_nft)
  return _msg;
}

// .TW.Aptos.Proto.ClaimNftMessage claim_nft = 3;
inline bool NftMessage::_internal_has_claim_nft() const {
  return nft_transaction_payload_case() == kClaimNft;
}
inline bool NftMessage::has_claim_nft() const {
  return _internal_has_claim_nft();
}
inline void NftMessage::set_has_claim_nft() {
  _oneof_case_[0] = kClaimNft;
}
inline void NftMessage::clear_claim_nft() {
  if (_internal_has_claim_nft()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nft_transaction_payload_.claim_nft_;
    }
    clear_has_nft_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::ClaimNftMessage* NftMessage::release_claim_nft() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.NftMessage.claim_nft)
  if (_internal_has_claim_nft()) {
    clear_has_nft_transaction_payload();
      ::TW::Aptos::Proto::ClaimNftMessage* temp = nft_transaction_payload_.claim_nft_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nft_transaction_payload_.claim_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::ClaimNftMessage& NftMessage::_internal_claim_nft() const {
  return _internal_has_claim_nft()
      ? *nft_transaction_payload_.claim_nft_
      : reinterpret_cast< ::TW::Aptos::Proto::ClaimNftMessage&>(::TW::Aptos::Proto::_ClaimNftMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::ClaimNftMessage& NftMessage::claim_nft() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.NftMessage.claim_nft)
  return _internal_claim_nft();
}
inline ::TW::Aptos::Proto::ClaimNftMessage* NftMessage::unsafe_arena_release_claim_nft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.NftMessage.claim_nft)
  if (_internal_has_claim_nft()) {
    clear_has_nft_transaction_payload();
    ::TW::Aptos::Proto::ClaimNftMessage* temp = nft_transaction_payload_.claim_nft_;
    nft_transaction_payload_.claim_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NftMessage::unsafe_arena_set_allocated_claim_nft(::TW::Aptos::Proto::ClaimNftMessage* claim_nft) {
  clear_nft_transaction_payload();
  if (claim_nft) {
    set_has_claim_nft();
    nft_transaction_payload_.claim_nft_ = claim_nft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.NftMessage.claim_nft)
}
inline ::TW::Aptos::Proto::ClaimNftMessage* NftMessage::_internal_mutable_claim_nft() {
  if (!_internal_has_claim_nft()) {
    clear_nft_transaction_payload();
    set_has_claim_nft();
    nft_transaction_payload_.claim_nft_ = CreateMaybeMessage< ::TW::Aptos::Proto::ClaimNftMessage >(GetArenaForAllocation());
  }
  return nft_transaction_payload_.claim_nft_;
}
inline ::TW::Aptos::Proto::ClaimNftMessage* NftMessage::mutable_claim_nft() {
  ::TW::Aptos::Proto::ClaimNftMessage* _msg = _internal_mutable_claim_nft();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.NftMessage.claim_nft)
  return _msg;
}

inline bool NftMessage::has_nft_transaction_payload() const {
  return nft_transaction_payload_case() != NFT_TRANSACTION_PAYLOAD_NOT_SET;
}
inline void NftMessage::clear_has_nft_transaction_payload() {
  _oneof_case_[0] = NFT_TRANSACTION_PAYLOAD_NOT_SET;
}
inline NftMessage::NftTransactionPayloadCase NftMessage::nft_transaction_payload_case() const {
  return NftMessage::NftTransactionPayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SigningInput

// string sender = 1;
inline void SigningInput::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& SigningInput::sender() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.sender)
}
inline std::string* SigningInput::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.sender)
  return _s;
}
inline const std::string& SigningInput::_internal_sender() const {
  return sender_.Get();
}
inline void SigningInput::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_sender() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningInput.sender)
}

// int64 sequence_number = 2;
inline void SigningInput::clear_sequence_number() {
  sequence_number_ = int64_t{0};
}
inline int64_t SigningInput::_internal_sequence_number() const {
  return sequence_number_;
}
inline int64_t SigningInput::sequence_number() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.sequence_number)
  return _internal_sequence_number();
}
inline void SigningInput::_internal_set_sequence_number(int64_t value) {
  
  sequence_number_ = value;
}
inline void SigningInput::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.sequence_number)
}

// uint64 max_gas_amount = 3;
inline void SigningInput::clear_max_gas_amount() {
  max_gas_amount_ = uint64_t{0u};
}
inline uint64_t SigningInput::_internal_max_gas_amount() const {
  return max_gas_amount_;
}
inline uint64_t SigningInput::max_gas_amount() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.max_gas_amount)
  return _internal_max_gas_amount();
}
inline void SigningInput::_internal_set_max_gas_amount(uint64_t value) {
  
  max_gas_amount_ = value;
}
inline void SigningInput::set_max_gas_amount(uint64_t value) {
  _internal_set_max_gas_amount(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.max_gas_amount)
}

// uint64 gas_unit_price = 4;
inline void SigningInput::clear_gas_unit_price() {
  gas_unit_price_ = uint64_t{0u};
}
inline uint64_t SigningInput::_internal_gas_unit_price() const {
  return gas_unit_price_;
}
inline uint64_t SigningInput::gas_unit_price() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.gas_unit_price)
  return _internal_gas_unit_price();
}
inline void SigningInput::_internal_set_gas_unit_price(uint64_t value) {
  
  gas_unit_price_ = value;
}
inline void SigningInput::set_gas_unit_price(uint64_t value) {
  _internal_set_gas_unit_price(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.gas_unit_price)
}

// uint64 expiration_timestamp_secs = 5;
inline void SigningInput::clear_expiration_timestamp_secs() {
  expiration_timestamp_secs_ = uint64_t{0u};
}
inline uint64_t SigningInput::_internal_expiration_timestamp_secs() const {
  return expiration_timestamp_secs_;
}
inline uint64_t SigningInput::expiration_timestamp_secs() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.expiration_timestamp_secs)
  return _internal_expiration_timestamp_secs();
}
inline void SigningInput::_internal_set_expiration_timestamp_secs(uint64_t value) {
  
  expiration_timestamp_secs_ = value;
}
inline void SigningInput::set_expiration_timestamp_secs(uint64_t value) {
  _internal_set_expiration_timestamp_secs(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.expiration_timestamp_secs)
}

// uint32 chain_id = 6;
inline void SigningInput::clear_chain_id() {
  chain_id_ = 0u;
}
inline uint32_t SigningInput::_internal_chain_id() const {
  return chain_id_;
}
inline uint32_t SigningInput::chain_id() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.chain_id)
  return _internal_chain_id();
}
inline void SigningInput::_internal_set_chain_id(uint32_t value) {
  
  chain_id_ = value;
}
inline void SigningInput::set_chain_id(uint32_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.chain_id)
}

// bytes private_key = 7;
inline void SigningInput::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& SigningInput::private_key() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 private_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.private_key)
  return _s;
}
inline const std::string& SigningInput::_internal_private_key() const {
  return private_key_.Get();
}
inline void SigningInput::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_private_key() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningInput.private_key)
}

// string any_encoded = 8;
inline void SigningInput::clear_any_encoded() {
  any_encoded_.ClearToEmpty();
}
inline const std::string& SigningInput::any_encoded() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.any_encoded)
  return _internal_any_encoded();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_any_encoded(ArgT0&& arg0, ArgT... args) {
 
 any_encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningInput.any_encoded)
}
inline std::string* SigningInput::mutable_any_encoded() {
  std::string* _s = _internal_mutable_any_encoded();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.any_encoded)
  return _s;
}
inline const std::string& SigningInput::_internal_any_encoded() const {
  return any_encoded_.Get();
}
inline void SigningInput::_internal_set_any_encoded(const std::string& value) {
  
  any_encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_any_encoded() {
  
  return any_encoded_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_any_encoded() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.any_encoded)
  return any_encoded_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_any_encoded(std::string* any_encoded) {
  if (any_encoded != nullptr) {
    
  } else {
    
  }
  any_encoded_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), any_encoded,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (any_encoded_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    any_encoded_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningInput.any_encoded)
}

// .TW.Aptos.Proto.TransferMessage transfer = 9;
inline bool SigningInput::_internal_has_transfer() const {
  return transaction_payload_case() == kTransfer;
}
inline bool SigningInput::has_transfer() const {
  return _internal_has_transfer();
}
inline void SigningInput::set_has_transfer() {
  _oneof_case_[0] = kTransfer;
}
inline void SigningInput::clear_transfer() {
  if (_internal_has_transfer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.transfer_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::TransferMessage* SigningInput::release_transfer() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.transfer)
  if (_internal_has_transfer()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::TransferMessage* temp = transaction_payload_.transfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::TransferMessage& SigningInput::_internal_transfer() const {
  return _internal_has_transfer()
      ? *transaction_payload_.transfer_
      : reinterpret_cast< ::TW::Aptos::Proto::TransferMessage&>(::TW::Aptos::Proto::_TransferMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::TransferMessage& SigningInput::transfer() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.transfer)
  return _internal_transfer();
}
inline ::TW::Aptos::Proto::TransferMessage* SigningInput::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.transfer)
  if (_internal_has_transfer()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::TransferMessage* temp = transaction_payload_.transfer_;
    transaction_payload_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_transfer(::TW::Aptos::Proto::TransferMessage* transfer) {
  clear_transaction_payload();
  if (transfer) {
    set_has_transfer();
    transaction_payload_.transfer_ = transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.transfer)
}
inline ::TW::Aptos::Proto::TransferMessage* SigningInput::_internal_mutable_transfer() {
  if (!_internal_has_transfer()) {
    clear_transaction_payload();
    set_has_transfer();
    transaction_payload_.transfer_ = CreateMaybeMessage< ::TW::Aptos::Proto::TransferMessage >(GetArenaForAllocation());
  }
  return transaction_payload_.transfer_;
}
inline ::TW::Aptos::Proto::TransferMessage* SigningInput::mutable_transfer() {
  ::TW::Aptos::Proto::TransferMessage* _msg = _internal_mutable_transfer();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.transfer)
  return _msg;
}

// .TW.Aptos.Proto.TokenTransferMessage token_transfer = 10;
inline bool SigningInput::_internal_has_token_transfer() const {
  return transaction_payload_case() == kTokenTransfer;
}
inline bool SigningInput::has_token_transfer() const {
  return _internal_has_token_transfer();
}
inline void SigningInput::set_has_token_transfer() {
  _oneof_case_[0] = kTokenTransfer;
}
inline void SigningInput::clear_token_transfer() {
  if (_internal_has_token_transfer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.token_transfer_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::TokenTransferMessage* SigningInput::release_token_transfer() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.token_transfer)
  if (_internal_has_token_transfer()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::TokenTransferMessage* temp = transaction_payload_.token_transfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.token_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::TokenTransferMessage& SigningInput::_internal_token_transfer() const {
  return _internal_has_token_transfer()
      ? *transaction_payload_.token_transfer_
      : reinterpret_cast< ::TW::Aptos::Proto::TokenTransferMessage&>(::TW::Aptos::Proto::_TokenTransferMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::TokenTransferMessage& SigningInput::token_transfer() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.token_transfer)
  return _internal_token_transfer();
}
inline ::TW::Aptos::Proto::TokenTransferMessage* SigningInput::unsafe_arena_release_token_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.token_transfer)
  if (_internal_has_token_transfer()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::TokenTransferMessage* temp = transaction_payload_.token_transfer_;
    transaction_payload_.token_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_token_transfer(::TW::Aptos::Proto::TokenTransferMessage* token_transfer) {
  clear_transaction_payload();
  if (token_transfer) {
    set_has_token_transfer();
    transaction_payload_.token_transfer_ = token_transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.token_transfer)
}
inline ::TW::Aptos::Proto::TokenTransferMessage* SigningInput::_internal_mutable_token_transfer() {
  if (!_internal_has_token_transfer()) {
    clear_transaction_payload();
    set_has_token_transfer();
    transaction_payload_.token_transfer_ = CreateMaybeMessage< ::TW::Aptos::Proto::TokenTransferMessage >(GetArenaForAllocation());
  }
  return transaction_payload_.token_transfer_;
}
inline ::TW::Aptos::Proto::TokenTransferMessage* SigningInput::mutable_token_transfer() {
  ::TW::Aptos::Proto::TokenTransferMessage* _msg = _internal_mutable_token_transfer();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.token_transfer)
  return _msg;
}

// .TW.Aptos.Proto.CreateAccountMessage create_account = 11;
inline bool SigningInput::_internal_has_create_account() const {
  return transaction_payload_case() == kCreateAccount;
}
inline bool SigningInput::has_create_account() const {
  return _internal_has_create_account();
}
inline void SigningInput::set_has_create_account() {
  _oneof_case_[0] = kCreateAccount;
}
inline void SigningInput::clear_create_account() {
  if (_internal_has_create_account()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.create_account_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::CreateAccountMessage* SigningInput::release_create_account() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.create_account)
  if (_internal_has_create_account()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::CreateAccountMessage* temp = transaction_payload_.create_account_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::CreateAccountMessage& SigningInput::_internal_create_account() const {
  return _internal_has_create_account()
      ? *transaction_payload_.create_account_
      : reinterpret_cast< ::TW::Aptos::Proto::CreateAccountMessage&>(::TW::Aptos::Proto::_CreateAccountMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::CreateAccountMessage& SigningInput::create_account() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.create_account)
  return _internal_create_account();
}
inline ::TW::Aptos::Proto::CreateAccountMessage* SigningInput::unsafe_arena_release_create_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.create_account)
  if (_internal_has_create_account()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::CreateAccountMessage* temp = transaction_payload_.create_account_;
    transaction_payload_.create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_create_account(::TW::Aptos::Proto::CreateAccountMessage* create_account) {
  clear_transaction_payload();
  if (create_account) {
    set_has_create_account();
    transaction_payload_.create_account_ = create_account;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.create_account)
}
inline ::TW::Aptos::Proto::CreateAccountMessage* SigningInput::_internal_mutable_create_account() {
  if (!_internal_has_create_account()) {
    clear_transaction_payload();
    set_has_create_account();
    transaction_payload_.create_account_ = CreateMaybeMessage< ::TW::Aptos::Proto::CreateAccountMessage >(GetArenaForAllocation());
  }
  return transaction_payload_.create_account_;
}
inline ::TW::Aptos::Proto::CreateAccountMessage* SigningInput::mutable_create_account() {
  ::TW::Aptos::Proto::CreateAccountMessage* _msg = _internal_mutable_create_account();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.create_account)
  return _msg;
}

// .TW.Aptos.Proto.NftMessage nft_message = 12;
inline bool SigningInput::_internal_has_nft_message() const {
  return transaction_payload_case() == kNftMessage;
}
inline bool SigningInput::has_nft_message() const {
  return _internal_has_nft_message();
}
inline void SigningInput::set_has_nft_message() {
  _oneof_case_[0] = kNftMessage;
}
inline void SigningInput::clear_nft_message() {
  if (_internal_has_nft_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.nft_message_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::NftMessage* SigningInput::release_nft_message() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.nft_message)
  if (_internal_has_nft_message()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::NftMessage* temp = transaction_payload_.nft_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.nft_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::NftMessage& SigningInput::_internal_nft_message() const {
  return _internal_has_nft_message()
      ? *transaction_payload_.nft_message_
      : reinterpret_cast< ::TW::Aptos::Proto::NftMessage&>(::TW::Aptos::Proto::_NftMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::NftMessage& SigningInput::nft_message() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.nft_message)
  return _internal_nft_message();
}
inline ::TW::Aptos::Proto::NftMessage* SigningInput::unsafe_arena_release_nft_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.nft_message)
  if (_internal_has_nft_message()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::NftMessage* temp = transaction_payload_.nft_message_;
    transaction_payload_.nft_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_nft_message(::TW::Aptos::Proto::NftMessage* nft_message) {
  clear_transaction_payload();
  if (nft_message) {
    set_has_nft_message();
    transaction_payload_.nft_message_ = nft_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.nft_message)
}
inline ::TW::Aptos::Proto::NftMessage* SigningInput::_internal_mutable_nft_message() {
  if (!_internal_has_nft_message()) {
    clear_transaction_payload();
    set_has_nft_message();
    transaction_payload_.nft_message_ = CreateMaybeMessage< ::TW::Aptos::Proto::NftMessage >(GetArenaForAllocation());
  }
  return transaction_payload_.nft_message_;
}
inline ::TW::Aptos::Proto::NftMessage* SigningInput::mutable_nft_message() {
  ::TW::Aptos::Proto::NftMessage* _msg = _internal_mutable_nft_message();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.nft_message)
  return _msg;
}

// .TW.Aptos.Proto.ManagedTokensRegisterMessage register_token = 13;
inline bool SigningInput::_internal_has_register_token() const {
  return transaction_payload_case() == kRegisterToken;
}
inline bool SigningInput::has_register_token() const {
  return _internal_has_register_token();
}
inline void SigningInput::set_has_register_token() {
  _oneof_case_[0] = kRegisterToken;
}
inline void SigningInput::clear_register_token() {
  if (_internal_has_register_token()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.register_token_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::ManagedTokensRegisterMessage* SigningInput::release_register_token() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.register_token)
  if (_internal_has_register_token()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::ManagedTokensRegisterMessage* temp = transaction_payload_.register_token_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.register_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::ManagedTokensRegisterMessage& SigningInput::_internal_register_token() const {
  return _internal_has_register_token()
      ? *transaction_payload_.register_token_
      : reinterpret_cast< ::TW::Aptos::Proto::ManagedTokensRegisterMessage&>(::TW::Aptos::Proto::_ManagedTokensRegisterMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::ManagedTokensRegisterMessage& SigningInput::register_token() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.register_token)
  return _internal_register_token();
}
inline ::TW::Aptos::Proto::ManagedTokensRegisterMessage* SigningInput::unsafe_arena_release_register_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.register_token)
  if (_internal_has_register_token()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::ManagedTokensRegisterMessage* temp = transaction_payload_.register_token_;
    transaction_payload_.register_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_register_token(::TW::Aptos::Proto::ManagedTokensRegisterMessage* register_token) {
  clear_transaction_payload();
  if (register_token) {
    set_has_register_token();
    transaction_payload_.register_token_ = register_token;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.register_token)
}
inline ::TW::Aptos::Proto::ManagedTokensRegisterMessage* SigningInput::_internal_mutable_register_token() {
  if (!_internal_has_register_token()) {
    clear_transaction_payload();
    set_has_register_token();
    transaction_payload_.register_token_ = CreateMaybeMessage< ::TW::Aptos::Proto::ManagedTokensRegisterMessage >(GetArenaForAllocation());
  }
  return transaction_payload_.register_token_;
}
inline ::TW::Aptos::Proto::ManagedTokensRegisterMessage* SigningInput::mutable_register_token() {
  ::TW::Aptos::Proto::ManagedTokensRegisterMessage* _msg = _internal_mutable_register_token();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.register_token)
  return _msg;
}

// .TW.Aptos.Proto.LiquidStaking liquid_staking_message = 14;
inline bool SigningInput::_internal_has_liquid_staking_message() const {
  return transaction_payload_case() == kLiquidStakingMessage;
}
inline bool SigningInput::has_liquid_staking_message() const {
  return _internal_has_liquid_staking_message();
}
inline void SigningInput::set_has_liquid_staking_message() {
  _oneof_case_[0] = kLiquidStakingMessage;
}
inline void SigningInput::clear_liquid_staking_message() {
  if (_internal_has_liquid_staking_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.liquid_staking_message_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::LiquidStaking* SigningInput::release_liquid_staking_message() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.liquid_staking_message)
  if (_internal_has_liquid_staking_message()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::LiquidStaking* temp = transaction_payload_.liquid_staking_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.liquid_staking_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::LiquidStaking& SigningInput::_internal_liquid_staking_message() const {
  return _internal_has_liquid_staking_message()
      ? *transaction_payload_.liquid_staking_message_
      : reinterpret_cast< ::TW::Aptos::Proto::LiquidStaking&>(::TW::Aptos::Proto::_LiquidStaking_default_instance_);
}
inline const ::TW::Aptos::Proto::LiquidStaking& SigningInput::liquid_staking_message() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.liquid_staking_message)
  return _internal_liquid_staking_message();
}
inline ::TW::Aptos::Proto::LiquidStaking* SigningInput::unsafe_arena_release_liquid_staking_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.liquid_staking_message)
  if (_internal_has_liquid_staking_message()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::LiquidStaking* temp = transaction_payload_.liquid_staking_message_;
    transaction_payload_.liquid_staking_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_liquid_staking_message(::TW::Aptos::Proto::LiquidStaking* liquid_staking_message) {
  clear_transaction_payload();
  if (liquid_staking_message) {
    set_has_liquid_staking_message();
    transaction_payload_.liquid_staking_message_ = liquid_staking_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.liquid_staking_message)
}
inline ::TW::Aptos::Proto::LiquidStaking* SigningInput::_internal_mutable_liquid_staking_message() {
  if (!_internal_has_liquid_staking_message()) {
    clear_transaction_payload();
    set_has_liquid_staking_message();
    transaction_payload_.liquid_staking_message_ = CreateMaybeMessage< ::TW::Aptos::Proto::LiquidStaking >(GetArenaForAllocation());
  }
  return transaction_payload_.liquid_staking_message_;
}
inline ::TW::Aptos::Proto::LiquidStaking* SigningInput::mutable_liquid_staking_message() {
  ::TW::Aptos::Proto::LiquidStaking* _msg = _internal_mutable_liquid_staking_message();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.liquid_staking_message)
  return _msg;
}

// .TW.Aptos.Proto.TokenTransferCoinsMessage token_transfer_coins = 15;
inline bool SigningInput::_internal_has_token_transfer_coins() const {
  return transaction_payload_case() == kTokenTransferCoins;
}
inline bool SigningInput::has_token_transfer_coins() const {
  return _internal_has_token_transfer_coins();
}
inline void SigningInput::set_has_token_transfer_coins() {
  _oneof_case_[0] = kTokenTransferCoins;
}
inline void SigningInput::clear_token_transfer_coins() {
  if (_internal_has_token_transfer_coins()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transaction_payload_.token_transfer_coins_;
    }
    clear_has_transaction_payload();
  }
}
inline ::TW::Aptos::Proto::TokenTransferCoinsMessage* SigningInput::release_token_transfer_coins() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningInput.token_transfer_coins)
  if (_internal_has_token_transfer_coins()) {
    clear_has_transaction_payload();
      ::TW::Aptos::Proto::TokenTransferCoinsMessage* temp = transaction_payload_.token_transfer_coins_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transaction_payload_.token_transfer_coins_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Aptos::Proto::TokenTransferCoinsMessage& SigningInput::_internal_token_transfer_coins() const {
  return _internal_has_token_transfer_coins()
      ? *transaction_payload_.token_transfer_coins_
      : reinterpret_cast< ::TW::Aptos::Proto::TokenTransferCoinsMessage&>(::TW::Aptos::Proto::_TokenTransferCoinsMessage_default_instance_);
}
inline const ::TW::Aptos::Proto::TokenTransferCoinsMessage& SigningInput::token_transfer_coins() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningInput.token_transfer_coins)
  return _internal_token_transfer_coins();
}
inline ::TW::Aptos::Proto::TokenTransferCoinsMessage* SigningInput::unsafe_arena_release_token_transfer_coins() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Aptos.Proto.SigningInput.token_transfer_coins)
  if (_internal_has_token_transfer_coins()) {
    clear_has_transaction_payload();
    ::TW::Aptos::Proto::TokenTransferCoinsMessage* temp = transaction_payload_.token_transfer_coins_;
    transaction_payload_.token_transfer_coins_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_token_transfer_coins(::TW::Aptos::Proto::TokenTransferCoinsMessage* token_transfer_coins) {
  clear_transaction_payload();
  if (token_transfer_coins) {
    set_has_token_transfer_coins();
    transaction_payload_.token_transfer_coins_ = token_transfer_coins;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningInput.token_transfer_coins)
}
inline ::TW::Aptos::Proto::TokenTransferCoinsMessage* SigningInput::_internal_mutable_token_transfer_coins() {
  if (!_internal_has_token_transfer_coins()) {
    clear_transaction_payload();
    set_has_token_transfer_coins();
    transaction_payload_.token_transfer_coins_ = CreateMaybeMessage< ::TW::Aptos::Proto::TokenTransferCoinsMessage >(GetArenaForAllocation());
  }
  return transaction_payload_.token_transfer_coins_;
}
inline ::TW::Aptos::Proto::TokenTransferCoinsMessage* SigningInput::mutable_token_transfer_coins() {
  ::TW::Aptos::Proto::TokenTransferCoinsMessage* _msg = _internal_mutable_token_transfer_coins();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningInput.token_transfer_coins)
  return _msg;
}

inline bool SigningInput::has_transaction_payload() const {
  return transaction_payload_case() != TRANSACTION_PAYLOAD_NOT_SET;
}
inline void SigningInput::clear_has_transaction_payload() {
  _oneof_case_[0] = TRANSACTION_PAYLOAD_NOT_SET;
}
inline SigningInput::TransactionPayloadCase SigningInput::transaction_payload_case() const {
  return SigningInput::TransactionPayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransactionAuthenticator

// bytes signature = 1;
inline void TransactionAuthenticator::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& TransactionAuthenticator::signature() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TransactionAuthenticator.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionAuthenticator::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TransactionAuthenticator.signature)
}
inline std::string* TransactionAuthenticator::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TransactionAuthenticator.signature)
  return _s;
}
inline const std::string& TransactionAuthenticator::_internal_signature() const {
  return signature_.Get();
}
inline void TransactionAuthenticator::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionAuthenticator::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionAuthenticator::release_signature() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TransactionAuthenticator.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionAuthenticator::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TransactionAuthenticator.signature)
}

// bytes public_key = 2;
inline void TransactionAuthenticator::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& TransactionAuthenticator::public_key() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.TransactionAuthenticator.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionAuthenticator::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.TransactionAuthenticator.public_key)
}
inline std::string* TransactionAuthenticator::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.TransactionAuthenticator.public_key)
  return _s;
}
inline const std::string& TransactionAuthenticator::_internal_public_key() const {
  return public_key_.Get();
}
inline void TransactionAuthenticator::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionAuthenticator::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionAuthenticator::release_public_key() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.TransactionAuthenticator.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionAuthenticator::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.TransactionAuthenticator.public_key)
}

// -------------------------------------------------------------------

// SigningOutput

// bytes raw_txn = 1;
inline void SigningOutput::clear_raw_txn() {
  raw_txn_.ClearToEmpty();
}
inline const std::string& SigningOutput::raw_txn() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningOutput.raw_txn)
  return _internal_raw_txn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_raw_txn(ArgT0&& arg0, ArgT... args) {
 
 raw_txn_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningOutput.raw_txn)
}
inline std::string* SigningOutput::mutable_raw_txn() {
  std::string* _s = _internal_mutable_raw_txn();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningOutput.raw_txn)
  return _s;
}
inline const std::string& SigningOutput::_internal_raw_txn() const {
  return raw_txn_.Get();
}
inline void SigningOutput::_internal_set_raw_txn(const std::string& value) {
  
  raw_txn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_raw_txn() {
  
  return raw_txn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_raw_txn() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningOutput.raw_txn)
  return raw_txn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_raw_txn(std::string* raw_txn) {
  if (raw_txn != nullptr) {
    
  } else {
    
  }
  raw_txn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_txn,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (raw_txn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    raw_txn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningOutput.raw_txn)
}

// .TW.Aptos.Proto.TransactionAuthenticator authenticator = 2;
inline bool SigningOutput::_internal_has_authenticator() const {
  return this != internal_default_instance() && authenticator_ != nullptr;
}
inline bool SigningOutput::has_authenticator() const {
  return _internal_has_authenticator();
}
inline void SigningOutput::clear_authenticator() {
  if (GetArenaForAllocation() == nullptr && authenticator_ != nullptr) {
    delete authenticator_;
  }
  authenticator_ = nullptr;
}
inline const ::TW::Aptos::Proto::TransactionAuthenticator& SigningOutput::_internal_authenticator() const {
  const ::TW::Aptos::Proto::TransactionAuthenticator* p = authenticator_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Aptos::Proto::TransactionAuthenticator&>(
      ::TW::Aptos::Proto::_TransactionAuthenticator_default_instance_);
}
inline const ::TW::Aptos::Proto::TransactionAuthenticator& SigningOutput::authenticator() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningOutput.authenticator)
  return _internal_authenticator();
}
inline void SigningOutput::unsafe_arena_set_allocated_authenticator(
    ::TW::Aptos::Proto::TransactionAuthenticator* authenticator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authenticator_);
  }
  authenticator_ = authenticator;
  if (authenticator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Aptos.Proto.SigningOutput.authenticator)
}
inline ::TW::Aptos::Proto::TransactionAuthenticator* SigningOutput::release_authenticator() {
  
  ::TW::Aptos::Proto::TransactionAuthenticator* temp = authenticator_;
  authenticator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Aptos::Proto::TransactionAuthenticator* SigningOutput::unsafe_arena_release_authenticator() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningOutput.authenticator)
  
  ::TW::Aptos::Proto::TransactionAuthenticator* temp = authenticator_;
  authenticator_ = nullptr;
  return temp;
}
inline ::TW::Aptos::Proto::TransactionAuthenticator* SigningOutput::_internal_mutable_authenticator() {
  
  if (authenticator_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Aptos::Proto::TransactionAuthenticator>(GetArenaForAllocation());
    authenticator_ = p;
  }
  return authenticator_;
}
inline ::TW::Aptos::Proto::TransactionAuthenticator* SigningOutput::mutable_authenticator() {
  ::TW::Aptos::Proto::TransactionAuthenticator* _msg = _internal_mutable_authenticator();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningOutput.authenticator)
  return _msg;
}
inline void SigningOutput::set_allocated_authenticator(::TW::Aptos::Proto::TransactionAuthenticator* authenticator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authenticator_;
  }
  if (authenticator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Aptos::Proto::TransactionAuthenticator>::GetOwningArena(authenticator);
    if (message_arena != submessage_arena) {
      authenticator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authenticator, submessage_arena);
    }
    
  } else {
    
  }
  authenticator_ = authenticator;
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningOutput.authenticator)
}

// bytes encoded = 3;
inline void SigningOutput::clear_encoded() {
  encoded_.ClearToEmpty();
}
inline const std::string& SigningOutput::encoded() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningOutput.encoded)
  return _internal_encoded();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_encoded(ArgT0&& arg0, ArgT... args) {
 
 encoded_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningOutput.encoded)
}
inline std::string* SigningOutput::mutable_encoded() {
  std::string* _s = _internal_mutable_encoded();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningOutput.encoded)
  return _s;
}
inline const std::string& SigningOutput::_internal_encoded() const {
  return encoded_.Get();
}
inline void SigningOutput::_internal_set_encoded(const std::string& value) {
  
  encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_encoded() {
  
  return encoded_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_encoded() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningOutput.encoded)
  return encoded_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_encoded(std::string* encoded) {
  if (encoded != nullptr) {
    
  } else {
    
  }
  encoded_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoded_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningOutput.encoded)
}

// string json = 4;
inline void SigningOutput::clear_json() {
  json_.ClearToEmpty();
}
inline const std::string& SigningOutput::json() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningOutput.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_json(ArgT0&& arg0, ArgT... args) {
 
 json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningOutput.json)
}
inline std::string* SigningOutput::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningOutput.json)
  return _s;
}
inline const std::string& SigningOutput::_internal_json() const {
  return json_.Get();
}
inline void SigningOutput::_internal_set_json(const std::string& value) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_json() {
  
  return json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_json() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningOutput.json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (json_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningOutput.json)
}

// .TW.Common.Proto.SigningError error = 5;
inline void SigningOutput::clear_error() {
  error_ = 0;
}
inline ::TW::Common::Proto::SigningError SigningOutput::_internal_error() const {
  return static_cast< ::TW::Common::Proto::SigningError >(error_);
}
inline ::TW::Common::Proto::SigningError SigningOutput::error() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningOutput.error)
  return _internal_error();
}
inline void SigningOutput::_internal_set_error(::TW::Common::Proto::SigningError value) {
  
  error_ = value;
}
inline void SigningOutput::set_error(::TW::Common::Proto::SigningError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningOutput.error)
}

// string error_message = 6;
inline void SigningOutput::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& SigningOutput::error_message() const {
  // @@protoc_insertion_point(field_get:TW.Aptos.Proto.SigningOutput.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Aptos.Proto.SigningOutput.error_message)
}
inline std::string* SigningOutput::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:TW.Aptos.Proto.SigningOutput.error_message)
  return _s;
}
inline const std::string& SigningOutput::_internal_error_message() const {
  return error_message_.Get();
}
inline void SigningOutput::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_error_message() {
  // @@protoc_insertion_point(field_release:TW.Aptos.Proto.SigningOutput.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Aptos.Proto.SigningOutput.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Aptos
}  // namespace TW

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Aptos_2eproto
