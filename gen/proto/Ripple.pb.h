// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Ripple.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Ripple_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Ripple_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Ripple_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Ripple_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Ripple_2eproto;
namespace TW {
namespace Ripple {
namespace Proto {
class CurrencyAmount;
struct CurrencyAmountDefaultTypeInternal;
extern CurrencyAmountDefaultTypeInternal _CurrencyAmount_default_instance_;
class OperationNFTokenAcceptOffer;
struct OperationNFTokenAcceptOfferDefaultTypeInternal;
extern OperationNFTokenAcceptOfferDefaultTypeInternal _OperationNFTokenAcceptOffer_default_instance_;
class OperationNFTokenBurn;
struct OperationNFTokenBurnDefaultTypeInternal;
extern OperationNFTokenBurnDefaultTypeInternal _OperationNFTokenBurn_default_instance_;
class OperationNFTokenCancelOffer;
struct OperationNFTokenCancelOfferDefaultTypeInternal;
extern OperationNFTokenCancelOfferDefaultTypeInternal _OperationNFTokenCancelOffer_default_instance_;
class OperationNFTokenCreateOffer;
struct OperationNFTokenCreateOfferDefaultTypeInternal;
extern OperationNFTokenCreateOfferDefaultTypeInternal _OperationNFTokenCreateOffer_default_instance_;
class OperationPayment;
struct OperationPaymentDefaultTypeInternal;
extern OperationPaymentDefaultTypeInternal _OperationPayment_default_instance_;
class OperationTrustSet;
struct OperationTrustSetDefaultTypeInternal;
extern OperationTrustSetDefaultTypeInternal _OperationTrustSet_default_instance_;
class SigningInput;
struct SigningInputDefaultTypeInternal;
extern SigningInputDefaultTypeInternal _SigningInput_default_instance_;
class SigningOutput;
struct SigningOutputDefaultTypeInternal;
extern SigningOutputDefaultTypeInternal _SigningOutput_default_instance_;
}  // namespace Proto
}  // namespace Ripple
}  // namespace TW
PROTOBUF_NAMESPACE_OPEN
template<> ::TW::Ripple::Proto::CurrencyAmount* Arena::CreateMaybeMessage<::TW::Ripple::Proto::CurrencyAmount>(Arena*);
template<> ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* Arena::CreateMaybeMessage<::TW::Ripple::Proto::OperationNFTokenAcceptOffer>(Arena*);
template<> ::TW::Ripple::Proto::OperationNFTokenBurn* Arena::CreateMaybeMessage<::TW::Ripple::Proto::OperationNFTokenBurn>(Arena*);
template<> ::TW::Ripple::Proto::OperationNFTokenCancelOffer* Arena::CreateMaybeMessage<::TW::Ripple::Proto::OperationNFTokenCancelOffer>(Arena*);
template<> ::TW::Ripple::Proto::OperationNFTokenCreateOffer* Arena::CreateMaybeMessage<::TW::Ripple::Proto::OperationNFTokenCreateOffer>(Arena*);
template<> ::TW::Ripple::Proto::OperationPayment* Arena::CreateMaybeMessage<::TW::Ripple::Proto::OperationPayment>(Arena*);
template<> ::TW::Ripple::Proto::OperationTrustSet* Arena::CreateMaybeMessage<::TW::Ripple::Proto::OperationTrustSet>(Arena*);
template<> ::TW::Ripple::Proto::SigningInput* Arena::CreateMaybeMessage<::TW::Ripple::Proto::SigningInput>(Arena*);
template<> ::TW::Ripple::Proto::SigningOutput* Arena::CreateMaybeMessage<::TW::Ripple::Proto::SigningOutput>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TW {
namespace Ripple {
namespace Proto {

// ===================================================================

class CurrencyAmount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.CurrencyAmount) */ {
 public:
  inline CurrencyAmount() : CurrencyAmount(nullptr) {}
  ~CurrencyAmount() override;
  explicit constexpr CurrencyAmount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyAmount(const CurrencyAmount& from);
  CurrencyAmount(CurrencyAmount&& from) noexcept
    : CurrencyAmount() {
    *this = ::std::move(from);
  }

  inline CurrencyAmount& operator=(const CurrencyAmount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyAmount& operator=(CurrencyAmount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyAmount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyAmount* internal_default_instance() {
    return reinterpret_cast<const CurrencyAmount*>(
               &_CurrencyAmount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CurrencyAmount& a, CurrencyAmount& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyAmount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyAmount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyAmount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyAmount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyAmount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrencyAmount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyAmount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.CurrencyAmount";
  }
  protected:
  explicit CurrencyAmount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyFieldNumber = 1,
    kValueFieldNumber = 2,
    kIssuerFieldNumber = 3,
  };
  // string currency = 1;
  void clear_currency();
  const std::string& currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency();
  PROTOBUF_NODISCARD std::string* release_currency();
  void set_allocated_currency(std::string* currency);
  private:
  const std::string& _internal_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const std::string& value);
  std::string* _internal_mutable_currency();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string issuer = 3;
  void clear_issuer();
  const std::string& issuer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* issuer);
  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(const std::string& value);
  std::string* _internal_mutable_issuer();
  public:

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.CurrencyAmount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class OperationTrustSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.OperationTrustSet) */ {
 public:
  inline OperationTrustSet() : OperationTrustSet(nullptr) {}
  ~OperationTrustSet() override;
  explicit constexpr OperationTrustSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationTrustSet(const OperationTrustSet& from);
  OperationTrustSet(OperationTrustSet&& from) noexcept
    : OperationTrustSet() {
    *this = ::std::move(from);
  }

  inline OperationTrustSet& operator=(const OperationTrustSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationTrustSet& operator=(OperationTrustSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationTrustSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationTrustSet* internal_default_instance() {
    return reinterpret_cast<const OperationTrustSet*>(
               &_OperationTrustSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OperationTrustSet& a, OperationTrustSet& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationTrustSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationTrustSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationTrustSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationTrustSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationTrustSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationTrustSet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationTrustSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.OperationTrustSet";
  }
  protected:
  explicit OperationTrustSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitAmountFieldNumber = 1,
  };
  // .TW.Ripple.Proto.CurrencyAmount limit_amount = 1;
  bool has_limit_amount() const;
  private:
  bool _internal_has_limit_amount() const;
  public:
  void clear_limit_amount();
  const ::TW::Ripple::Proto::CurrencyAmount& limit_amount() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::CurrencyAmount* release_limit_amount();
  ::TW::Ripple::Proto::CurrencyAmount* mutable_limit_amount();
  void set_allocated_limit_amount(::TW::Ripple::Proto::CurrencyAmount* limit_amount);
  private:
  const ::TW::Ripple::Proto::CurrencyAmount& _internal_limit_amount() const;
  ::TW::Ripple::Proto::CurrencyAmount* _internal_mutable_limit_amount();
  public:
  void unsafe_arena_set_allocated_limit_amount(
      ::TW::Ripple::Proto::CurrencyAmount* limit_amount);
  ::TW::Ripple::Proto::CurrencyAmount* unsafe_arena_release_limit_amount();

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.OperationTrustSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TW::Ripple::Proto::CurrencyAmount* limit_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class OperationPayment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.OperationPayment) */ {
 public:
  inline OperationPayment() : OperationPayment(nullptr) {}
  ~OperationPayment() override;
  explicit constexpr OperationPayment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationPayment(const OperationPayment& from);
  OperationPayment(OperationPayment&& from) noexcept
    : OperationPayment() {
    *this = ::std::move(from);
  }

  inline OperationPayment& operator=(const OperationPayment& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationPayment& operator=(OperationPayment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationPayment& default_instance() {
    return *internal_default_instance();
  }
  enum AmountOneofCase {
    kAmount = 1,
    kCurrencyAmount = 2,
    AMOUNT_ONEOF_NOT_SET = 0,
  };

  static inline const OperationPayment* internal_default_instance() {
    return reinterpret_cast<const OperationPayment*>(
               &_OperationPayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OperationPayment& a, OperationPayment& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationPayment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationPayment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationPayment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationPayment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationPayment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationPayment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationPayment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.OperationPayment";
  }
  protected:
  explicit OperationPayment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 3,
    kDestinationTagFieldNumber = 4,
    kAmountFieldNumber = 1,
    kCurrencyAmountFieldNumber = 2,
  };
  // string destination = 3;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // int64 destination_tag = 4;
  void clear_destination_tag();
  int64_t destination_tag() const;
  void set_destination_tag(int64_t value);
  private:
  int64_t _internal_destination_tag() const;
  void _internal_set_destination_tag(int64_t value);
  public:

  // int64 amount = 1;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // .TW.Ripple.Proto.CurrencyAmount currency_amount = 2;
  bool has_currency_amount() const;
  private:
  bool _internal_has_currency_amount() const;
  public:
  void clear_currency_amount();
  const ::TW::Ripple::Proto::CurrencyAmount& currency_amount() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::CurrencyAmount* release_currency_amount();
  ::TW::Ripple::Proto::CurrencyAmount* mutable_currency_amount();
  void set_allocated_currency_amount(::TW::Ripple::Proto::CurrencyAmount* currency_amount);
  private:
  const ::TW::Ripple::Proto::CurrencyAmount& _internal_currency_amount() const;
  ::TW::Ripple::Proto::CurrencyAmount* _internal_mutable_currency_amount();
  public:
  void unsafe_arena_set_allocated_currency_amount(
      ::TW::Ripple::Proto::CurrencyAmount* currency_amount);
  ::TW::Ripple::Proto::CurrencyAmount* unsafe_arena_release_currency_amount();

  void clear_amount_oneof();
  AmountOneofCase amount_oneof_case() const;
  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.OperationPayment)
 private:
  class _Internal;
  void set_has_amount();
  void set_has_currency_amount();

  inline bool has_amount_oneof() const;
  inline void clear_has_amount_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  int64_t destination_tag_;
  union AmountOneofUnion {
    constexpr AmountOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int64_t amount_;
    ::TW::Ripple::Proto::CurrencyAmount* currency_amount_;
  } amount_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class OperationNFTokenBurn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.OperationNFTokenBurn) */ {
 public:
  inline OperationNFTokenBurn() : OperationNFTokenBurn(nullptr) {}
  ~OperationNFTokenBurn() override;
  explicit constexpr OperationNFTokenBurn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationNFTokenBurn(const OperationNFTokenBurn& from);
  OperationNFTokenBurn(OperationNFTokenBurn&& from) noexcept
    : OperationNFTokenBurn() {
    *this = ::std::move(from);
  }

  inline OperationNFTokenBurn& operator=(const OperationNFTokenBurn& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationNFTokenBurn& operator=(OperationNFTokenBurn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationNFTokenBurn& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationNFTokenBurn* internal_default_instance() {
    return reinterpret_cast<const OperationNFTokenBurn*>(
               &_OperationNFTokenBurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OperationNFTokenBurn& a, OperationNFTokenBurn& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationNFTokenBurn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationNFTokenBurn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationNFTokenBurn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationNFTokenBurn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationNFTokenBurn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationNFTokenBurn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationNFTokenBurn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.OperationNFTokenBurn";
  }
  protected:
  explicit OperationNFTokenBurn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNftokenIdFieldNumber = 1,
  };
  // bytes nftoken_id = 1;
  void clear_nftoken_id();
  const std::string& nftoken_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nftoken_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nftoken_id();
  PROTOBUF_NODISCARD std::string* release_nftoken_id();
  void set_allocated_nftoken_id(std::string* nftoken_id);
  private:
  const std::string& _internal_nftoken_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nftoken_id(const std::string& value);
  std::string* _internal_mutable_nftoken_id();
  public:

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.OperationNFTokenBurn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nftoken_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class OperationNFTokenCreateOffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.OperationNFTokenCreateOffer) */ {
 public:
  inline OperationNFTokenCreateOffer() : OperationNFTokenCreateOffer(nullptr) {}
  ~OperationNFTokenCreateOffer() override;
  explicit constexpr OperationNFTokenCreateOffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationNFTokenCreateOffer(const OperationNFTokenCreateOffer& from);
  OperationNFTokenCreateOffer(OperationNFTokenCreateOffer&& from) noexcept
    : OperationNFTokenCreateOffer() {
    *this = ::std::move(from);
  }

  inline OperationNFTokenCreateOffer& operator=(const OperationNFTokenCreateOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationNFTokenCreateOffer& operator=(OperationNFTokenCreateOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationNFTokenCreateOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationNFTokenCreateOffer* internal_default_instance() {
    return reinterpret_cast<const OperationNFTokenCreateOffer*>(
               &_OperationNFTokenCreateOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OperationNFTokenCreateOffer& a, OperationNFTokenCreateOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationNFTokenCreateOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationNFTokenCreateOffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationNFTokenCreateOffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationNFTokenCreateOffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationNFTokenCreateOffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationNFTokenCreateOffer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationNFTokenCreateOffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.OperationNFTokenCreateOffer";
  }
  protected:
  explicit OperationNFTokenCreateOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNftokenIdFieldNumber = 1,
    kDestinationFieldNumber = 2,
  };
  // bytes nftoken_id = 1;
  void clear_nftoken_id();
  const std::string& nftoken_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nftoken_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nftoken_id();
  PROTOBUF_NODISCARD std::string* release_nftoken_id();
  void set_allocated_nftoken_id(std::string* nftoken_id);
  private:
  const std::string& _internal_nftoken_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nftoken_id(const std::string& value);
  std::string* _internal_mutable_nftoken_id();
  public:

  // string destination = 2;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.OperationNFTokenCreateOffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nftoken_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class OperationNFTokenAcceptOffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.OperationNFTokenAcceptOffer) */ {
 public:
  inline OperationNFTokenAcceptOffer() : OperationNFTokenAcceptOffer(nullptr) {}
  ~OperationNFTokenAcceptOffer() override;
  explicit constexpr OperationNFTokenAcceptOffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationNFTokenAcceptOffer(const OperationNFTokenAcceptOffer& from);
  OperationNFTokenAcceptOffer(OperationNFTokenAcceptOffer&& from) noexcept
    : OperationNFTokenAcceptOffer() {
    *this = ::std::move(from);
  }

  inline OperationNFTokenAcceptOffer& operator=(const OperationNFTokenAcceptOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationNFTokenAcceptOffer& operator=(OperationNFTokenAcceptOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationNFTokenAcceptOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationNFTokenAcceptOffer* internal_default_instance() {
    return reinterpret_cast<const OperationNFTokenAcceptOffer*>(
               &_OperationNFTokenAcceptOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OperationNFTokenAcceptOffer& a, OperationNFTokenAcceptOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationNFTokenAcceptOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationNFTokenAcceptOffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationNFTokenAcceptOffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationNFTokenAcceptOffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationNFTokenAcceptOffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationNFTokenAcceptOffer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationNFTokenAcceptOffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.OperationNFTokenAcceptOffer";
  }
  protected:
  explicit OperationNFTokenAcceptOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellOfferFieldNumber = 1,
  };
  // bytes sell_offer = 1;
  void clear_sell_offer();
  const std::string& sell_offer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_offer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_offer();
  PROTOBUF_NODISCARD std::string* release_sell_offer();
  void set_allocated_sell_offer(std::string* sell_offer);
  private:
  const std::string& _internal_sell_offer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_offer(const std::string& value);
  std::string* _internal_mutable_sell_offer();
  public:

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.OperationNFTokenAcceptOffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_offer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class OperationNFTokenCancelOffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.OperationNFTokenCancelOffer) */ {
 public:
  inline OperationNFTokenCancelOffer() : OperationNFTokenCancelOffer(nullptr) {}
  ~OperationNFTokenCancelOffer() override;
  explicit constexpr OperationNFTokenCancelOffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationNFTokenCancelOffer(const OperationNFTokenCancelOffer& from);
  OperationNFTokenCancelOffer(OperationNFTokenCancelOffer&& from) noexcept
    : OperationNFTokenCancelOffer() {
    *this = ::std::move(from);
  }

  inline OperationNFTokenCancelOffer& operator=(const OperationNFTokenCancelOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationNFTokenCancelOffer& operator=(OperationNFTokenCancelOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationNFTokenCancelOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationNFTokenCancelOffer* internal_default_instance() {
    return reinterpret_cast<const OperationNFTokenCancelOffer*>(
               &_OperationNFTokenCancelOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OperationNFTokenCancelOffer& a, OperationNFTokenCancelOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationNFTokenCancelOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationNFTokenCancelOffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationNFTokenCancelOffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationNFTokenCancelOffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationNFTokenCancelOffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationNFTokenCancelOffer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationNFTokenCancelOffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.OperationNFTokenCancelOffer";
  }
  protected:
  explicit OperationNFTokenCancelOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenOffersFieldNumber = 1,
  };
  // repeated bytes token_offers = 1;
  int token_offers_size() const;
  private:
  int _internal_token_offers_size() const;
  public:
  void clear_token_offers();
  const std::string& token_offers(int index) const;
  std::string* mutable_token_offers(int index);
  void set_token_offers(int index, const std::string& value);
  void set_token_offers(int index, std::string&& value);
  void set_token_offers(int index, const char* value);
  void set_token_offers(int index, const void* value, size_t size);
  std::string* add_token_offers();
  void add_token_offers(const std::string& value);
  void add_token_offers(std::string&& value);
  void add_token_offers(const char* value);
  void add_token_offers(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& token_offers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_token_offers();
  private:
  const std::string& _internal_token_offers(int index) const;
  std::string* _internal_add_token_offers();
  public:

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.OperationNFTokenCancelOffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> token_offers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class SigningInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.SigningInput) */ {
 public:
  inline SigningInput() : SigningInput(nullptr) {}
  ~SigningInput() override;
  explicit constexpr SigningInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningInput(const SigningInput& from);
  SigningInput(SigningInput&& from) noexcept
    : SigningInput() {
    *this = ::std::move(from);
  }

  inline SigningInput& operator=(const SigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningInput& operator=(SigningInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningInput& default_instance() {
    return *internal_default_instance();
  }
  enum OperationOneofCase {
    kOpTrustSet = 7,
    kOpPayment = 8,
    kOpNftokenBurn = 9,
    kOpNftokenCreateOffer = 10,
    kOpNftokenAcceptOffer = 11,
    kOpNftokenCancelOffer = 12,
    OPERATION_ONEOF_NOT_SET = 0,
  };

  static inline const SigningInput* internal_default_instance() {
    return reinterpret_cast<const SigningInput*>(
               &_SigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SigningInput& a, SigningInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.SigningInput";
  }
  protected:
  explicit SigningInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 4,
    kPrivateKeyFieldNumber = 6,
    kPublicKeyFieldNumber = 15,
    kFeeFieldNumber = 1,
    kSequenceFieldNumber = 2,
    kLastLedgerSequenceFieldNumber = 3,
    kFlagsFieldNumber = 5,
    kOpTrustSetFieldNumber = 7,
    kOpPaymentFieldNumber = 8,
    kOpNftokenBurnFieldNumber = 9,
    kOpNftokenCreateOfferFieldNumber = 10,
    kOpNftokenAcceptOfferFieldNumber = 11,
    kOpNftokenCancelOfferFieldNumber = 12,
  };
  // string account = 4;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes private_key = 6;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // bytes public_key = 15;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // int64 fee = 1;
  void clear_fee();
  int64_t fee() const;
  void set_fee(int64_t value);
  private:
  int64_t _internal_fee() const;
  void _internal_set_fee(int64_t value);
  public:

  // int32 sequence = 2;
  void clear_sequence();
  int32_t sequence() const;
  void set_sequence(int32_t value);
  private:
  int32_t _internal_sequence() const;
  void _internal_set_sequence(int32_t value);
  public:

  // int32 last_ledger_sequence = 3;
  void clear_last_ledger_sequence();
  int32_t last_ledger_sequence() const;
  void set_last_ledger_sequence(int32_t value);
  private:
  int32_t _internal_last_ledger_sequence() const;
  void _internal_set_last_ledger_sequence(int32_t value);
  public:

  // int64 flags = 5;
  void clear_flags();
  int64_t flags() const;
  void set_flags(int64_t value);
  private:
  int64_t _internal_flags() const;
  void _internal_set_flags(int64_t value);
  public:

  // .TW.Ripple.Proto.OperationTrustSet op_trust_set = 7;
  bool has_op_trust_set() const;
  private:
  bool _internal_has_op_trust_set() const;
  public:
  void clear_op_trust_set();
  const ::TW::Ripple::Proto::OperationTrustSet& op_trust_set() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::OperationTrustSet* release_op_trust_set();
  ::TW::Ripple::Proto::OperationTrustSet* mutable_op_trust_set();
  void set_allocated_op_trust_set(::TW::Ripple::Proto::OperationTrustSet* op_trust_set);
  private:
  const ::TW::Ripple::Proto::OperationTrustSet& _internal_op_trust_set() const;
  ::TW::Ripple::Proto::OperationTrustSet* _internal_mutable_op_trust_set();
  public:
  void unsafe_arena_set_allocated_op_trust_set(
      ::TW::Ripple::Proto::OperationTrustSet* op_trust_set);
  ::TW::Ripple::Proto::OperationTrustSet* unsafe_arena_release_op_trust_set();

  // .TW.Ripple.Proto.OperationPayment op_payment = 8;
  bool has_op_payment() const;
  private:
  bool _internal_has_op_payment() const;
  public:
  void clear_op_payment();
  const ::TW::Ripple::Proto::OperationPayment& op_payment() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::OperationPayment* release_op_payment();
  ::TW::Ripple::Proto::OperationPayment* mutable_op_payment();
  void set_allocated_op_payment(::TW::Ripple::Proto::OperationPayment* op_payment);
  private:
  const ::TW::Ripple::Proto::OperationPayment& _internal_op_payment() const;
  ::TW::Ripple::Proto::OperationPayment* _internal_mutable_op_payment();
  public:
  void unsafe_arena_set_allocated_op_payment(
      ::TW::Ripple::Proto::OperationPayment* op_payment);
  ::TW::Ripple::Proto::OperationPayment* unsafe_arena_release_op_payment();

  // .TW.Ripple.Proto.OperationNFTokenBurn op_nftoken_burn = 9;
  bool has_op_nftoken_burn() const;
  private:
  bool _internal_has_op_nftoken_burn() const;
  public:
  void clear_op_nftoken_burn();
  const ::TW::Ripple::Proto::OperationNFTokenBurn& op_nftoken_burn() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::OperationNFTokenBurn* release_op_nftoken_burn();
  ::TW::Ripple::Proto::OperationNFTokenBurn* mutable_op_nftoken_burn();
  void set_allocated_op_nftoken_burn(::TW::Ripple::Proto::OperationNFTokenBurn* op_nftoken_burn);
  private:
  const ::TW::Ripple::Proto::OperationNFTokenBurn& _internal_op_nftoken_burn() const;
  ::TW::Ripple::Proto::OperationNFTokenBurn* _internal_mutable_op_nftoken_burn();
  public:
  void unsafe_arena_set_allocated_op_nftoken_burn(
      ::TW::Ripple::Proto::OperationNFTokenBurn* op_nftoken_burn);
  ::TW::Ripple::Proto::OperationNFTokenBurn* unsafe_arena_release_op_nftoken_burn();

  // .TW.Ripple.Proto.OperationNFTokenCreateOffer op_nftoken_create_offer = 10;
  bool has_op_nftoken_create_offer() const;
  private:
  bool _internal_has_op_nftoken_create_offer() const;
  public:
  void clear_op_nftoken_create_offer();
  const ::TW::Ripple::Proto::OperationNFTokenCreateOffer& op_nftoken_create_offer() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::OperationNFTokenCreateOffer* release_op_nftoken_create_offer();
  ::TW::Ripple::Proto::OperationNFTokenCreateOffer* mutable_op_nftoken_create_offer();
  void set_allocated_op_nftoken_create_offer(::TW::Ripple::Proto::OperationNFTokenCreateOffer* op_nftoken_create_offer);
  private:
  const ::TW::Ripple::Proto::OperationNFTokenCreateOffer& _internal_op_nftoken_create_offer() const;
  ::TW::Ripple::Proto::OperationNFTokenCreateOffer* _internal_mutable_op_nftoken_create_offer();
  public:
  void unsafe_arena_set_allocated_op_nftoken_create_offer(
      ::TW::Ripple::Proto::OperationNFTokenCreateOffer* op_nftoken_create_offer);
  ::TW::Ripple::Proto::OperationNFTokenCreateOffer* unsafe_arena_release_op_nftoken_create_offer();

  // .TW.Ripple.Proto.OperationNFTokenAcceptOffer op_nftoken_accept_offer = 11;
  bool has_op_nftoken_accept_offer() const;
  private:
  bool _internal_has_op_nftoken_accept_offer() const;
  public:
  void clear_op_nftoken_accept_offer();
  const ::TW::Ripple::Proto::OperationNFTokenAcceptOffer& op_nftoken_accept_offer() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* release_op_nftoken_accept_offer();
  ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* mutable_op_nftoken_accept_offer();
  void set_allocated_op_nftoken_accept_offer(::TW::Ripple::Proto::OperationNFTokenAcceptOffer* op_nftoken_accept_offer);
  private:
  const ::TW::Ripple::Proto::OperationNFTokenAcceptOffer& _internal_op_nftoken_accept_offer() const;
  ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* _internal_mutable_op_nftoken_accept_offer();
  public:
  void unsafe_arena_set_allocated_op_nftoken_accept_offer(
      ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* op_nftoken_accept_offer);
  ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* unsafe_arena_release_op_nftoken_accept_offer();

  // .TW.Ripple.Proto.OperationNFTokenCancelOffer op_nftoken_cancel_offer = 12;
  bool has_op_nftoken_cancel_offer() const;
  private:
  bool _internal_has_op_nftoken_cancel_offer() const;
  public:
  void clear_op_nftoken_cancel_offer();
  const ::TW::Ripple::Proto::OperationNFTokenCancelOffer& op_nftoken_cancel_offer() const;
  PROTOBUF_NODISCARD ::TW::Ripple::Proto::OperationNFTokenCancelOffer* release_op_nftoken_cancel_offer();
  ::TW::Ripple::Proto::OperationNFTokenCancelOffer* mutable_op_nftoken_cancel_offer();
  void set_allocated_op_nftoken_cancel_offer(::TW::Ripple::Proto::OperationNFTokenCancelOffer* op_nftoken_cancel_offer);
  private:
  const ::TW::Ripple::Proto::OperationNFTokenCancelOffer& _internal_op_nftoken_cancel_offer() const;
  ::TW::Ripple::Proto::OperationNFTokenCancelOffer* _internal_mutable_op_nftoken_cancel_offer();
  public:
  void unsafe_arena_set_allocated_op_nftoken_cancel_offer(
      ::TW::Ripple::Proto::OperationNFTokenCancelOffer* op_nftoken_cancel_offer);
  ::TW::Ripple::Proto::OperationNFTokenCancelOffer* unsafe_arena_release_op_nftoken_cancel_offer();

  void clear_operation_oneof();
  OperationOneofCase operation_oneof_case() const;
  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.SigningInput)
 private:
  class _Internal;
  void set_has_op_trust_set();
  void set_has_op_payment();
  void set_has_op_nftoken_burn();
  void set_has_op_nftoken_create_offer();
  void set_has_op_nftoken_accept_offer();
  void set_has_op_nftoken_cancel_offer();

  inline bool has_operation_oneof() const;
  inline void clear_has_operation_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  int64_t fee_;
  int32_t sequence_;
  int32_t last_ledger_sequence_;
  int64_t flags_;
  union OperationOneofUnion {
    constexpr OperationOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Ripple::Proto::OperationTrustSet* op_trust_set_;
    ::TW::Ripple::Proto::OperationPayment* op_payment_;
    ::TW::Ripple::Proto::OperationNFTokenBurn* op_nftoken_burn_;
    ::TW::Ripple::Proto::OperationNFTokenCreateOffer* op_nftoken_create_offer_;
    ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* op_nftoken_accept_offer_;
    ::TW::Ripple::Proto::OperationNFTokenCancelOffer* op_nftoken_cancel_offer_;
  } operation_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Ripple_2eproto;
};
// -------------------------------------------------------------------

class SigningOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Ripple.Proto.SigningOutput) */ {
 public:
  inline SigningOutput() : SigningOutput(nullptr) {}
  ~SigningOutput() override;
  explicit constexpr SigningOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningOutput(const SigningOutput& from);
  SigningOutput(SigningOutput&& from) noexcept
    : SigningOutput() {
    *this = ::std::move(from);
  }

  inline SigningOutput& operator=(const SigningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningOutput& operator=(SigningOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningOutput* internal_default_instance() {
    return reinterpret_cast<const SigningOutput*>(
               &_SigningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SigningOutput& a, SigningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Ripple.Proto.SigningOutput";
  }
  protected:
  explicit SigningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kErrorFieldNumber = 2,
  };
  // bytes encoded = 1;
  void clear_encoded();
  const std::string& encoded() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded();
  PROTOBUF_NODISCARD std::string* release_encoded();
  void set_allocated_encoded(std::string* encoded);
  private:
  const std::string& _internal_encoded() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded(const std::string& value);
  std::string* _internal_mutable_encoded();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .TW.Common.Proto.SigningError error = 2;
  void clear_error();
  ::TW::Common::Proto::SigningError error() const;
  void set_error(::TW::Common::Proto::SigningError value);
  private:
  ::TW::Common::Proto::SigningError _internal_error() const;
  void _internal_set_error(::TW::Common::Proto::SigningError value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Ripple.Proto.SigningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Ripple_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CurrencyAmount

// string currency = 1;
inline void CurrencyAmount::clear_currency() {
  currency_.ClearToEmpty();
}
inline const std::string& CurrencyAmount::currency() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.CurrencyAmount.currency)
  return _internal_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyAmount::set_currency(ArgT0&& arg0, ArgT... args) {
 
 currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.CurrencyAmount.currency)
}
inline std::string* CurrencyAmount::mutable_currency() {
  std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.CurrencyAmount.currency)
  return _s;
}
inline const std::string& CurrencyAmount::_internal_currency() const {
  return currency_.Get();
}
inline void CurrencyAmount::_internal_set_currency(const std::string& value) {
  
  currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyAmount::_internal_mutable_currency() {
  
  return currency_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyAmount::release_currency() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.CurrencyAmount.currency)
  return currency_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrencyAmount::set_allocated_currency(std::string* currency) {
  if (currency != nullptr) {
    
  } else {
    
  }
  currency_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currency,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (currency_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    currency_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.CurrencyAmount.currency)
}

// string value = 2;
inline void CurrencyAmount::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& CurrencyAmount::value() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.CurrencyAmount.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyAmount::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.CurrencyAmount.value)
}
inline std::string* CurrencyAmount::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.CurrencyAmount.value)
  return _s;
}
inline const std::string& CurrencyAmount::_internal_value() const {
  return value_.Get();
}
inline void CurrencyAmount::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyAmount::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyAmount::release_value() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.CurrencyAmount.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrencyAmount::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.CurrencyAmount.value)
}

// string issuer = 3;
inline void CurrencyAmount::clear_issuer() {
  issuer_.ClearToEmpty();
}
inline const std::string& CurrencyAmount::issuer() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.CurrencyAmount.issuer)
  return _internal_issuer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyAmount::set_issuer(ArgT0&& arg0, ArgT... args) {
 
 issuer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.CurrencyAmount.issuer)
}
inline std::string* CurrencyAmount::mutable_issuer() {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.CurrencyAmount.issuer)
  return _s;
}
inline const std::string& CurrencyAmount::_internal_issuer() const {
  return issuer_.Get();
}
inline void CurrencyAmount::_internal_set_issuer(const std::string& value) {
  
  issuer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyAmount::_internal_mutable_issuer() {
  
  return issuer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyAmount::release_issuer() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.CurrencyAmount.issuer)
  return issuer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrencyAmount::set_allocated_issuer(std::string* issuer) {
  if (issuer != nullptr) {
    
  } else {
    
  }
  issuer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), issuer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (issuer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    issuer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.CurrencyAmount.issuer)
}

// -------------------------------------------------------------------

// OperationTrustSet

// .TW.Ripple.Proto.CurrencyAmount limit_amount = 1;
inline bool OperationTrustSet::_internal_has_limit_amount() const {
  return this != internal_default_instance() && limit_amount_ != nullptr;
}
inline bool OperationTrustSet::has_limit_amount() const {
  return _internal_has_limit_amount();
}
inline void OperationTrustSet::clear_limit_amount() {
  if (GetArenaForAllocation() == nullptr && limit_amount_ != nullptr) {
    delete limit_amount_;
  }
  limit_amount_ = nullptr;
}
inline const ::TW::Ripple::Proto::CurrencyAmount& OperationTrustSet::_internal_limit_amount() const {
  const ::TW::Ripple::Proto::CurrencyAmount* p = limit_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Ripple::Proto::CurrencyAmount&>(
      ::TW::Ripple::Proto::_CurrencyAmount_default_instance_);
}
inline const ::TW::Ripple::Proto::CurrencyAmount& OperationTrustSet::limit_amount() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationTrustSet.limit_amount)
  return _internal_limit_amount();
}
inline void OperationTrustSet::unsafe_arena_set_allocated_limit_amount(
    ::TW::Ripple::Proto::CurrencyAmount* limit_amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit_amount_);
  }
  limit_amount_ = limit_amount;
  if (limit_amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.OperationTrustSet.limit_amount)
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationTrustSet::release_limit_amount() {
  
  ::TW::Ripple::Proto::CurrencyAmount* temp = limit_amount_;
  limit_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationTrustSet::unsafe_arena_release_limit_amount() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationTrustSet.limit_amount)
  
  ::TW::Ripple::Proto::CurrencyAmount* temp = limit_amount_;
  limit_amount_ = nullptr;
  return temp;
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationTrustSet::_internal_mutable_limit_amount() {
  
  if (limit_amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Ripple::Proto::CurrencyAmount>(GetArenaForAllocation());
    limit_amount_ = p;
  }
  return limit_amount_;
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationTrustSet::mutable_limit_amount() {
  ::TW::Ripple::Proto::CurrencyAmount* _msg = _internal_mutable_limit_amount();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationTrustSet.limit_amount)
  return _msg;
}
inline void OperationTrustSet::set_allocated_limit_amount(::TW::Ripple::Proto::CurrencyAmount* limit_amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete limit_amount_;
  }
  if (limit_amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Ripple::Proto::CurrencyAmount>::GetOwningArena(limit_amount);
    if (message_arena != submessage_arena) {
      limit_amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_amount, submessage_arena);
    }
    
  } else {
    
  }
  limit_amount_ = limit_amount;
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.OperationTrustSet.limit_amount)
}

// -------------------------------------------------------------------

// OperationPayment

// int64 amount = 1;
inline bool OperationPayment::_internal_has_amount() const {
  return amount_oneof_case() == kAmount;
}
inline bool OperationPayment::has_amount() const {
  return _internal_has_amount();
}
inline void OperationPayment::set_has_amount() {
  _oneof_case_[0] = kAmount;
}
inline void OperationPayment::clear_amount() {
  if (_internal_has_amount()) {
    amount_oneof_.amount_ = int64_t{0};
    clear_has_amount_oneof();
  }
}
inline int64_t OperationPayment::_internal_amount() const {
  if (_internal_has_amount()) {
    return amount_oneof_.amount_;
  }
  return int64_t{0};
}
inline void OperationPayment::_internal_set_amount(int64_t value) {
  if (!_internal_has_amount()) {
    clear_amount_oneof();
    set_has_amount();
  }
  amount_oneof_.amount_ = value;
}
inline int64_t OperationPayment::amount() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationPayment.amount)
  return _internal_amount();
}
inline void OperationPayment::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationPayment.amount)
}

// .TW.Ripple.Proto.CurrencyAmount currency_amount = 2;
inline bool OperationPayment::_internal_has_currency_amount() const {
  return amount_oneof_case() == kCurrencyAmount;
}
inline bool OperationPayment::has_currency_amount() const {
  return _internal_has_currency_amount();
}
inline void OperationPayment::set_has_currency_amount() {
  _oneof_case_[0] = kCurrencyAmount;
}
inline void OperationPayment::clear_currency_amount() {
  if (_internal_has_currency_amount()) {
    if (GetArenaForAllocation() == nullptr) {
      delete amount_oneof_.currency_amount_;
    }
    clear_has_amount_oneof();
  }
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationPayment::release_currency_amount() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationPayment.currency_amount)
  if (_internal_has_currency_amount()) {
    clear_has_amount_oneof();
      ::TW::Ripple::Proto::CurrencyAmount* temp = amount_oneof_.currency_amount_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    amount_oneof_.currency_amount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::CurrencyAmount& OperationPayment::_internal_currency_amount() const {
  return _internal_has_currency_amount()
      ? *amount_oneof_.currency_amount_
      : reinterpret_cast< ::TW::Ripple::Proto::CurrencyAmount&>(::TW::Ripple::Proto::_CurrencyAmount_default_instance_);
}
inline const ::TW::Ripple::Proto::CurrencyAmount& OperationPayment::currency_amount() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationPayment.currency_amount)
  return _internal_currency_amount();
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationPayment::unsafe_arena_release_currency_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.OperationPayment.currency_amount)
  if (_internal_has_currency_amount()) {
    clear_has_amount_oneof();
    ::TW::Ripple::Proto::CurrencyAmount* temp = amount_oneof_.currency_amount_;
    amount_oneof_.currency_amount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OperationPayment::unsafe_arena_set_allocated_currency_amount(::TW::Ripple::Proto::CurrencyAmount* currency_amount) {
  clear_amount_oneof();
  if (currency_amount) {
    set_has_currency_amount();
    amount_oneof_.currency_amount_ = currency_amount;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.OperationPayment.currency_amount)
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationPayment::_internal_mutable_currency_amount() {
  if (!_internal_has_currency_amount()) {
    clear_amount_oneof();
    set_has_currency_amount();
    amount_oneof_.currency_amount_ = CreateMaybeMessage< ::TW::Ripple::Proto::CurrencyAmount >(GetArenaForAllocation());
  }
  return amount_oneof_.currency_amount_;
}
inline ::TW::Ripple::Proto::CurrencyAmount* OperationPayment::mutable_currency_amount() {
  ::TW::Ripple::Proto::CurrencyAmount* _msg = _internal_mutable_currency_amount();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationPayment.currency_amount)
  return _msg;
}

// string destination = 3;
inline void OperationPayment::clear_destination() {
  destination_.ClearToEmpty();
}
inline const std::string& OperationPayment::destination() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationPayment.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationPayment::set_destination(ArgT0&& arg0, ArgT... args) {
 
 destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationPayment.destination)
}
inline std::string* OperationPayment::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationPayment.destination)
  return _s;
}
inline const std::string& OperationPayment::_internal_destination() const {
  return destination_.Get();
}
inline void OperationPayment::_internal_set_destination(const std::string& value) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationPayment::_internal_mutable_destination() {
  
  return destination_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationPayment::release_destination() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationPayment.destination)
  return destination_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationPayment::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.OperationPayment.destination)
}

// int64 destination_tag = 4;
inline void OperationPayment::clear_destination_tag() {
  destination_tag_ = int64_t{0};
}
inline int64_t OperationPayment::_internal_destination_tag() const {
  return destination_tag_;
}
inline int64_t OperationPayment::destination_tag() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationPayment.destination_tag)
  return _internal_destination_tag();
}
inline void OperationPayment::_internal_set_destination_tag(int64_t value) {
  
  destination_tag_ = value;
}
inline void OperationPayment::set_destination_tag(int64_t value) {
  _internal_set_destination_tag(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationPayment.destination_tag)
}

inline bool OperationPayment::has_amount_oneof() const {
  return amount_oneof_case() != AMOUNT_ONEOF_NOT_SET;
}
inline void OperationPayment::clear_has_amount_oneof() {
  _oneof_case_[0] = AMOUNT_ONEOF_NOT_SET;
}
inline OperationPayment::AmountOneofCase OperationPayment::amount_oneof_case() const {
  return OperationPayment::AmountOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OperationNFTokenBurn

// bytes nftoken_id = 1;
inline void OperationNFTokenBurn::clear_nftoken_id() {
  nftoken_id_.ClearToEmpty();
}
inline const std::string& OperationNFTokenBurn::nftoken_id() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationNFTokenBurn.nftoken_id)
  return _internal_nftoken_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationNFTokenBurn::set_nftoken_id(ArgT0&& arg0, ArgT... args) {
 
 nftoken_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationNFTokenBurn.nftoken_id)
}
inline std::string* OperationNFTokenBurn::mutable_nftoken_id() {
  std::string* _s = _internal_mutable_nftoken_id();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationNFTokenBurn.nftoken_id)
  return _s;
}
inline const std::string& OperationNFTokenBurn::_internal_nftoken_id() const {
  return nftoken_id_.Get();
}
inline void OperationNFTokenBurn::_internal_set_nftoken_id(const std::string& value) {
  
  nftoken_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationNFTokenBurn::_internal_mutable_nftoken_id() {
  
  return nftoken_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationNFTokenBurn::release_nftoken_id() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationNFTokenBurn.nftoken_id)
  return nftoken_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationNFTokenBurn::set_allocated_nftoken_id(std::string* nftoken_id) {
  if (nftoken_id != nullptr) {
    
  } else {
    
  }
  nftoken_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nftoken_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nftoken_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nftoken_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.OperationNFTokenBurn.nftoken_id)
}

// -------------------------------------------------------------------

// OperationNFTokenCreateOffer

// bytes nftoken_id = 1;
inline void OperationNFTokenCreateOffer::clear_nftoken_id() {
  nftoken_id_.ClearToEmpty();
}
inline const std::string& OperationNFTokenCreateOffer::nftoken_id() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationNFTokenCreateOffer.nftoken_id)
  return _internal_nftoken_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationNFTokenCreateOffer::set_nftoken_id(ArgT0&& arg0, ArgT... args) {
 
 nftoken_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationNFTokenCreateOffer.nftoken_id)
}
inline std::string* OperationNFTokenCreateOffer::mutable_nftoken_id() {
  std::string* _s = _internal_mutable_nftoken_id();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationNFTokenCreateOffer.nftoken_id)
  return _s;
}
inline const std::string& OperationNFTokenCreateOffer::_internal_nftoken_id() const {
  return nftoken_id_.Get();
}
inline void OperationNFTokenCreateOffer::_internal_set_nftoken_id(const std::string& value) {
  
  nftoken_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationNFTokenCreateOffer::_internal_mutable_nftoken_id() {
  
  return nftoken_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationNFTokenCreateOffer::release_nftoken_id() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationNFTokenCreateOffer.nftoken_id)
  return nftoken_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationNFTokenCreateOffer::set_allocated_nftoken_id(std::string* nftoken_id) {
  if (nftoken_id != nullptr) {
    
  } else {
    
  }
  nftoken_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nftoken_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nftoken_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nftoken_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.OperationNFTokenCreateOffer.nftoken_id)
}

// string destination = 2;
inline void OperationNFTokenCreateOffer::clear_destination() {
  destination_.ClearToEmpty();
}
inline const std::string& OperationNFTokenCreateOffer::destination() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationNFTokenCreateOffer.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationNFTokenCreateOffer::set_destination(ArgT0&& arg0, ArgT... args) {
 
 destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationNFTokenCreateOffer.destination)
}
inline std::string* OperationNFTokenCreateOffer::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationNFTokenCreateOffer.destination)
  return _s;
}
inline const std::string& OperationNFTokenCreateOffer::_internal_destination() const {
  return destination_.Get();
}
inline void OperationNFTokenCreateOffer::_internal_set_destination(const std::string& value) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationNFTokenCreateOffer::_internal_mutable_destination() {
  
  return destination_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationNFTokenCreateOffer::release_destination() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationNFTokenCreateOffer.destination)
  return destination_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationNFTokenCreateOffer::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.OperationNFTokenCreateOffer.destination)
}

// -------------------------------------------------------------------

// OperationNFTokenAcceptOffer

// bytes sell_offer = 1;
inline void OperationNFTokenAcceptOffer::clear_sell_offer() {
  sell_offer_.ClearToEmpty();
}
inline const std::string& OperationNFTokenAcceptOffer::sell_offer() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationNFTokenAcceptOffer.sell_offer)
  return _internal_sell_offer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationNFTokenAcceptOffer::set_sell_offer(ArgT0&& arg0, ArgT... args) {
 
 sell_offer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationNFTokenAcceptOffer.sell_offer)
}
inline std::string* OperationNFTokenAcceptOffer::mutable_sell_offer() {
  std::string* _s = _internal_mutable_sell_offer();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationNFTokenAcceptOffer.sell_offer)
  return _s;
}
inline const std::string& OperationNFTokenAcceptOffer::_internal_sell_offer() const {
  return sell_offer_.Get();
}
inline void OperationNFTokenAcceptOffer::_internal_set_sell_offer(const std::string& value) {
  
  sell_offer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationNFTokenAcceptOffer::_internal_mutable_sell_offer() {
  
  return sell_offer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationNFTokenAcceptOffer::release_sell_offer() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.OperationNFTokenAcceptOffer.sell_offer)
  return sell_offer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationNFTokenAcceptOffer::set_allocated_sell_offer(std::string* sell_offer) {
  if (sell_offer != nullptr) {
    
  } else {
    
  }
  sell_offer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_offer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sell_offer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sell_offer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.OperationNFTokenAcceptOffer.sell_offer)
}

// -------------------------------------------------------------------

// OperationNFTokenCancelOffer

// repeated bytes token_offers = 1;
inline int OperationNFTokenCancelOffer::_internal_token_offers_size() const {
  return token_offers_.size();
}
inline int OperationNFTokenCancelOffer::token_offers_size() const {
  return _internal_token_offers_size();
}
inline void OperationNFTokenCancelOffer::clear_token_offers() {
  token_offers_.Clear();
}
inline std::string* OperationNFTokenCancelOffer::add_token_offers() {
  std::string* _s = _internal_add_token_offers();
  // @@protoc_insertion_point(field_add_mutable:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
  return _s;
}
inline const std::string& OperationNFTokenCancelOffer::_internal_token_offers(int index) const {
  return token_offers_.Get(index);
}
inline const std::string& OperationNFTokenCancelOffer::token_offers(int index) const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
  return _internal_token_offers(index);
}
inline std::string* OperationNFTokenCancelOffer::mutable_token_offers(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
  return token_offers_.Mutable(index);
}
inline void OperationNFTokenCancelOffer::set_token_offers(int index, const std::string& value) {
  token_offers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline void OperationNFTokenCancelOffer::set_token_offers(int index, std::string&& value) {
  token_offers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline void OperationNFTokenCancelOffer::set_token_offers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  token_offers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline void OperationNFTokenCancelOffer::set_token_offers(int index, const void* value, size_t size) {
  token_offers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline std::string* OperationNFTokenCancelOffer::_internal_add_token_offers() {
  return token_offers_.Add();
}
inline void OperationNFTokenCancelOffer::add_token_offers(const std::string& value) {
  token_offers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline void OperationNFTokenCancelOffer::add_token_offers(std::string&& value) {
  token_offers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline void OperationNFTokenCancelOffer::add_token_offers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  token_offers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline void OperationNFTokenCancelOffer::add_token_offers(const void* value, size_t size) {
  token_offers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperationNFTokenCancelOffer::token_offers() const {
  // @@protoc_insertion_point(field_list:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
  return token_offers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperationNFTokenCancelOffer::mutable_token_offers() {
  // @@protoc_insertion_point(field_mutable_list:TW.Ripple.Proto.OperationNFTokenCancelOffer.token_offers)
  return &token_offers_;
}

// -------------------------------------------------------------------

// SigningInput

// int64 fee = 1;
inline void SigningInput::clear_fee() {
  fee_ = int64_t{0};
}
inline int64_t SigningInput::_internal_fee() const {
  return fee_;
}
inline int64_t SigningInput::fee() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.fee)
  return _internal_fee();
}
inline void SigningInput::_internal_set_fee(int64_t value) {
  
  fee_ = value;
}
inline void SigningInput::set_fee(int64_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.fee)
}

// int32 sequence = 2;
inline void SigningInput::clear_sequence() {
  sequence_ = 0;
}
inline int32_t SigningInput::_internal_sequence() const {
  return sequence_;
}
inline int32_t SigningInput::sequence() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.sequence)
  return _internal_sequence();
}
inline void SigningInput::_internal_set_sequence(int32_t value) {
  
  sequence_ = value;
}
inline void SigningInput::set_sequence(int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.sequence)
}

// int32 last_ledger_sequence = 3;
inline void SigningInput::clear_last_ledger_sequence() {
  last_ledger_sequence_ = 0;
}
inline int32_t SigningInput::_internal_last_ledger_sequence() const {
  return last_ledger_sequence_;
}
inline int32_t SigningInput::last_ledger_sequence() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.last_ledger_sequence)
  return _internal_last_ledger_sequence();
}
inline void SigningInput::_internal_set_last_ledger_sequence(int32_t value) {
  
  last_ledger_sequence_ = value;
}
inline void SigningInput::set_last_ledger_sequence(int32_t value) {
  _internal_set_last_ledger_sequence(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.last_ledger_sequence)
}

// string account = 4;
inline void SigningInput::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& SigningInput::account() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.account)
}
inline std::string* SigningInput::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.account)
  return _s;
}
inline const std::string& SigningInput::_internal_account() const {
  return account_.Get();
}
inline void SigningInput::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_account() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.SigningInput.account)
}

// int64 flags = 5;
inline void SigningInput::clear_flags() {
  flags_ = int64_t{0};
}
inline int64_t SigningInput::_internal_flags() const {
  return flags_;
}
inline int64_t SigningInput::flags() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.flags)
  return _internal_flags();
}
inline void SigningInput::_internal_set_flags(int64_t value) {
  
  flags_ = value;
}
inline void SigningInput::set_flags(int64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.flags)
}

// bytes private_key = 6;
inline void SigningInput::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& SigningInput::private_key() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 private_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.private_key)
  return _s;
}
inline const std::string& SigningInput::_internal_private_key() const {
  return private_key_.Get();
}
inline void SigningInput::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_private_key() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.SigningInput.private_key)
}

// .TW.Ripple.Proto.OperationTrustSet op_trust_set = 7;
inline bool SigningInput::_internal_has_op_trust_set() const {
  return operation_oneof_case() == kOpTrustSet;
}
inline bool SigningInput::has_op_trust_set() const {
  return _internal_has_op_trust_set();
}
inline void SigningInput::set_has_op_trust_set() {
  _oneof_case_[0] = kOpTrustSet;
}
inline void SigningInput::clear_op_trust_set() {
  if (_internal_has_op_trust_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_trust_set_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Ripple::Proto::OperationTrustSet* SigningInput::release_op_trust_set() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.op_trust_set)
  if (_internal_has_op_trust_set()) {
    clear_has_operation_oneof();
      ::TW::Ripple::Proto::OperationTrustSet* temp = operation_oneof_.op_trust_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_trust_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::OperationTrustSet& SigningInput::_internal_op_trust_set() const {
  return _internal_has_op_trust_set()
      ? *operation_oneof_.op_trust_set_
      : reinterpret_cast< ::TW::Ripple::Proto::OperationTrustSet&>(::TW::Ripple::Proto::_OperationTrustSet_default_instance_);
}
inline const ::TW::Ripple::Proto::OperationTrustSet& SigningInput::op_trust_set() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.op_trust_set)
  return _internal_op_trust_set();
}
inline ::TW::Ripple::Proto::OperationTrustSet* SigningInput::unsafe_arena_release_op_trust_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.SigningInput.op_trust_set)
  if (_internal_has_op_trust_set()) {
    clear_has_operation_oneof();
    ::TW::Ripple::Proto::OperationTrustSet* temp = operation_oneof_.op_trust_set_;
    operation_oneof_.op_trust_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_trust_set(::TW::Ripple::Proto::OperationTrustSet* op_trust_set) {
  clear_operation_oneof();
  if (op_trust_set) {
    set_has_op_trust_set();
    operation_oneof_.op_trust_set_ = op_trust_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.SigningInput.op_trust_set)
}
inline ::TW::Ripple::Proto::OperationTrustSet* SigningInput::_internal_mutable_op_trust_set() {
  if (!_internal_has_op_trust_set()) {
    clear_operation_oneof();
    set_has_op_trust_set();
    operation_oneof_.op_trust_set_ = CreateMaybeMessage< ::TW::Ripple::Proto::OperationTrustSet >(GetArenaForAllocation());
  }
  return operation_oneof_.op_trust_set_;
}
inline ::TW::Ripple::Proto::OperationTrustSet* SigningInput::mutable_op_trust_set() {
  ::TW::Ripple::Proto::OperationTrustSet* _msg = _internal_mutable_op_trust_set();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.op_trust_set)
  return _msg;
}

// .TW.Ripple.Proto.OperationPayment op_payment = 8;
inline bool SigningInput::_internal_has_op_payment() const {
  return operation_oneof_case() == kOpPayment;
}
inline bool SigningInput::has_op_payment() const {
  return _internal_has_op_payment();
}
inline void SigningInput::set_has_op_payment() {
  _oneof_case_[0] = kOpPayment;
}
inline void SigningInput::clear_op_payment() {
  if (_internal_has_op_payment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_payment_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Ripple::Proto::OperationPayment* SigningInput::release_op_payment() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.op_payment)
  if (_internal_has_op_payment()) {
    clear_has_operation_oneof();
      ::TW::Ripple::Proto::OperationPayment* temp = operation_oneof_.op_payment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_payment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::OperationPayment& SigningInput::_internal_op_payment() const {
  return _internal_has_op_payment()
      ? *operation_oneof_.op_payment_
      : reinterpret_cast< ::TW::Ripple::Proto::OperationPayment&>(::TW::Ripple::Proto::_OperationPayment_default_instance_);
}
inline const ::TW::Ripple::Proto::OperationPayment& SigningInput::op_payment() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.op_payment)
  return _internal_op_payment();
}
inline ::TW::Ripple::Proto::OperationPayment* SigningInput::unsafe_arena_release_op_payment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.SigningInput.op_payment)
  if (_internal_has_op_payment()) {
    clear_has_operation_oneof();
    ::TW::Ripple::Proto::OperationPayment* temp = operation_oneof_.op_payment_;
    operation_oneof_.op_payment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_payment(::TW::Ripple::Proto::OperationPayment* op_payment) {
  clear_operation_oneof();
  if (op_payment) {
    set_has_op_payment();
    operation_oneof_.op_payment_ = op_payment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.SigningInput.op_payment)
}
inline ::TW::Ripple::Proto::OperationPayment* SigningInput::_internal_mutable_op_payment() {
  if (!_internal_has_op_payment()) {
    clear_operation_oneof();
    set_has_op_payment();
    operation_oneof_.op_payment_ = CreateMaybeMessage< ::TW::Ripple::Proto::OperationPayment >(GetArenaForAllocation());
  }
  return operation_oneof_.op_payment_;
}
inline ::TW::Ripple::Proto::OperationPayment* SigningInput::mutable_op_payment() {
  ::TW::Ripple::Proto::OperationPayment* _msg = _internal_mutable_op_payment();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.op_payment)
  return _msg;
}

// .TW.Ripple.Proto.OperationNFTokenBurn op_nftoken_burn = 9;
inline bool SigningInput::_internal_has_op_nftoken_burn() const {
  return operation_oneof_case() == kOpNftokenBurn;
}
inline bool SigningInput::has_op_nftoken_burn() const {
  return _internal_has_op_nftoken_burn();
}
inline void SigningInput::set_has_op_nftoken_burn() {
  _oneof_case_[0] = kOpNftokenBurn;
}
inline void SigningInput::clear_op_nftoken_burn() {
  if (_internal_has_op_nftoken_burn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_nftoken_burn_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Ripple::Proto::OperationNFTokenBurn* SigningInput::release_op_nftoken_burn() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.op_nftoken_burn)
  if (_internal_has_op_nftoken_burn()) {
    clear_has_operation_oneof();
      ::TW::Ripple::Proto::OperationNFTokenBurn* temp = operation_oneof_.op_nftoken_burn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_nftoken_burn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::OperationNFTokenBurn& SigningInput::_internal_op_nftoken_burn() const {
  return _internal_has_op_nftoken_burn()
      ? *operation_oneof_.op_nftoken_burn_
      : reinterpret_cast< ::TW::Ripple::Proto::OperationNFTokenBurn&>(::TW::Ripple::Proto::_OperationNFTokenBurn_default_instance_);
}
inline const ::TW::Ripple::Proto::OperationNFTokenBurn& SigningInput::op_nftoken_burn() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.op_nftoken_burn)
  return _internal_op_nftoken_burn();
}
inline ::TW::Ripple::Proto::OperationNFTokenBurn* SigningInput::unsafe_arena_release_op_nftoken_burn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.SigningInput.op_nftoken_burn)
  if (_internal_has_op_nftoken_burn()) {
    clear_has_operation_oneof();
    ::TW::Ripple::Proto::OperationNFTokenBurn* temp = operation_oneof_.op_nftoken_burn_;
    operation_oneof_.op_nftoken_burn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_nftoken_burn(::TW::Ripple::Proto::OperationNFTokenBurn* op_nftoken_burn) {
  clear_operation_oneof();
  if (op_nftoken_burn) {
    set_has_op_nftoken_burn();
    operation_oneof_.op_nftoken_burn_ = op_nftoken_burn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.SigningInput.op_nftoken_burn)
}
inline ::TW::Ripple::Proto::OperationNFTokenBurn* SigningInput::_internal_mutable_op_nftoken_burn() {
  if (!_internal_has_op_nftoken_burn()) {
    clear_operation_oneof();
    set_has_op_nftoken_burn();
    operation_oneof_.op_nftoken_burn_ = CreateMaybeMessage< ::TW::Ripple::Proto::OperationNFTokenBurn >(GetArenaForAllocation());
  }
  return operation_oneof_.op_nftoken_burn_;
}
inline ::TW::Ripple::Proto::OperationNFTokenBurn* SigningInput::mutable_op_nftoken_burn() {
  ::TW::Ripple::Proto::OperationNFTokenBurn* _msg = _internal_mutable_op_nftoken_burn();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.op_nftoken_burn)
  return _msg;
}

// .TW.Ripple.Proto.OperationNFTokenCreateOffer op_nftoken_create_offer = 10;
inline bool SigningInput::_internal_has_op_nftoken_create_offer() const {
  return operation_oneof_case() == kOpNftokenCreateOffer;
}
inline bool SigningInput::has_op_nftoken_create_offer() const {
  return _internal_has_op_nftoken_create_offer();
}
inline void SigningInput::set_has_op_nftoken_create_offer() {
  _oneof_case_[0] = kOpNftokenCreateOffer;
}
inline void SigningInput::clear_op_nftoken_create_offer() {
  if (_internal_has_op_nftoken_create_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_nftoken_create_offer_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Ripple::Proto::OperationNFTokenCreateOffer* SigningInput::release_op_nftoken_create_offer() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.op_nftoken_create_offer)
  if (_internal_has_op_nftoken_create_offer()) {
    clear_has_operation_oneof();
      ::TW::Ripple::Proto::OperationNFTokenCreateOffer* temp = operation_oneof_.op_nftoken_create_offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_nftoken_create_offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::OperationNFTokenCreateOffer& SigningInput::_internal_op_nftoken_create_offer() const {
  return _internal_has_op_nftoken_create_offer()
      ? *operation_oneof_.op_nftoken_create_offer_
      : reinterpret_cast< ::TW::Ripple::Proto::OperationNFTokenCreateOffer&>(::TW::Ripple::Proto::_OperationNFTokenCreateOffer_default_instance_);
}
inline const ::TW::Ripple::Proto::OperationNFTokenCreateOffer& SigningInput::op_nftoken_create_offer() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.op_nftoken_create_offer)
  return _internal_op_nftoken_create_offer();
}
inline ::TW::Ripple::Proto::OperationNFTokenCreateOffer* SigningInput::unsafe_arena_release_op_nftoken_create_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.SigningInput.op_nftoken_create_offer)
  if (_internal_has_op_nftoken_create_offer()) {
    clear_has_operation_oneof();
    ::TW::Ripple::Proto::OperationNFTokenCreateOffer* temp = operation_oneof_.op_nftoken_create_offer_;
    operation_oneof_.op_nftoken_create_offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_nftoken_create_offer(::TW::Ripple::Proto::OperationNFTokenCreateOffer* op_nftoken_create_offer) {
  clear_operation_oneof();
  if (op_nftoken_create_offer) {
    set_has_op_nftoken_create_offer();
    operation_oneof_.op_nftoken_create_offer_ = op_nftoken_create_offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.SigningInput.op_nftoken_create_offer)
}
inline ::TW::Ripple::Proto::OperationNFTokenCreateOffer* SigningInput::_internal_mutable_op_nftoken_create_offer() {
  if (!_internal_has_op_nftoken_create_offer()) {
    clear_operation_oneof();
    set_has_op_nftoken_create_offer();
    operation_oneof_.op_nftoken_create_offer_ = CreateMaybeMessage< ::TW::Ripple::Proto::OperationNFTokenCreateOffer >(GetArenaForAllocation());
  }
  return operation_oneof_.op_nftoken_create_offer_;
}
inline ::TW::Ripple::Proto::OperationNFTokenCreateOffer* SigningInput::mutable_op_nftoken_create_offer() {
  ::TW::Ripple::Proto::OperationNFTokenCreateOffer* _msg = _internal_mutable_op_nftoken_create_offer();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.op_nftoken_create_offer)
  return _msg;
}

// .TW.Ripple.Proto.OperationNFTokenAcceptOffer op_nftoken_accept_offer = 11;
inline bool SigningInput::_internal_has_op_nftoken_accept_offer() const {
  return operation_oneof_case() == kOpNftokenAcceptOffer;
}
inline bool SigningInput::has_op_nftoken_accept_offer() const {
  return _internal_has_op_nftoken_accept_offer();
}
inline void SigningInput::set_has_op_nftoken_accept_offer() {
  _oneof_case_[0] = kOpNftokenAcceptOffer;
}
inline void SigningInput::clear_op_nftoken_accept_offer() {
  if (_internal_has_op_nftoken_accept_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_nftoken_accept_offer_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* SigningInput::release_op_nftoken_accept_offer() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.op_nftoken_accept_offer)
  if (_internal_has_op_nftoken_accept_offer()) {
    clear_has_operation_oneof();
      ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* temp = operation_oneof_.op_nftoken_accept_offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_nftoken_accept_offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::OperationNFTokenAcceptOffer& SigningInput::_internal_op_nftoken_accept_offer() const {
  return _internal_has_op_nftoken_accept_offer()
      ? *operation_oneof_.op_nftoken_accept_offer_
      : reinterpret_cast< ::TW::Ripple::Proto::OperationNFTokenAcceptOffer&>(::TW::Ripple::Proto::_OperationNFTokenAcceptOffer_default_instance_);
}
inline const ::TW::Ripple::Proto::OperationNFTokenAcceptOffer& SigningInput::op_nftoken_accept_offer() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.op_nftoken_accept_offer)
  return _internal_op_nftoken_accept_offer();
}
inline ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* SigningInput::unsafe_arena_release_op_nftoken_accept_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.SigningInput.op_nftoken_accept_offer)
  if (_internal_has_op_nftoken_accept_offer()) {
    clear_has_operation_oneof();
    ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* temp = operation_oneof_.op_nftoken_accept_offer_;
    operation_oneof_.op_nftoken_accept_offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_nftoken_accept_offer(::TW::Ripple::Proto::OperationNFTokenAcceptOffer* op_nftoken_accept_offer) {
  clear_operation_oneof();
  if (op_nftoken_accept_offer) {
    set_has_op_nftoken_accept_offer();
    operation_oneof_.op_nftoken_accept_offer_ = op_nftoken_accept_offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.SigningInput.op_nftoken_accept_offer)
}
inline ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* SigningInput::_internal_mutable_op_nftoken_accept_offer() {
  if (!_internal_has_op_nftoken_accept_offer()) {
    clear_operation_oneof();
    set_has_op_nftoken_accept_offer();
    operation_oneof_.op_nftoken_accept_offer_ = CreateMaybeMessage< ::TW::Ripple::Proto::OperationNFTokenAcceptOffer >(GetArenaForAllocation());
  }
  return operation_oneof_.op_nftoken_accept_offer_;
}
inline ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* SigningInput::mutable_op_nftoken_accept_offer() {
  ::TW::Ripple::Proto::OperationNFTokenAcceptOffer* _msg = _internal_mutable_op_nftoken_accept_offer();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.op_nftoken_accept_offer)
  return _msg;
}

// .TW.Ripple.Proto.OperationNFTokenCancelOffer op_nftoken_cancel_offer = 12;
inline bool SigningInput::_internal_has_op_nftoken_cancel_offer() const {
  return operation_oneof_case() == kOpNftokenCancelOffer;
}
inline bool SigningInput::has_op_nftoken_cancel_offer() const {
  return _internal_has_op_nftoken_cancel_offer();
}
inline void SigningInput::set_has_op_nftoken_cancel_offer() {
  _oneof_case_[0] = kOpNftokenCancelOffer;
}
inline void SigningInput::clear_op_nftoken_cancel_offer() {
  if (_internal_has_op_nftoken_cancel_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_nftoken_cancel_offer_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Ripple::Proto::OperationNFTokenCancelOffer* SigningInput::release_op_nftoken_cancel_offer() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.op_nftoken_cancel_offer)
  if (_internal_has_op_nftoken_cancel_offer()) {
    clear_has_operation_oneof();
      ::TW::Ripple::Proto::OperationNFTokenCancelOffer* temp = operation_oneof_.op_nftoken_cancel_offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_nftoken_cancel_offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Ripple::Proto::OperationNFTokenCancelOffer& SigningInput::_internal_op_nftoken_cancel_offer() const {
  return _internal_has_op_nftoken_cancel_offer()
      ? *operation_oneof_.op_nftoken_cancel_offer_
      : reinterpret_cast< ::TW::Ripple::Proto::OperationNFTokenCancelOffer&>(::TW::Ripple::Proto::_OperationNFTokenCancelOffer_default_instance_);
}
inline const ::TW::Ripple::Proto::OperationNFTokenCancelOffer& SigningInput::op_nftoken_cancel_offer() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.op_nftoken_cancel_offer)
  return _internal_op_nftoken_cancel_offer();
}
inline ::TW::Ripple::Proto::OperationNFTokenCancelOffer* SigningInput::unsafe_arena_release_op_nftoken_cancel_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Ripple.Proto.SigningInput.op_nftoken_cancel_offer)
  if (_internal_has_op_nftoken_cancel_offer()) {
    clear_has_operation_oneof();
    ::TW::Ripple::Proto::OperationNFTokenCancelOffer* temp = operation_oneof_.op_nftoken_cancel_offer_;
    operation_oneof_.op_nftoken_cancel_offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_nftoken_cancel_offer(::TW::Ripple::Proto::OperationNFTokenCancelOffer* op_nftoken_cancel_offer) {
  clear_operation_oneof();
  if (op_nftoken_cancel_offer) {
    set_has_op_nftoken_cancel_offer();
    operation_oneof_.op_nftoken_cancel_offer_ = op_nftoken_cancel_offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Ripple.Proto.SigningInput.op_nftoken_cancel_offer)
}
inline ::TW::Ripple::Proto::OperationNFTokenCancelOffer* SigningInput::_internal_mutable_op_nftoken_cancel_offer() {
  if (!_internal_has_op_nftoken_cancel_offer()) {
    clear_operation_oneof();
    set_has_op_nftoken_cancel_offer();
    operation_oneof_.op_nftoken_cancel_offer_ = CreateMaybeMessage< ::TW::Ripple::Proto::OperationNFTokenCancelOffer >(GetArenaForAllocation());
  }
  return operation_oneof_.op_nftoken_cancel_offer_;
}
inline ::TW::Ripple::Proto::OperationNFTokenCancelOffer* SigningInput::mutable_op_nftoken_cancel_offer() {
  ::TW::Ripple::Proto::OperationNFTokenCancelOffer* _msg = _internal_mutable_op_nftoken_cancel_offer();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.op_nftoken_cancel_offer)
  return _msg;
}

// bytes public_key = 15;
inline void SigningInput::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& SigningInput::public_key() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningInput.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningInput.public_key)
}
inline std::string* SigningInput::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningInput.public_key)
  return _s;
}
inline const std::string& SigningInput::_internal_public_key() const {
  return public_key_.Get();
}
inline void SigningInput::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_public_key() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningInput.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.SigningInput.public_key)
}

inline bool SigningInput::has_operation_oneof() const {
  return operation_oneof_case() != OPERATION_ONEOF_NOT_SET;
}
inline void SigningInput::clear_has_operation_oneof() {
  _oneof_case_[0] = OPERATION_ONEOF_NOT_SET;
}
inline SigningInput::OperationOneofCase SigningInput::operation_oneof_case() const {
  return SigningInput::OperationOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SigningOutput

// bytes encoded = 1;
inline void SigningOutput::clear_encoded() {
  encoded_.ClearToEmpty();
}
inline const std::string& SigningOutput::encoded() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningOutput.encoded)
  return _internal_encoded();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_encoded(ArgT0&& arg0, ArgT... args) {
 
 encoded_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningOutput.encoded)
}
inline std::string* SigningOutput::mutable_encoded() {
  std::string* _s = _internal_mutable_encoded();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningOutput.encoded)
  return _s;
}
inline const std::string& SigningOutput::_internal_encoded() const {
  return encoded_.Get();
}
inline void SigningOutput::_internal_set_encoded(const std::string& value) {
  
  encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_encoded() {
  
  return encoded_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_encoded() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningOutput.encoded)
  return encoded_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_encoded(std::string* encoded) {
  if (encoded != nullptr) {
    
  } else {
    
  }
  encoded_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoded_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.SigningOutput.encoded)
}

// .TW.Common.Proto.SigningError error = 2;
inline void SigningOutput::clear_error() {
  error_ = 0;
}
inline ::TW::Common::Proto::SigningError SigningOutput::_internal_error() const {
  return static_cast< ::TW::Common::Proto::SigningError >(error_);
}
inline ::TW::Common::Proto::SigningError SigningOutput::error() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningOutput.error)
  return _internal_error();
}
inline void SigningOutput::_internal_set_error(::TW::Common::Proto::SigningError value) {
  
  error_ = value;
}
inline void SigningOutput::set_error(::TW::Common::Proto::SigningError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningOutput.error)
}

// string error_message = 3;
inline void SigningOutput::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& SigningOutput::error_message() const {
  // @@protoc_insertion_point(field_get:TW.Ripple.Proto.SigningOutput.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Ripple.Proto.SigningOutput.error_message)
}
inline std::string* SigningOutput::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:TW.Ripple.Proto.SigningOutput.error_message)
  return _s;
}
inline const std::string& SigningOutput::_internal_error_message() const {
  return error_message_.Get();
}
inline void SigningOutput::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_error_message() {
  // @@protoc_insertion_point(field_release:TW.Ripple.Proto.SigningOutput.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Ripple.Proto.SigningOutput.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Ripple
}  // namespace TW

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Ripple_2eproto
