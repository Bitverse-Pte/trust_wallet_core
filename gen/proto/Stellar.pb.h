// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Stellar.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Stellar_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Stellar_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Stellar_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Stellar_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Stellar_2eproto;
namespace TW {
namespace Stellar {
namespace Proto {
class Asset;
struct AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class Claimant;
struct ClaimantDefaultTypeInternal;
extern ClaimantDefaultTypeInternal _Claimant_default_instance_;
class MemoHash;
struct MemoHashDefaultTypeInternal;
extern MemoHashDefaultTypeInternal _MemoHash_default_instance_;
class MemoId;
struct MemoIdDefaultTypeInternal;
extern MemoIdDefaultTypeInternal _MemoId_default_instance_;
class MemoText;
struct MemoTextDefaultTypeInternal;
extern MemoTextDefaultTypeInternal _MemoText_default_instance_;
class MemoVoid;
struct MemoVoidDefaultTypeInternal;
extern MemoVoidDefaultTypeInternal _MemoVoid_default_instance_;
class OperationChangeTrust;
struct OperationChangeTrustDefaultTypeInternal;
extern OperationChangeTrustDefaultTypeInternal _OperationChangeTrust_default_instance_;
class OperationClaimClaimableBalance;
struct OperationClaimClaimableBalanceDefaultTypeInternal;
extern OperationClaimClaimableBalanceDefaultTypeInternal _OperationClaimClaimableBalance_default_instance_;
class OperationCreateAccount;
struct OperationCreateAccountDefaultTypeInternal;
extern OperationCreateAccountDefaultTypeInternal _OperationCreateAccount_default_instance_;
class OperationCreateClaimableBalance;
struct OperationCreateClaimableBalanceDefaultTypeInternal;
extern OperationCreateClaimableBalanceDefaultTypeInternal _OperationCreateClaimableBalance_default_instance_;
class OperationPayment;
struct OperationPaymentDefaultTypeInternal;
extern OperationPaymentDefaultTypeInternal _OperationPayment_default_instance_;
class SigningInput;
struct SigningInputDefaultTypeInternal;
extern SigningInputDefaultTypeInternal _SigningInput_default_instance_;
class SigningOutput;
struct SigningOutputDefaultTypeInternal;
extern SigningOutputDefaultTypeInternal _SigningOutput_default_instance_;
}  // namespace Proto
}  // namespace Stellar
}  // namespace TW
PROTOBUF_NAMESPACE_OPEN
template<> ::TW::Stellar::Proto::Asset* Arena::CreateMaybeMessage<::TW::Stellar::Proto::Asset>(Arena*);
template<> ::TW::Stellar::Proto::Claimant* Arena::CreateMaybeMessage<::TW::Stellar::Proto::Claimant>(Arena*);
template<> ::TW::Stellar::Proto::MemoHash* Arena::CreateMaybeMessage<::TW::Stellar::Proto::MemoHash>(Arena*);
template<> ::TW::Stellar::Proto::MemoId* Arena::CreateMaybeMessage<::TW::Stellar::Proto::MemoId>(Arena*);
template<> ::TW::Stellar::Proto::MemoText* Arena::CreateMaybeMessage<::TW::Stellar::Proto::MemoText>(Arena*);
template<> ::TW::Stellar::Proto::MemoVoid* Arena::CreateMaybeMessage<::TW::Stellar::Proto::MemoVoid>(Arena*);
template<> ::TW::Stellar::Proto::OperationChangeTrust* Arena::CreateMaybeMessage<::TW::Stellar::Proto::OperationChangeTrust>(Arena*);
template<> ::TW::Stellar::Proto::OperationClaimClaimableBalance* Arena::CreateMaybeMessage<::TW::Stellar::Proto::OperationClaimClaimableBalance>(Arena*);
template<> ::TW::Stellar::Proto::OperationCreateAccount* Arena::CreateMaybeMessage<::TW::Stellar::Proto::OperationCreateAccount>(Arena*);
template<> ::TW::Stellar::Proto::OperationCreateClaimableBalance* Arena::CreateMaybeMessage<::TW::Stellar::Proto::OperationCreateClaimableBalance>(Arena*);
template<> ::TW::Stellar::Proto::OperationPayment* Arena::CreateMaybeMessage<::TW::Stellar::Proto::OperationPayment>(Arena*);
template<> ::TW::Stellar::Proto::SigningInput* Arena::CreateMaybeMessage<::TW::Stellar::Proto::SigningInput>(Arena*);
template<> ::TW::Stellar::Proto::SigningOutput* Arena::CreateMaybeMessage<::TW::Stellar::Proto::SigningOutput>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TW {
namespace Stellar {
namespace Proto {

enum ClaimPredicate : int {
  Predicate_unconditional = 0,
  ClaimPredicate_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClaimPredicate_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClaimPredicate_IsValid(int value);
constexpr ClaimPredicate ClaimPredicate_MIN = Predicate_unconditional;
constexpr ClaimPredicate ClaimPredicate_MAX = Predicate_unconditional;
constexpr int ClaimPredicate_ARRAYSIZE = ClaimPredicate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClaimPredicate_descriptor();
template<typename T>
inline const std::string& ClaimPredicate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClaimPredicate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClaimPredicate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClaimPredicate_descriptor(), enum_t_value);
}
inline bool ClaimPredicate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClaimPredicate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClaimPredicate>(
    ClaimPredicate_descriptor(), name, value);
}
// ===================================================================

class Asset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.Asset) */ {
 public:
  inline Asset() : Asset(nullptr) {}
  ~Asset() override;
  explicit constexpr Asset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Asset(const Asset& from);
  Asset(Asset&& from) noexcept
    : Asset() {
    *this = ::std::move(from);
  }

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset& operator=(Asset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Asset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Asset& a, Asset& b) {
    a.Swap(&b);
  }
  inline void Swap(Asset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Asset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Asset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Asset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Asset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Asset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.Asset";
  }
  protected:
  explicit Asset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssuerFieldNumber = 1,
    kAlphanum4FieldNumber = 2,
  };
  // string issuer = 1;
  void clear_issuer();
  const std::string& issuer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* issuer);
  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(const std::string& value);
  std::string* _internal_mutable_issuer();
  public:

  // string alphanum4 = 2;
  void clear_alphanum4();
  const std::string& alphanum4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alphanum4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alphanum4();
  PROTOBUF_NODISCARD std::string* release_alphanum4();
  void set_allocated_alphanum4(std::string* alphanum4);
  private:
  const std::string& _internal_alphanum4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alphanum4(const std::string& value);
  std::string* _internal_mutable_alphanum4();
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.Asset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alphanum4_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class OperationCreateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.OperationCreateAccount) */ {
 public:
  inline OperationCreateAccount() : OperationCreateAccount(nullptr) {}
  ~OperationCreateAccount() override;
  explicit constexpr OperationCreateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationCreateAccount(const OperationCreateAccount& from);
  OperationCreateAccount(OperationCreateAccount&& from) noexcept
    : OperationCreateAccount() {
    *this = ::std::move(from);
  }

  inline OperationCreateAccount& operator=(const OperationCreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationCreateAccount& operator=(OperationCreateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationCreateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationCreateAccount* internal_default_instance() {
    return reinterpret_cast<const OperationCreateAccount*>(
               &_OperationCreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OperationCreateAccount& a, OperationCreateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationCreateAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationCreateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationCreateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationCreateAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationCreateAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationCreateAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationCreateAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.OperationCreateAccount";
  }
  protected:
  explicit OperationCreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string destination = 1;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.OperationCreateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  int64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class OperationPayment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.OperationPayment) */ {
 public:
  inline OperationPayment() : OperationPayment(nullptr) {}
  ~OperationPayment() override;
  explicit constexpr OperationPayment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationPayment(const OperationPayment& from);
  OperationPayment(OperationPayment&& from) noexcept
    : OperationPayment() {
    *this = ::std::move(from);
  }

  inline OperationPayment& operator=(const OperationPayment& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationPayment& operator=(OperationPayment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationPayment& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationPayment* internal_default_instance() {
    return reinterpret_cast<const OperationPayment*>(
               &_OperationPayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OperationPayment& a, OperationPayment& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationPayment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationPayment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationPayment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationPayment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationPayment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationPayment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationPayment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.OperationPayment";
  }
  protected:
  explicit OperationPayment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kAssetFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string destination = 1;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // .TW.Stellar.Proto.Asset asset = 2;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::TW::Stellar::Proto::Asset& asset() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::Asset* release_asset();
  ::TW::Stellar::Proto::Asset* mutable_asset();
  void set_allocated_asset(::TW::Stellar::Proto::Asset* asset);
  private:
  const ::TW::Stellar::Proto::Asset& _internal_asset() const;
  ::TW::Stellar::Proto::Asset* _internal_mutable_asset();
  public:
  void unsafe_arena_set_allocated_asset(
      ::TW::Stellar::Proto::Asset* asset);
  ::TW::Stellar::Proto::Asset* unsafe_arena_release_asset();

  // int64 amount = 3;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.OperationPayment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  ::TW::Stellar::Proto::Asset* asset_;
  int64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class OperationChangeTrust final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.OperationChangeTrust) */ {
 public:
  inline OperationChangeTrust() : OperationChangeTrust(nullptr) {}
  ~OperationChangeTrust() override;
  explicit constexpr OperationChangeTrust(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationChangeTrust(const OperationChangeTrust& from);
  OperationChangeTrust(OperationChangeTrust&& from) noexcept
    : OperationChangeTrust() {
    *this = ::std::move(from);
  }

  inline OperationChangeTrust& operator=(const OperationChangeTrust& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationChangeTrust& operator=(OperationChangeTrust&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationChangeTrust& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationChangeTrust* internal_default_instance() {
    return reinterpret_cast<const OperationChangeTrust*>(
               &_OperationChangeTrust_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OperationChangeTrust& a, OperationChangeTrust& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationChangeTrust* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationChangeTrust* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationChangeTrust* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationChangeTrust>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationChangeTrust& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationChangeTrust& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationChangeTrust* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.OperationChangeTrust";
  }
  protected:
  explicit OperationChangeTrust(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetFieldNumber = 1,
    kValidBeforeFieldNumber = 2,
  };
  // .TW.Stellar.Proto.Asset asset = 1;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::TW::Stellar::Proto::Asset& asset() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::Asset* release_asset();
  ::TW::Stellar::Proto::Asset* mutable_asset();
  void set_allocated_asset(::TW::Stellar::Proto::Asset* asset);
  private:
  const ::TW::Stellar::Proto::Asset& _internal_asset() const;
  ::TW::Stellar::Proto::Asset* _internal_mutable_asset();
  public:
  void unsafe_arena_set_allocated_asset(
      ::TW::Stellar::Proto::Asset* asset);
  ::TW::Stellar::Proto::Asset* unsafe_arena_release_asset();

  // int64 valid_before = 2;
  void clear_valid_before();
  int64_t valid_before() const;
  void set_valid_before(int64_t value);
  private:
  int64_t _internal_valid_before() const;
  void _internal_set_valid_before(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.OperationChangeTrust)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TW::Stellar::Proto::Asset* asset_;
  int64_t valid_before_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class Claimant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.Claimant) */ {
 public:
  inline Claimant() : Claimant(nullptr) {}
  ~Claimant() override;
  explicit constexpr Claimant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Claimant(const Claimant& from);
  Claimant(Claimant&& from) noexcept
    : Claimant() {
    *this = ::std::move(from);
  }

  inline Claimant& operator=(const Claimant& from) {
    CopyFrom(from);
    return *this;
  }
  inline Claimant& operator=(Claimant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Claimant& default_instance() {
    return *internal_default_instance();
  }
  static inline const Claimant* internal_default_instance() {
    return reinterpret_cast<const Claimant*>(
               &_Claimant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Claimant& a, Claimant& b) {
    a.Swap(&b);
  }
  inline void Swap(Claimant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Claimant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Claimant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Claimant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Claimant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Claimant& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Claimant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.Claimant";
  }
  protected:
  explicit Claimant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kPredicateFieldNumber = 2,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // .TW.Stellar.Proto.ClaimPredicate predicate = 2;
  void clear_predicate();
  ::TW::Stellar::Proto::ClaimPredicate predicate() const;
  void set_predicate(::TW::Stellar::Proto::ClaimPredicate value);
  private:
  ::TW::Stellar::Proto::ClaimPredicate _internal_predicate() const;
  void _internal_set_predicate(::TW::Stellar::Proto::ClaimPredicate value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.Claimant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int predicate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class OperationCreateClaimableBalance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.OperationCreateClaimableBalance) */ {
 public:
  inline OperationCreateClaimableBalance() : OperationCreateClaimableBalance(nullptr) {}
  ~OperationCreateClaimableBalance() override;
  explicit constexpr OperationCreateClaimableBalance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationCreateClaimableBalance(const OperationCreateClaimableBalance& from);
  OperationCreateClaimableBalance(OperationCreateClaimableBalance&& from) noexcept
    : OperationCreateClaimableBalance() {
    *this = ::std::move(from);
  }

  inline OperationCreateClaimableBalance& operator=(const OperationCreateClaimableBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationCreateClaimableBalance& operator=(OperationCreateClaimableBalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationCreateClaimableBalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationCreateClaimableBalance* internal_default_instance() {
    return reinterpret_cast<const OperationCreateClaimableBalance*>(
               &_OperationCreateClaimableBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OperationCreateClaimableBalance& a, OperationCreateClaimableBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationCreateClaimableBalance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationCreateClaimableBalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationCreateClaimableBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationCreateClaimableBalance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationCreateClaimableBalance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationCreateClaimableBalance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationCreateClaimableBalance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.OperationCreateClaimableBalance";
  }
  protected:
  explicit OperationCreateClaimableBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimantsFieldNumber = 3,
    kAssetFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // repeated .TW.Stellar.Proto.Claimant claimants = 3;
  int claimants_size() const;
  private:
  int _internal_claimants_size() const;
  public:
  void clear_claimants();
  ::TW::Stellar::Proto::Claimant* mutable_claimants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Stellar::Proto::Claimant >*
      mutable_claimants();
  private:
  const ::TW::Stellar::Proto::Claimant& _internal_claimants(int index) const;
  ::TW::Stellar::Proto::Claimant* _internal_add_claimants();
  public:
  const ::TW::Stellar::Proto::Claimant& claimants(int index) const;
  ::TW::Stellar::Proto::Claimant* add_claimants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Stellar::Proto::Claimant >&
      claimants() const;

  // .TW.Stellar.Proto.Asset asset = 1;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::TW::Stellar::Proto::Asset& asset() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::Asset* release_asset();
  ::TW::Stellar::Proto::Asset* mutable_asset();
  void set_allocated_asset(::TW::Stellar::Proto::Asset* asset);
  private:
  const ::TW::Stellar::Proto::Asset& _internal_asset() const;
  ::TW::Stellar::Proto::Asset* _internal_mutable_asset();
  public:
  void unsafe_arena_set_allocated_asset(
      ::TW::Stellar::Proto::Asset* asset);
  ::TW::Stellar::Proto::Asset* unsafe_arena_release_asset();

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.OperationCreateClaimableBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Stellar::Proto::Claimant > claimants_;
  ::TW::Stellar::Proto::Asset* asset_;
  int64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class OperationClaimClaimableBalance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.OperationClaimClaimableBalance) */ {
 public:
  inline OperationClaimClaimableBalance() : OperationClaimClaimableBalance(nullptr) {}
  ~OperationClaimClaimableBalance() override;
  explicit constexpr OperationClaimClaimableBalance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationClaimClaimableBalance(const OperationClaimClaimableBalance& from);
  OperationClaimClaimableBalance(OperationClaimClaimableBalance&& from) noexcept
    : OperationClaimClaimableBalance() {
    *this = ::std::move(from);
  }

  inline OperationClaimClaimableBalance& operator=(const OperationClaimClaimableBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationClaimClaimableBalance& operator=(OperationClaimClaimableBalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationClaimClaimableBalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationClaimClaimableBalance* internal_default_instance() {
    return reinterpret_cast<const OperationClaimClaimableBalance*>(
               &_OperationClaimClaimableBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OperationClaimClaimableBalance& a, OperationClaimClaimableBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationClaimClaimableBalance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationClaimClaimableBalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationClaimClaimableBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationClaimClaimableBalance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationClaimClaimableBalance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationClaimClaimableBalance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationClaimClaimableBalance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.OperationClaimClaimableBalance";
  }
  protected:
  explicit OperationClaimClaimableBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceIdFieldNumber = 1,
  };
  // bytes balance_id = 1;
  void clear_balance_id();
  const std::string& balance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance_id();
  PROTOBUF_NODISCARD std::string* release_balance_id();
  void set_allocated_balance_id(std::string* balance_id);
  private:
  const std::string& _internal_balance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance_id(const std::string& value);
  std::string* _internal_mutable_balance_id();
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.OperationClaimClaimableBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class MemoVoid final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.MemoVoid) */ {
 public:
  inline MemoVoid() : MemoVoid(nullptr) {}
  explicit constexpr MemoVoid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoVoid(const MemoVoid& from);
  MemoVoid(MemoVoid&& from) noexcept
    : MemoVoid() {
    *this = ::std::move(from);
  }

  inline MemoVoid& operator=(const MemoVoid& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoVoid& operator=(MemoVoid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoVoid& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoVoid* internal_default_instance() {
    return reinterpret_cast<const MemoVoid*>(
               &_MemoVoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MemoVoid& a, MemoVoid& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoVoid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoVoid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoVoid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoVoid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MemoVoid& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MemoVoid& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.MemoVoid";
  }
  protected:
  explicit MemoVoid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.MemoVoid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class MemoText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.MemoText) */ {
 public:
  inline MemoText() : MemoText(nullptr) {}
  ~MemoText() override;
  explicit constexpr MemoText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoText(const MemoText& from);
  MemoText(MemoText&& from) noexcept
    : MemoText() {
    *this = ::std::move(from);
  }

  inline MemoText& operator=(const MemoText& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoText& operator=(MemoText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoText& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoText* internal_default_instance() {
    return reinterpret_cast<const MemoText*>(
               &_MemoText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MemoText& a, MemoText& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoText* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemoText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemoText& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.MemoText";
  }
  protected:
  explicit MemoText(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.MemoText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class MemoId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.MemoId) */ {
 public:
  inline MemoId() : MemoId(nullptr) {}
  ~MemoId() override;
  explicit constexpr MemoId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoId(const MemoId& from);
  MemoId(MemoId&& from) noexcept
    : MemoId() {
    *this = ::std::move(from);
  }

  inline MemoId& operator=(const MemoId& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoId& operator=(MemoId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoId& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoId* internal_default_instance() {
    return reinterpret_cast<const MemoId*>(
               &_MemoId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MemoId& a, MemoId& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemoId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemoId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.MemoId";
  }
  protected:
  explicit MemoId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.MemoId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class MemoHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.MemoHash) */ {
 public:
  inline MemoHash() : MemoHash(nullptr) {}
  ~MemoHash() override;
  explicit constexpr MemoHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoHash(const MemoHash& from);
  MemoHash(MemoHash&& from) noexcept
    : MemoHash() {
    *this = ::std::move(from);
  }

  inline MemoHash& operator=(const MemoHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoHash& operator=(MemoHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoHash* internal_default_instance() {
    return reinterpret_cast<const MemoHash*>(
               &_MemoHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MemoHash& a, MemoHash& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoHash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemoHash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemoHash& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.MemoHash";
  }
  protected:
  explicit MemoHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.MemoHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class SigningInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.SigningInput) */ {
 public:
  inline SigningInput() : SigningInput(nullptr) {}
  ~SigningInput() override;
  explicit constexpr SigningInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningInput(const SigningInput& from);
  SigningInput(SigningInput&& from) noexcept
    : SigningInput() {
    *this = ::std::move(from);
  }

  inline SigningInput& operator=(const SigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningInput& operator=(SigningInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningInput& default_instance() {
    return *internal_default_instance();
  }
  enum OperationOneofCase {
    kOpCreateAccount = 6,
    kOpPayment = 7,
    kOpChangeTrust = 8,
    kOpCreateClaimableBalance = 14,
    kOpClaimClaimableBalance = 15,
    OPERATION_ONEOF_NOT_SET = 0,
  };

  enum MemoTypeOneofCase {
    kMemoVoid = 9,
    kMemoText = 10,
    kMemoId = 11,
    kMemoHash = 12,
    kMemoReturnHash = 13,
    MEMO_TYPE_ONEOF_NOT_SET = 0,
  };

  static inline const SigningInput* internal_default_instance() {
    return reinterpret_cast<const SigningInput*>(
               &_SigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SigningInput& a, SigningInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.SigningInput";
  }
  protected:
  explicit SigningInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 3,
    kPrivateKeyFieldNumber = 4,
    kPassphraseFieldNumber = 5,
    kSequenceFieldNumber = 2,
    kFeeFieldNumber = 1,
    kTimeBoundsFieldNumber = 16,
    kOpCreateAccountFieldNumber = 6,
    kOpPaymentFieldNumber = 7,
    kOpChangeTrustFieldNumber = 8,
    kOpCreateClaimableBalanceFieldNumber = 14,
    kOpClaimClaimableBalanceFieldNumber = 15,
    kMemoVoidFieldNumber = 9,
    kMemoTextFieldNumber = 10,
    kMemoIdFieldNumber = 11,
    kMemoHashFieldNumber = 12,
    kMemoReturnHashFieldNumber = 13,
  };
  // string account = 3;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes private_key = 4;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // string passphrase = 5;
  void clear_passphrase();
  const std::string& passphrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passphrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passphrase();
  PROTOBUF_NODISCARD std::string* release_passphrase();
  void set_allocated_passphrase(std::string* passphrase);
  private:
  const std::string& _internal_passphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passphrase(const std::string& value);
  std::string* _internal_mutable_passphrase();
  public:

  // int64 sequence = 2;
  void clear_sequence();
  int64_t sequence() const;
  void set_sequence(int64_t value);
  private:
  int64_t _internal_sequence() const;
  void _internal_set_sequence(int64_t value);
  public:

  // int32 fee = 1;
  void clear_fee();
  int32_t fee() const;
  void set_fee(int32_t value);
  private:
  int32_t _internal_fee() const;
  void _internal_set_fee(int32_t value);
  public:

  // int64 time_bounds = 16;
  void clear_time_bounds();
  int64_t time_bounds() const;
  void set_time_bounds(int64_t value);
  private:
  int64_t _internal_time_bounds() const;
  void _internal_set_time_bounds(int64_t value);
  public:

  // .TW.Stellar.Proto.OperationCreateAccount op_create_account = 6;
  bool has_op_create_account() const;
  private:
  bool _internal_has_op_create_account() const;
  public:
  void clear_op_create_account();
  const ::TW::Stellar::Proto::OperationCreateAccount& op_create_account() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::OperationCreateAccount* release_op_create_account();
  ::TW::Stellar::Proto::OperationCreateAccount* mutable_op_create_account();
  void set_allocated_op_create_account(::TW::Stellar::Proto::OperationCreateAccount* op_create_account);
  private:
  const ::TW::Stellar::Proto::OperationCreateAccount& _internal_op_create_account() const;
  ::TW::Stellar::Proto::OperationCreateAccount* _internal_mutable_op_create_account();
  public:
  void unsafe_arena_set_allocated_op_create_account(
      ::TW::Stellar::Proto::OperationCreateAccount* op_create_account);
  ::TW::Stellar::Proto::OperationCreateAccount* unsafe_arena_release_op_create_account();

  // .TW.Stellar.Proto.OperationPayment op_payment = 7;
  bool has_op_payment() const;
  private:
  bool _internal_has_op_payment() const;
  public:
  void clear_op_payment();
  const ::TW::Stellar::Proto::OperationPayment& op_payment() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::OperationPayment* release_op_payment();
  ::TW::Stellar::Proto::OperationPayment* mutable_op_payment();
  void set_allocated_op_payment(::TW::Stellar::Proto::OperationPayment* op_payment);
  private:
  const ::TW::Stellar::Proto::OperationPayment& _internal_op_payment() const;
  ::TW::Stellar::Proto::OperationPayment* _internal_mutable_op_payment();
  public:
  void unsafe_arena_set_allocated_op_payment(
      ::TW::Stellar::Proto::OperationPayment* op_payment);
  ::TW::Stellar::Proto::OperationPayment* unsafe_arena_release_op_payment();

  // .TW.Stellar.Proto.OperationChangeTrust op_change_trust = 8;
  bool has_op_change_trust() const;
  private:
  bool _internal_has_op_change_trust() const;
  public:
  void clear_op_change_trust();
  const ::TW::Stellar::Proto::OperationChangeTrust& op_change_trust() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::OperationChangeTrust* release_op_change_trust();
  ::TW::Stellar::Proto::OperationChangeTrust* mutable_op_change_trust();
  void set_allocated_op_change_trust(::TW::Stellar::Proto::OperationChangeTrust* op_change_trust);
  private:
  const ::TW::Stellar::Proto::OperationChangeTrust& _internal_op_change_trust() const;
  ::TW::Stellar::Proto::OperationChangeTrust* _internal_mutable_op_change_trust();
  public:
  void unsafe_arena_set_allocated_op_change_trust(
      ::TW::Stellar::Proto::OperationChangeTrust* op_change_trust);
  ::TW::Stellar::Proto::OperationChangeTrust* unsafe_arena_release_op_change_trust();

  // .TW.Stellar.Proto.OperationCreateClaimableBalance op_create_claimable_balance = 14;
  bool has_op_create_claimable_balance() const;
  private:
  bool _internal_has_op_create_claimable_balance() const;
  public:
  void clear_op_create_claimable_balance();
  const ::TW::Stellar::Proto::OperationCreateClaimableBalance& op_create_claimable_balance() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::OperationCreateClaimableBalance* release_op_create_claimable_balance();
  ::TW::Stellar::Proto::OperationCreateClaimableBalance* mutable_op_create_claimable_balance();
  void set_allocated_op_create_claimable_balance(::TW::Stellar::Proto::OperationCreateClaimableBalance* op_create_claimable_balance);
  private:
  const ::TW::Stellar::Proto::OperationCreateClaimableBalance& _internal_op_create_claimable_balance() const;
  ::TW::Stellar::Proto::OperationCreateClaimableBalance* _internal_mutable_op_create_claimable_balance();
  public:
  void unsafe_arena_set_allocated_op_create_claimable_balance(
      ::TW::Stellar::Proto::OperationCreateClaimableBalance* op_create_claimable_balance);
  ::TW::Stellar::Proto::OperationCreateClaimableBalance* unsafe_arena_release_op_create_claimable_balance();

  // .TW.Stellar.Proto.OperationClaimClaimableBalance op_claim_claimable_balance = 15;
  bool has_op_claim_claimable_balance() const;
  private:
  bool _internal_has_op_claim_claimable_balance() const;
  public:
  void clear_op_claim_claimable_balance();
  const ::TW::Stellar::Proto::OperationClaimClaimableBalance& op_claim_claimable_balance() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::OperationClaimClaimableBalance* release_op_claim_claimable_balance();
  ::TW::Stellar::Proto::OperationClaimClaimableBalance* mutable_op_claim_claimable_balance();
  void set_allocated_op_claim_claimable_balance(::TW::Stellar::Proto::OperationClaimClaimableBalance* op_claim_claimable_balance);
  private:
  const ::TW::Stellar::Proto::OperationClaimClaimableBalance& _internal_op_claim_claimable_balance() const;
  ::TW::Stellar::Proto::OperationClaimClaimableBalance* _internal_mutable_op_claim_claimable_balance();
  public:
  void unsafe_arena_set_allocated_op_claim_claimable_balance(
      ::TW::Stellar::Proto::OperationClaimClaimableBalance* op_claim_claimable_balance);
  ::TW::Stellar::Proto::OperationClaimClaimableBalance* unsafe_arena_release_op_claim_claimable_balance();

  // .TW.Stellar.Proto.MemoVoid memo_void = 9;
  bool has_memo_void() const;
  private:
  bool _internal_has_memo_void() const;
  public:
  void clear_memo_void();
  const ::TW::Stellar::Proto::MemoVoid& memo_void() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::MemoVoid* release_memo_void();
  ::TW::Stellar::Proto::MemoVoid* mutable_memo_void();
  void set_allocated_memo_void(::TW::Stellar::Proto::MemoVoid* memo_void);
  private:
  const ::TW::Stellar::Proto::MemoVoid& _internal_memo_void() const;
  ::TW::Stellar::Proto::MemoVoid* _internal_mutable_memo_void();
  public:
  void unsafe_arena_set_allocated_memo_void(
      ::TW::Stellar::Proto::MemoVoid* memo_void);
  ::TW::Stellar::Proto::MemoVoid* unsafe_arena_release_memo_void();

  // .TW.Stellar.Proto.MemoText memo_text = 10;
  bool has_memo_text() const;
  private:
  bool _internal_has_memo_text() const;
  public:
  void clear_memo_text();
  const ::TW::Stellar::Proto::MemoText& memo_text() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::MemoText* release_memo_text();
  ::TW::Stellar::Proto::MemoText* mutable_memo_text();
  void set_allocated_memo_text(::TW::Stellar::Proto::MemoText* memo_text);
  private:
  const ::TW::Stellar::Proto::MemoText& _internal_memo_text() const;
  ::TW::Stellar::Proto::MemoText* _internal_mutable_memo_text();
  public:
  void unsafe_arena_set_allocated_memo_text(
      ::TW::Stellar::Proto::MemoText* memo_text);
  ::TW::Stellar::Proto::MemoText* unsafe_arena_release_memo_text();

  // .TW.Stellar.Proto.MemoId memo_id = 11;
  bool has_memo_id() const;
  private:
  bool _internal_has_memo_id() const;
  public:
  void clear_memo_id();
  const ::TW::Stellar::Proto::MemoId& memo_id() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::MemoId* release_memo_id();
  ::TW::Stellar::Proto::MemoId* mutable_memo_id();
  void set_allocated_memo_id(::TW::Stellar::Proto::MemoId* memo_id);
  private:
  const ::TW::Stellar::Proto::MemoId& _internal_memo_id() const;
  ::TW::Stellar::Proto::MemoId* _internal_mutable_memo_id();
  public:
  void unsafe_arena_set_allocated_memo_id(
      ::TW::Stellar::Proto::MemoId* memo_id);
  ::TW::Stellar::Proto::MemoId* unsafe_arena_release_memo_id();

  // .TW.Stellar.Proto.MemoHash memo_hash = 12;
  bool has_memo_hash() const;
  private:
  bool _internal_has_memo_hash() const;
  public:
  void clear_memo_hash();
  const ::TW::Stellar::Proto::MemoHash& memo_hash() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::MemoHash* release_memo_hash();
  ::TW::Stellar::Proto::MemoHash* mutable_memo_hash();
  void set_allocated_memo_hash(::TW::Stellar::Proto::MemoHash* memo_hash);
  private:
  const ::TW::Stellar::Proto::MemoHash& _internal_memo_hash() const;
  ::TW::Stellar::Proto::MemoHash* _internal_mutable_memo_hash();
  public:
  void unsafe_arena_set_allocated_memo_hash(
      ::TW::Stellar::Proto::MemoHash* memo_hash);
  ::TW::Stellar::Proto::MemoHash* unsafe_arena_release_memo_hash();

  // .TW.Stellar.Proto.MemoHash memo_return_hash = 13;
  bool has_memo_return_hash() const;
  private:
  bool _internal_has_memo_return_hash() const;
  public:
  void clear_memo_return_hash();
  const ::TW::Stellar::Proto::MemoHash& memo_return_hash() const;
  PROTOBUF_NODISCARD ::TW::Stellar::Proto::MemoHash* release_memo_return_hash();
  ::TW::Stellar::Proto::MemoHash* mutable_memo_return_hash();
  void set_allocated_memo_return_hash(::TW::Stellar::Proto::MemoHash* memo_return_hash);
  private:
  const ::TW::Stellar::Proto::MemoHash& _internal_memo_return_hash() const;
  ::TW::Stellar::Proto::MemoHash* _internal_mutable_memo_return_hash();
  public:
  void unsafe_arena_set_allocated_memo_return_hash(
      ::TW::Stellar::Proto::MemoHash* memo_return_hash);
  ::TW::Stellar::Proto::MemoHash* unsafe_arena_release_memo_return_hash();

  void clear_operation_oneof();
  OperationOneofCase operation_oneof_case() const;
  void clear_memo_type_oneof();
  MemoTypeOneofCase memo_type_oneof_case() const;
  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.SigningInput)
 private:
  class _Internal;
  void set_has_op_create_account();
  void set_has_op_payment();
  void set_has_op_change_trust();
  void set_has_op_create_claimable_balance();
  void set_has_op_claim_claimable_balance();
  void set_has_memo_void();
  void set_has_memo_text();
  void set_has_memo_id();
  void set_has_memo_hash();
  void set_has_memo_return_hash();

  inline bool has_operation_oneof() const;
  inline void clear_has_operation_oneof();

  inline bool has_memo_type_oneof() const;
  inline void clear_has_memo_type_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passphrase_;
  int64_t sequence_;
  int32_t fee_;
  int64_t time_bounds_;
  union OperationOneofUnion {
    constexpr OperationOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Stellar::Proto::OperationCreateAccount* op_create_account_;
    ::TW::Stellar::Proto::OperationPayment* op_payment_;
    ::TW::Stellar::Proto::OperationChangeTrust* op_change_trust_;
    ::TW::Stellar::Proto::OperationCreateClaimableBalance* op_create_claimable_balance_;
    ::TW::Stellar::Proto::OperationClaimClaimableBalance* op_claim_claimable_balance_;
  } operation_oneof_;
  union MemoTypeOneofUnion {
    constexpr MemoTypeOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Stellar::Proto::MemoVoid* memo_void_;
    ::TW::Stellar::Proto::MemoText* memo_text_;
    ::TW::Stellar::Proto::MemoId* memo_id_;
    ::TW::Stellar::Proto::MemoHash* memo_hash_;
    ::TW::Stellar::Proto::MemoHash* memo_return_hash_;
  } memo_type_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_Stellar_2eproto;
};
// -------------------------------------------------------------------

class SigningOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Stellar.Proto.SigningOutput) */ {
 public:
  inline SigningOutput() : SigningOutput(nullptr) {}
  ~SigningOutput() override;
  explicit constexpr SigningOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningOutput(const SigningOutput& from);
  SigningOutput(SigningOutput&& from) noexcept
    : SigningOutput() {
    *this = ::std::move(from);
  }

  inline SigningOutput& operator=(const SigningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningOutput& operator=(SigningOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningOutput* internal_default_instance() {
    return reinterpret_cast<const SigningOutput*>(
               &_SigningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SigningOutput& a, SigningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Stellar.Proto.SigningOutput";
  }
  protected:
  explicit SigningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kErrorFieldNumber = 2,
  };
  // string signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .TW.Common.Proto.SigningError error = 2;
  void clear_error();
  ::TW::Common::Proto::SigningError error() const;
  void set_error(::TW::Common::Proto::SigningError value);
  private:
  ::TW::Common::Proto::SigningError _internal_error() const;
  void _internal_set_error(::TW::Common::Proto::SigningError value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Stellar.Proto.SigningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Stellar_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Asset

// string issuer = 1;
inline void Asset::clear_issuer() {
  issuer_.ClearToEmpty();
}
inline const std::string& Asset::issuer() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.Asset.issuer)
  return _internal_issuer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Asset::set_issuer(ArgT0&& arg0, ArgT... args) {
 
 issuer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.Asset.issuer)
}
inline std::string* Asset::mutable_issuer() {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.Asset.issuer)
  return _s;
}
inline const std::string& Asset::_internal_issuer() const {
  return issuer_.Get();
}
inline void Asset::_internal_set_issuer(const std::string& value) {
  
  issuer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Asset::_internal_mutable_issuer() {
  
  return issuer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Asset::release_issuer() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.Asset.issuer)
  return issuer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Asset::set_allocated_issuer(std::string* issuer) {
  if (issuer != nullptr) {
    
  } else {
    
  }
  issuer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), issuer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (issuer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    issuer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.Asset.issuer)
}

// string alphanum4 = 2;
inline void Asset::clear_alphanum4() {
  alphanum4_.ClearToEmpty();
}
inline const std::string& Asset::alphanum4() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.Asset.alphanum4)
  return _internal_alphanum4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Asset::set_alphanum4(ArgT0&& arg0, ArgT... args) {
 
 alphanum4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.Asset.alphanum4)
}
inline std::string* Asset::mutable_alphanum4() {
  std::string* _s = _internal_mutable_alphanum4();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.Asset.alphanum4)
  return _s;
}
inline const std::string& Asset::_internal_alphanum4() const {
  return alphanum4_.Get();
}
inline void Asset::_internal_set_alphanum4(const std::string& value) {
  
  alphanum4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Asset::_internal_mutable_alphanum4() {
  
  return alphanum4_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Asset::release_alphanum4() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.Asset.alphanum4)
  return alphanum4_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Asset::set_allocated_alphanum4(std::string* alphanum4) {
  if (alphanum4 != nullptr) {
    
  } else {
    
  }
  alphanum4_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alphanum4,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (alphanum4_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    alphanum4_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.Asset.alphanum4)
}

// -------------------------------------------------------------------

// OperationCreateAccount

// string destination = 1;
inline void OperationCreateAccount::clear_destination() {
  destination_.ClearToEmpty();
}
inline const std::string& OperationCreateAccount::destination() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationCreateAccount.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationCreateAccount::set_destination(ArgT0&& arg0, ArgT... args) {
 
 destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationCreateAccount.destination)
}
inline std::string* OperationCreateAccount::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationCreateAccount.destination)
  return _s;
}
inline const std::string& OperationCreateAccount::_internal_destination() const {
  return destination_.Get();
}
inline void OperationCreateAccount::_internal_set_destination(const std::string& value) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationCreateAccount::_internal_mutable_destination() {
  
  return destination_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationCreateAccount::release_destination() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.OperationCreateAccount.destination)
  return destination_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationCreateAccount::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.OperationCreateAccount.destination)
}

// int64 amount = 2;
inline void OperationCreateAccount::clear_amount() {
  amount_ = int64_t{0};
}
inline int64_t OperationCreateAccount::_internal_amount() const {
  return amount_;
}
inline int64_t OperationCreateAccount::amount() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationCreateAccount.amount)
  return _internal_amount();
}
inline void OperationCreateAccount::_internal_set_amount(int64_t value) {
  
  amount_ = value;
}
inline void OperationCreateAccount::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationCreateAccount.amount)
}

// -------------------------------------------------------------------

// OperationPayment

// string destination = 1;
inline void OperationPayment::clear_destination() {
  destination_.ClearToEmpty();
}
inline const std::string& OperationPayment::destination() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationPayment.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationPayment::set_destination(ArgT0&& arg0, ArgT... args) {
 
 destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationPayment.destination)
}
inline std::string* OperationPayment::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationPayment.destination)
  return _s;
}
inline const std::string& OperationPayment::_internal_destination() const {
  return destination_.Get();
}
inline void OperationPayment::_internal_set_destination(const std::string& value) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationPayment::_internal_mutable_destination() {
  
  return destination_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationPayment::release_destination() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.OperationPayment.destination)
  return destination_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationPayment::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.OperationPayment.destination)
}

// .TW.Stellar.Proto.Asset asset = 2;
inline bool OperationPayment::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool OperationPayment::has_asset() const {
  return _internal_has_asset();
}
inline void OperationPayment::clear_asset() {
  if (GetArenaForAllocation() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::TW::Stellar::Proto::Asset& OperationPayment::_internal_asset() const {
  const ::TW::Stellar::Proto::Asset* p = asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Stellar::Proto::Asset&>(
      ::TW::Stellar::Proto::_Asset_default_instance_);
}
inline const ::TW::Stellar::Proto::Asset& OperationPayment::asset() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationPayment.asset)
  return _internal_asset();
}
inline void OperationPayment::unsafe_arena_set_allocated_asset(
    ::TW::Stellar::Proto::Asset* asset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asset_);
  }
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.OperationPayment.asset)
}
inline ::TW::Stellar::Proto::Asset* OperationPayment::release_asset() {
  
  ::TW::Stellar::Proto::Asset* temp = asset_;
  asset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Stellar::Proto::Asset* OperationPayment::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.OperationPayment.asset)
  
  ::TW::Stellar::Proto::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::TW::Stellar::Proto::Asset* OperationPayment::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Stellar::Proto::Asset>(GetArenaForAllocation());
    asset_ = p;
  }
  return asset_;
}
inline ::TW::Stellar::Proto::Asset* OperationPayment::mutable_asset() {
  ::TW::Stellar::Proto::Asset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationPayment.asset)
  return _msg;
}
inline void OperationPayment::set_allocated_asset(::TW::Stellar::Proto::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Stellar::Proto::Asset>::GetOwningArena(asset);
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.OperationPayment.asset)
}

// int64 amount = 3;
inline void OperationPayment::clear_amount() {
  amount_ = int64_t{0};
}
inline int64_t OperationPayment::_internal_amount() const {
  return amount_;
}
inline int64_t OperationPayment::amount() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationPayment.amount)
  return _internal_amount();
}
inline void OperationPayment::_internal_set_amount(int64_t value) {
  
  amount_ = value;
}
inline void OperationPayment::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationPayment.amount)
}

// -------------------------------------------------------------------

// OperationChangeTrust

// .TW.Stellar.Proto.Asset asset = 1;
inline bool OperationChangeTrust::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool OperationChangeTrust::has_asset() const {
  return _internal_has_asset();
}
inline void OperationChangeTrust::clear_asset() {
  if (GetArenaForAllocation() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::TW::Stellar::Proto::Asset& OperationChangeTrust::_internal_asset() const {
  const ::TW::Stellar::Proto::Asset* p = asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Stellar::Proto::Asset&>(
      ::TW::Stellar::Proto::_Asset_default_instance_);
}
inline const ::TW::Stellar::Proto::Asset& OperationChangeTrust::asset() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationChangeTrust.asset)
  return _internal_asset();
}
inline void OperationChangeTrust::unsafe_arena_set_allocated_asset(
    ::TW::Stellar::Proto::Asset* asset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asset_);
  }
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.OperationChangeTrust.asset)
}
inline ::TW::Stellar::Proto::Asset* OperationChangeTrust::release_asset() {
  
  ::TW::Stellar::Proto::Asset* temp = asset_;
  asset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Stellar::Proto::Asset* OperationChangeTrust::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.OperationChangeTrust.asset)
  
  ::TW::Stellar::Proto::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::TW::Stellar::Proto::Asset* OperationChangeTrust::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Stellar::Proto::Asset>(GetArenaForAllocation());
    asset_ = p;
  }
  return asset_;
}
inline ::TW::Stellar::Proto::Asset* OperationChangeTrust::mutable_asset() {
  ::TW::Stellar::Proto::Asset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationChangeTrust.asset)
  return _msg;
}
inline void OperationChangeTrust::set_allocated_asset(::TW::Stellar::Proto::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Stellar::Proto::Asset>::GetOwningArena(asset);
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.OperationChangeTrust.asset)
}

// int64 valid_before = 2;
inline void OperationChangeTrust::clear_valid_before() {
  valid_before_ = int64_t{0};
}
inline int64_t OperationChangeTrust::_internal_valid_before() const {
  return valid_before_;
}
inline int64_t OperationChangeTrust::valid_before() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationChangeTrust.valid_before)
  return _internal_valid_before();
}
inline void OperationChangeTrust::_internal_set_valid_before(int64_t value) {
  
  valid_before_ = value;
}
inline void OperationChangeTrust::set_valid_before(int64_t value) {
  _internal_set_valid_before(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationChangeTrust.valid_before)
}

// -------------------------------------------------------------------

// Claimant

// string account = 1;
inline void Claimant::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& Claimant::account() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.Claimant.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Claimant::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.Claimant.account)
}
inline std::string* Claimant::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.Claimant.account)
  return _s;
}
inline const std::string& Claimant::_internal_account() const {
  return account_.Get();
}
inline void Claimant::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Claimant::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Claimant::release_account() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.Claimant.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Claimant::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.Claimant.account)
}

// .TW.Stellar.Proto.ClaimPredicate predicate = 2;
inline void Claimant::clear_predicate() {
  predicate_ = 0;
}
inline ::TW::Stellar::Proto::ClaimPredicate Claimant::_internal_predicate() const {
  return static_cast< ::TW::Stellar::Proto::ClaimPredicate >(predicate_);
}
inline ::TW::Stellar::Proto::ClaimPredicate Claimant::predicate() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.Claimant.predicate)
  return _internal_predicate();
}
inline void Claimant::_internal_set_predicate(::TW::Stellar::Proto::ClaimPredicate value) {
  
  predicate_ = value;
}
inline void Claimant::set_predicate(::TW::Stellar::Proto::ClaimPredicate value) {
  _internal_set_predicate(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.Claimant.predicate)
}

// -------------------------------------------------------------------

// OperationCreateClaimableBalance

// .TW.Stellar.Proto.Asset asset = 1;
inline bool OperationCreateClaimableBalance::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool OperationCreateClaimableBalance::has_asset() const {
  return _internal_has_asset();
}
inline void OperationCreateClaimableBalance::clear_asset() {
  if (GetArenaForAllocation() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::TW::Stellar::Proto::Asset& OperationCreateClaimableBalance::_internal_asset() const {
  const ::TW::Stellar::Proto::Asset* p = asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Stellar::Proto::Asset&>(
      ::TW::Stellar::Proto::_Asset_default_instance_);
}
inline const ::TW::Stellar::Proto::Asset& OperationCreateClaimableBalance::asset() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationCreateClaimableBalance.asset)
  return _internal_asset();
}
inline void OperationCreateClaimableBalance::unsafe_arena_set_allocated_asset(
    ::TW::Stellar::Proto::Asset* asset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asset_);
  }
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.OperationCreateClaimableBalance.asset)
}
inline ::TW::Stellar::Proto::Asset* OperationCreateClaimableBalance::release_asset() {
  
  ::TW::Stellar::Proto::Asset* temp = asset_;
  asset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Stellar::Proto::Asset* OperationCreateClaimableBalance::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.OperationCreateClaimableBalance.asset)
  
  ::TW::Stellar::Proto::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::TW::Stellar::Proto::Asset* OperationCreateClaimableBalance::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Stellar::Proto::Asset>(GetArenaForAllocation());
    asset_ = p;
  }
  return asset_;
}
inline ::TW::Stellar::Proto::Asset* OperationCreateClaimableBalance::mutable_asset() {
  ::TW::Stellar::Proto::Asset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationCreateClaimableBalance.asset)
  return _msg;
}
inline void OperationCreateClaimableBalance::set_allocated_asset(::TW::Stellar::Proto::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Stellar::Proto::Asset>::GetOwningArena(asset);
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.OperationCreateClaimableBalance.asset)
}

// int64 amount = 2;
inline void OperationCreateClaimableBalance::clear_amount() {
  amount_ = int64_t{0};
}
inline int64_t OperationCreateClaimableBalance::_internal_amount() const {
  return amount_;
}
inline int64_t OperationCreateClaimableBalance::amount() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationCreateClaimableBalance.amount)
  return _internal_amount();
}
inline void OperationCreateClaimableBalance::_internal_set_amount(int64_t value) {
  
  amount_ = value;
}
inline void OperationCreateClaimableBalance::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationCreateClaimableBalance.amount)
}

// repeated .TW.Stellar.Proto.Claimant claimants = 3;
inline int OperationCreateClaimableBalance::_internal_claimants_size() const {
  return claimants_.size();
}
inline int OperationCreateClaimableBalance::claimants_size() const {
  return _internal_claimants_size();
}
inline void OperationCreateClaimableBalance::clear_claimants() {
  claimants_.Clear();
}
inline ::TW::Stellar::Proto::Claimant* OperationCreateClaimableBalance::mutable_claimants(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationCreateClaimableBalance.claimants)
  return claimants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Stellar::Proto::Claimant >*
OperationCreateClaimableBalance::mutable_claimants() {
  // @@protoc_insertion_point(field_mutable_list:TW.Stellar.Proto.OperationCreateClaimableBalance.claimants)
  return &claimants_;
}
inline const ::TW::Stellar::Proto::Claimant& OperationCreateClaimableBalance::_internal_claimants(int index) const {
  return claimants_.Get(index);
}
inline const ::TW::Stellar::Proto::Claimant& OperationCreateClaimableBalance::claimants(int index) const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationCreateClaimableBalance.claimants)
  return _internal_claimants(index);
}
inline ::TW::Stellar::Proto::Claimant* OperationCreateClaimableBalance::_internal_add_claimants() {
  return claimants_.Add();
}
inline ::TW::Stellar::Proto::Claimant* OperationCreateClaimableBalance::add_claimants() {
  ::TW::Stellar::Proto::Claimant* _add = _internal_add_claimants();
  // @@protoc_insertion_point(field_add:TW.Stellar.Proto.OperationCreateClaimableBalance.claimants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Stellar::Proto::Claimant >&
OperationCreateClaimableBalance::claimants() const {
  // @@protoc_insertion_point(field_list:TW.Stellar.Proto.OperationCreateClaimableBalance.claimants)
  return claimants_;
}

// -------------------------------------------------------------------

// OperationClaimClaimableBalance

// bytes balance_id = 1;
inline void OperationClaimClaimableBalance::clear_balance_id() {
  balance_id_.ClearToEmpty();
}
inline const std::string& OperationClaimClaimableBalance::balance_id() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.OperationClaimClaimableBalance.balance_id)
  return _internal_balance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationClaimClaimableBalance::set_balance_id(ArgT0&& arg0, ArgT... args) {
 
 balance_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.OperationClaimClaimableBalance.balance_id)
}
inline std::string* OperationClaimClaimableBalance::mutable_balance_id() {
  std::string* _s = _internal_mutable_balance_id();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.OperationClaimClaimableBalance.balance_id)
  return _s;
}
inline const std::string& OperationClaimClaimableBalance::_internal_balance_id() const {
  return balance_id_.Get();
}
inline void OperationClaimClaimableBalance::_internal_set_balance_id(const std::string& value) {
  
  balance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OperationClaimClaimableBalance::_internal_mutable_balance_id() {
  
  return balance_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OperationClaimClaimableBalance::release_balance_id() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.OperationClaimClaimableBalance.balance_id)
  return balance_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OperationClaimClaimableBalance::set_allocated_balance_id(std::string* balance_id) {
  if (balance_id != nullptr) {
    
  } else {
    
  }
  balance_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), balance_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (balance_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    balance_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.OperationClaimClaimableBalance.balance_id)
}

// -------------------------------------------------------------------

// MemoVoid

// -------------------------------------------------------------------

// MemoText

// string text = 1;
inline void MemoText::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& MemoText::text() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.MemoText.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MemoText::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.MemoText.text)
}
inline std::string* MemoText::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.MemoText.text)
  return _s;
}
inline const std::string& MemoText::_internal_text() const {
  return text_.Get();
}
inline void MemoText::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MemoText::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MemoText::release_text() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.MemoText.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MemoText::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.MemoText.text)
}

// -------------------------------------------------------------------

// MemoId

// int64 id = 1;
inline void MemoId::clear_id() {
  id_ = int64_t{0};
}
inline int64_t MemoId::_internal_id() const {
  return id_;
}
inline int64_t MemoId::id() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.MemoId.id)
  return _internal_id();
}
inline void MemoId::_internal_set_id(int64_t value) {
  
  id_ = value;
}
inline void MemoId::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.MemoId.id)
}

// -------------------------------------------------------------------

// MemoHash

// bytes hash = 1;
inline void MemoHash::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& MemoHash::hash() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.MemoHash.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MemoHash::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.MemoHash.hash)
}
inline std::string* MemoHash::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.MemoHash.hash)
  return _s;
}
inline const std::string& MemoHash::_internal_hash() const {
  return hash_.Get();
}
inline void MemoHash::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MemoHash::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MemoHash::release_hash() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.MemoHash.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MemoHash::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.MemoHash.hash)
}

// -------------------------------------------------------------------

// SigningInput

// int32 fee = 1;
inline void SigningInput::clear_fee() {
  fee_ = 0;
}
inline int32_t SigningInput::_internal_fee() const {
  return fee_;
}
inline int32_t SigningInput::fee() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.fee)
  return _internal_fee();
}
inline void SigningInput::_internal_set_fee(int32_t value) {
  
  fee_ = value;
}
inline void SigningInput::set_fee(int32_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningInput.fee)
}

// int64 sequence = 2;
inline void SigningInput::clear_sequence() {
  sequence_ = int64_t{0};
}
inline int64_t SigningInput::_internal_sequence() const {
  return sequence_;
}
inline int64_t SigningInput::sequence() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.sequence)
  return _internal_sequence();
}
inline void SigningInput::_internal_set_sequence(int64_t value) {
  
  sequence_ = value;
}
inline void SigningInput::set_sequence(int64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningInput.sequence)
}

// string account = 3;
inline void SigningInput::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& SigningInput::account() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningInput.account)
}
inline std::string* SigningInput::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.account)
  return _s;
}
inline const std::string& SigningInput::_internal_account() const {
  return account_.Get();
}
inline void SigningInput::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_account() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.SigningInput.account)
}

// bytes private_key = 4;
inline void SigningInput::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& SigningInput::private_key() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 private_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.private_key)
  return _s;
}
inline const std::string& SigningInput::_internal_private_key() const {
  return private_key_.Get();
}
inline void SigningInput::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_private_key() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.SigningInput.private_key)
}

// string passphrase = 5;
inline void SigningInput::clear_passphrase() {
  passphrase_.ClearToEmpty();
}
inline const std::string& SigningInput::passphrase() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.passphrase)
  return _internal_passphrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_passphrase(ArgT0&& arg0, ArgT... args) {
 
 passphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningInput.passphrase)
}
inline std::string* SigningInput::mutable_passphrase() {
  std::string* _s = _internal_mutable_passphrase();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.passphrase)
  return _s;
}
inline const std::string& SigningInput::_internal_passphrase() const {
  return passphrase_.Get();
}
inline void SigningInput::_internal_set_passphrase(const std::string& value) {
  
  passphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_passphrase() {
  
  return passphrase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_passphrase() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.passphrase)
  return passphrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_passphrase(std::string* passphrase) {
  if (passphrase != nullptr) {
    
  } else {
    
  }
  passphrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passphrase,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (passphrase_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    passphrase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.SigningInput.passphrase)
}

// .TW.Stellar.Proto.OperationCreateAccount op_create_account = 6;
inline bool SigningInput::_internal_has_op_create_account() const {
  return operation_oneof_case() == kOpCreateAccount;
}
inline bool SigningInput::has_op_create_account() const {
  return _internal_has_op_create_account();
}
inline void SigningInput::set_has_op_create_account() {
  _oneof_case_[0] = kOpCreateAccount;
}
inline void SigningInput::clear_op_create_account() {
  if (_internal_has_op_create_account()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_create_account_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Stellar::Proto::OperationCreateAccount* SigningInput::release_op_create_account() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.op_create_account)
  if (_internal_has_op_create_account()) {
    clear_has_operation_oneof();
      ::TW::Stellar::Proto::OperationCreateAccount* temp = operation_oneof_.op_create_account_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::OperationCreateAccount& SigningInput::_internal_op_create_account() const {
  return _internal_has_op_create_account()
      ? *operation_oneof_.op_create_account_
      : reinterpret_cast< ::TW::Stellar::Proto::OperationCreateAccount&>(::TW::Stellar::Proto::_OperationCreateAccount_default_instance_);
}
inline const ::TW::Stellar::Proto::OperationCreateAccount& SigningInput::op_create_account() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.op_create_account)
  return _internal_op_create_account();
}
inline ::TW::Stellar::Proto::OperationCreateAccount* SigningInput::unsafe_arena_release_op_create_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.op_create_account)
  if (_internal_has_op_create_account()) {
    clear_has_operation_oneof();
    ::TW::Stellar::Proto::OperationCreateAccount* temp = operation_oneof_.op_create_account_;
    operation_oneof_.op_create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_create_account(::TW::Stellar::Proto::OperationCreateAccount* op_create_account) {
  clear_operation_oneof();
  if (op_create_account) {
    set_has_op_create_account();
    operation_oneof_.op_create_account_ = op_create_account;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.op_create_account)
}
inline ::TW::Stellar::Proto::OperationCreateAccount* SigningInput::_internal_mutable_op_create_account() {
  if (!_internal_has_op_create_account()) {
    clear_operation_oneof();
    set_has_op_create_account();
    operation_oneof_.op_create_account_ = CreateMaybeMessage< ::TW::Stellar::Proto::OperationCreateAccount >(GetArenaForAllocation());
  }
  return operation_oneof_.op_create_account_;
}
inline ::TW::Stellar::Proto::OperationCreateAccount* SigningInput::mutable_op_create_account() {
  ::TW::Stellar::Proto::OperationCreateAccount* _msg = _internal_mutable_op_create_account();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.op_create_account)
  return _msg;
}

// .TW.Stellar.Proto.OperationPayment op_payment = 7;
inline bool SigningInput::_internal_has_op_payment() const {
  return operation_oneof_case() == kOpPayment;
}
inline bool SigningInput::has_op_payment() const {
  return _internal_has_op_payment();
}
inline void SigningInput::set_has_op_payment() {
  _oneof_case_[0] = kOpPayment;
}
inline void SigningInput::clear_op_payment() {
  if (_internal_has_op_payment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_payment_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Stellar::Proto::OperationPayment* SigningInput::release_op_payment() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.op_payment)
  if (_internal_has_op_payment()) {
    clear_has_operation_oneof();
      ::TW::Stellar::Proto::OperationPayment* temp = operation_oneof_.op_payment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_payment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::OperationPayment& SigningInput::_internal_op_payment() const {
  return _internal_has_op_payment()
      ? *operation_oneof_.op_payment_
      : reinterpret_cast< ::TW::Stellar::Proto::OperationPayment&>(::TW::Stellar::Proto::_OperationPayment_default_instance_);
}
inline const ::TW::Stellar::Proto::OperationPayment& SigningInput::op_payment() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.op_payment)
  return _internal_op_payment();
}
inline ::TW::Stellar::Proto::OperationPayment* SigningInput::unsafe_arena_release_op_payment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.op_payment)
  if (_internal_has_op_payment()) {
    clear_has_operation_oneof();
    ::TW::Stellar::Proto::OperationPayment* temp = operation_oneof_.op_payment_;
    operation_oneof_.op_payment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_payment(::TW::Stellar::Proto::OperationPayment* op_payment) {
  clear_operation_oneof();
  if (op_payment) {
    set_has_op_payment();
    operation_oneof_.op_payment_ = op_payment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.op_payment)
}
inline ::TW::Stellar::Proto::OperationPayment* SigningInput::_internal_mutable_op_payment() {
  if (!_internal_has_op_payment()) {
    clear_operation_oneof();
    set_has_op_payment();
    operation_oneof_.op_payment_ = CreateMaybeMessage< ::TW::Stellar::Proto::OperationPayment >(GetArenaForAllocation());
  }
  return operation_oneof_.op_payment_;
}
inline ::TW::Stellar::Proto::OperationPayment* SigningInput::mutable_op_payment() {
  ::TW::Stellar::Proto::OperationPayment* _msg = _internal_mutable_op_payment();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.op_payment)
  return _msg;
}

// .TW.Stellar.Proto.OperationChangeTrust op_change_trust = 8;
inline bool SigningInput::_internal_has_op_change_trust() const {
  return operation_oneof_case() == kOpChangeTrust;
}
inline bool SigningInput::has_op_change_trust() const {
  return _internal_has_op_change_trust();
}
inline void SigningInput::set_has_op_change_trust() {
  _oneof_case_[0] = kOpChangeTrust;
}
inline void SigningInput::clear_op_change_trust() {
  if (_internal_has_op_change_trust()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_change_trust_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Stellar::Proto::OperationChangeTrust* SigningInput::release_op_change_trust() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.op_change_trust)
  if (_internal_has_op_change_trust()) {
    clear_has_operation_oneof();
      ::TW::Stellar::Proto::OperationChangeTrust* temp = operation_oneof_.op_change_trust_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_change_trust_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::OperationChangeTrust& SigningInput::_internal_op_change_trust() const {
  return _internal_has_op_change_trust()
      ? *operation_oneof_.op_change_trust_
      : reinterpret_cast< ::TW::Stellar::Proto::OperationChangeTrust&>(::TW::Stellar::Proto::_OperationChangeTrust_default_instance_);
}
inline const ::TW::Stellar::Proto::OperationChangeTrust& SigningInput::op_change_trust() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.op_change_trust)
  return _internal_op_change_trust();
}
inline ::TW::Stellar::Proto::OperationChangeTrust* SigningInput::unsafe_arena_release_op_change_trust() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.op_change_trust)
  if (_internal_has_op_change_trust()) {
    clear_has_operation_oneof();
    ::TW::Stellar::Proto::OperationChangeTrust* temp = operation_oneof_.op_change_trust_;
    operation_oneof_.op_change_trust_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_change_trust(::TW::Stellar::Proto::OperationChangeTrust* op_change_trust) {
  clear_operation_oneof();
  if (op_change_trust) {
    set_has_op_change_trust();
    operation_oneof_.op_change_trust_ = op_change_trust;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.op_change_trust)
}
inline ::TW::Stellar::Proto::OperationChangeTrust* SigningInput::_internal_mutable_op_change_trust() {
  if (!_internal_has_op_change_trust()) {
    clear_operation_oneof();
    set_has_op_change_trust();
    operation_oneof_.op_change_trust_ = CreateMaybeMessage< ::TW::Stellar::Proto::OperationChangeTrust >(GetArenaForAllocation());
  }
  return operation_oneof_.op_change_trust_;
}
inline ::TW::Stellar::Proto::OperationChangeTrust* SigningInput::mutable_op_change_trust() {
  ::TW::Stellar::Proto::OperationChangeTrust* _msg = _internal_mutable_op_change_trust();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.op_change_trust)
  return _msg;
}

// .TW.Stellar.Proto.OperationCreateClaimableBalance op_create_claimable_balance = 14;
inline bool SigningInput::_internal_has_op_create_claimable_balance() const {
  return operation_oneof_case() == kOpCreateClaimableBalance;
}
inline bool SigningInput::has_op_create_claimable_balance() const {
  return _internal_has_op_create_claimable_balance();
}
inline void SigningInput::set_has_op_create_claimable_balance() {
  _oneof_case_[0] = kOpCreateClaimableBalance;
}
inline void SigningInput::clear_op_create_claimable_balance() {
  if (_internal_has_op_create_claimable_balance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_create_claimable_balance_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Stellar::Proto::OperationCreateClaimableBalance* SigningInput::release_op_create_claimable_balance() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.op_create_claimable_balance)
  if (_internal_has_op_create_claimable_balance()) {
    clear_has_operation_oneof();
      ::TW::Stellar::Proto::OperationCreateClaimableBalance* temp = operation_oneof_.op_create_claimable_balance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_create_claimable_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::OperationCreateClaimableBalance& SigningInput::_internal_op_create_claimable_balance() const {
  return _internal_has_op_create_claimable_balance()
      ? *operation_oneof_.op_create_claimable_balance_
      : reinterpret_cast< ::TW::Stellar::Proto::OperationCreateClaimableBalance&>(::TW::Stellar::Proto::_OperationCreateClaimableBalance_default_instance_);
}
inline const ::TW::Stellar::Proto::OperationCreateClaimableBalance& SigningInput::op_create_claimable_balance() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.op_create_claimable_balance)
  return _internal_op_create_claimable_balance();
}
inline ::TW::Stellar::Proto::OperationCreateClaimableBalance* SigningInput::unsafe_arena_release_op_create_claimable_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.op_create_claimable_balance)
  if (_internal_has_op_create_claimable_balance()) {
    clear_has_operation_oneof();
    ::TW::Stellar::Proto::OperationCreateClaimableBalance* temp = operation_oneof_.op_create_claimable_balance_;
    operation_oneof_.op_create_claimable_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_create_claimable_balance(::TW::Stellar::Proto::OperationCreateClaimableBalance* op_create_claimable_balance) {
  clear_operation_oneof();
  if (op_create_claimable_balance) {
    set_has_op_create_claimable_balance();
    operation_oneof_.op_create_claimable_balance_ = op_create_claimable_balance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.op_create_claimable_balance)
}
inline ::TW::Stellar::Proto::OperationCreateClaimableBalance* SigningInput::_internal_mutable_op_create_claimable_balance() {
  if (!_internal_has_op_create_claimable_balance()) {
    clear_operation_oneof();
    set_has_op_create_claimable_balance();
    operation_oneof_.op_create_claimable_balance_ = CreateMaybeMessage< ::TW::Stellar::Proto::OperationCreateClaimableBalance >(GetArenaForAllocation());
  }
  return operation_oneof_.op_create_claimable_balance_;
}
inline ::TW::Stellar::Proto::OperationCreateClaimableBalance* SigningInput::mutable_op_create_claimable_balance() {
  ::TW::Stellar::Proto::OperationCreateClaimableBalance* _msg = _internal_mutable_op_create_claimable_balance();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.op_create_claimable_balance)
  return _msg;
}

// .TW.Stellar.Proto.OperationClaimClaimableBalance op_claim_claimable_balance = 15;
inline bool SigningInput::_internal_has_op_claim_claimable_balance() const {
  return operation_oneof_case() == kOpClaimClaimableBalance;
}
inline bool SigningInput::has_op_claim_claimable_balance() const {
  return _internal_has_op_claim_claimable_balance();
}
inline void SigningInput::set_has_op_claim_claimable_balance() {
  _oneof_case_[0] = kOpClaimClaimableBalance;
}
inline void SigningInput::clear_op_claim_claimable_balance() {
  if (_internal_has_op_claim_claimable_balance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete operation_oneof_.op_claim_claimable_balance_;
    }
    clear_has_operation_oneof();
  }
}
inline ::TW::Stellar::Proto::OperationClaimClaimableBalance* SigningInput::release_op_claim_claimable_balance() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.op_claim_claimable_balance)
  if (_internal_has_op_claim_claimable_balance()) {
    clear_has_operation_oneof();
      ::TW::Stellar::Proto::OperationClaimClaimableBalance* temp = operation_oneof_.op_claim_claimable_balance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    operation_oneof_.op_claim_claimable_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::OperationClaimClaimableBalance& SigningInput::_internal_op_claim_claimable_balance() const {
  return _internal_has_op_claim_claimable_balance()
      ? *operation_oneof_.op_claim_claimable_balance_
      : reinterpret_cast< ::TW::Stellar::Proto::OperationClaimClaimableBalance&>(::TW::Stellar::Proto::_OperationClaimClaimableBalance_default_instance_);
}
inline const ::TW::Stellar::Proto::OperationClaimClaimableBalance& SigningInput::op_claim_claimable_balance() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.op_claim_claimable_balance)
  return _internal_op_claim_claimable_balance();
}
inline ::TW::Stellar::Proto::OperationClaimClaimableBalance* SigningInput::unsafe_arena_release_op_claim_claimable_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.op_claim_claimable_balance)
  if (_internal_has_op_claim_claimable_balance()) {
    clear_has_operation_oneof();
    ::TW::Stellar::Proto::OperationClaimClaimableBalance* temp = operation_oneof_.op_claim_claimable_balance_;
    operation_oneof_.op_claim_claimable_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_op_claim_claimable_balance(::TW::Stellar::Proto::OperationClaimClaimableBalance* op_claim_claimable_balance) {
  clear_operation_oneof();
  if (op_claim_claimable_balance) {
    set_has_op_claim_claimable_balance();
    operation_oneof_.op_claim_claimable_balance_ = op_claim_claimable_balance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.op_claim_claimable_balance)
}
inline ::TW::Stellar::Proto::OperationClaimClaimableBalance* SigningInput::_internal_mutable_op_claim_claimable_balance() {
  if (!_internal_has_op_claim_claimable_balance()) {
    clear_operation_oneof();
    set_has_op_claim_claimable_balance();
    operation_oneof_.op_claim_claimable_balance_ = CreateMaybeMessage< ::TW::Stellar::Proto::OperationClaimClaimableBalance >(GetArenaForAllocation());
  }
  return operation_oneof_.op_claim_claimable_balance_;
}
inline ::TW::Stellar::Proto::OperationClaimClaimableBalance* SigningInput::mutable_op_claim_claimable_balance() {
  ::TW::Stellar::Proto::OperationClaimClaimableBalance* _msg = _internal_mutable_op_claim_claimable_balance();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.op_claim_claimable_balance)
  return _msg;
}

// .TW.Stellar.Proto.MemoVoid memo_void = 9;
inline bool SigningInput::_internal_has_memo_void() const {
  return memo_type_oneof_case() == kMemoVoid;
}
inline bool SigningInput::has_memo_void() const {
  return _internal_has_memo_void();
}
inline void SigningInput::set_has_memo_void() {
  _oneof_case_[1] = kMemoVoid;
}
inline void SigningInput::clear_memo_void() {
  if (_internal_has_memo_void()) {
    if (GetArenaForAllocation() == nullptr) {
      delete memo_type_oneof_.memo_void_;
    }
    clear_has_memo_type_oneof();
  }
}
inline ::TW::Stellar::Proto::MemoVoid* SigningInput::release_memo_void() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.memo_void)
  if (_internal_has_memo_void()) {
    clear_has_memo_type_oneof();
      ::TW::Stellar::Proto::MemoVoid* temp = memo_type_oneof_.memo_void_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    memo_type_oneof_.memo_void_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::MemoVoid& SigningInput::_internal_memo_void() const {
  return _internal_has_memo_void()
      ? *memo_type_oneof_.memo_void_
      : reinterpret_cast< ::TW::Stellar::Proto::MemoVoid&>(::TW::Stellar::Proto::_MemoVoid_default_instance_);
}
inline const ::TW::Stellar::Proto::MemoVoid& SigningInput::memo_void() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.memo_void)
  return _internal_memo_void();
}
inline ::TW::Stellar::Proto::MemoVoid* SigningInput::unsafe_arena_release_memo_void() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.memo_void)
  if (_internal_has_memo_void()) {
    clear_has_memo_type_oneof();
    ::TW::Stellar::Proto::MemoVoid* temp = memo_type_oneof_.memo_void_;
    memo_type_oneof_.memo_void_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_memo_void(::TW::Stellar::Proto::MemoVoid* memo_void) {
  clear_memo_type_oneof();
  if (memo_void) {
    set_has_memo_void();
    memo_type_oneof_.memo_void_ = memo_void;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.memo_void)
}
inline ::TW::Stellar::Proto::MemoVoid* SigningInput::_internal_mutable_memo_void() {
  if (!_internal_has_memo_void()) {
    clear_memo_type_oneof();
    set_has_memo_void();
    memo_type_oneof_.memo_void_ = CreateMaybeMessage< ::TW::Stellar::Proto::MemoVoid >(GetArenaForAllocation());
  }
  return memo_type_oneof_.memo_void_;
}
inline ::TW::Stellar::Proto::MemoVoid* SigningInput::mutable_memo_void() {
  ::TW::Stellar::Proto::MemoVoid* _msg = _internal_mutable_memo_void();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.memo_void)
  return _msg;
}

// .TW.Stellar.Proto.MemoText memo_text = 10;
inline bool SigningInput::_internal_has_memo_text() const {
  return memo_type_oneof_case() == kMemoText;
}
inline bool SigningInput::has_memo_text() const {
  return _internal_has_memo_text();
}
inline void SigningInput::set_has_memo_text() {
  _oneof_case_[1] = kMemoText;
}
inline void SigningInput::clear_memo_text() {
  if (_internal_has_memo_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete memo_type_oneof_.memo_text_;
    }
    clear_has_memo_type_oneof();
  }
}
inline ::TW::Stellar::Proto::MemoText* SigningInput::release_memo_text() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.memo_text)
  if (_internal_has_memo_text()) {
    clear_has_memo_type_oneof();
      ::TW::Stellar::Proto::MemoText* temp = memo_type_oneof_.memo_text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    memo_type_oneof_.memo_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::MemoText& SigningInput::_internal_memo_text() const {
  return _internal_has_memo_text()
      ? *memo_type_oneof_.memo_text_
      : reinterpret_cast< ::TW::Stellar::Proto::MemoText&>(::TW::Stellar::Proto::_MemoText_default_instance_);
}
inline const ::TW::Stellar::Proto::MemoText& SigningInput::memo_text() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.memo_text)
  return _internal_memo_text();
}
inline ::TW::Stellar::Proto::MemoText* SigningInput::unsafe_arena_release_memo_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.memo_text)
  if (_internal_has_memo_text()) {
    clear_has_memo_type_oneof();
    ::TW::Stellar::Proto::MemoText* temp = memo_type_oneof_.memo_text_;
    memo_type_oneof_.memo_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_memo_text(::TW::Stellar::Proto::MemoText* memo_text) {
  clear_memo_type_oneof();
  if (memo_text) {
    set_has_memo_text();
    memo_type_oneof_.memo_text_ = memo_text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.memo_text)
}
inline ::TW::Stellar::Proto::MemoText* SigningInput::_internal_mutable_memo_text() {
  if (!_internal_has_memo_text()) {
    clear_memo_type_oneof();
    set_has_memo_text();
    memo_type_oneof_.memo_text_ = CreateMaybeMessage< ::TW::Stellar::Proto::MemoText >(GetArenaForAllocation());
  }
  return memo_type_oneof_.memo_text_;
}
inline ::TW::Stellar::Proto::MemoText* SigningInput::mutable_memo_text() {
  ::TW::Stellar::Proto::MemoText* _msg = _internal_mutable_memo_text();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.memo_text)
  return _msg;
}

// .TW.Stellar.Proto.MemoId memo_id = 11;
inline bool SigningInput::_internal_has_memo_id() const {
  return memo_type_oneof_case() == kMemoId;
}
inline bool SigningInput::has_memo_id() const {
  return _internal_has_memo_id();
}
inline void SigningInput::set_has_memo_id() {
  _oneof_case_[1] = kMemoId;
}
inline void SigningInput::clear_memo_id() {
  if (_internal_has_memo_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete memo_type_oneof_.memo_id_;
    }
    clear_has_memo_type_oneof();
  }
}
inline ::TW::Stellar::Proto::MemoId* SigningInput::release_memo_id() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.memo_id)
  if (_internal_has_memo_id()) {
    clear_has_memo_type_oneof();
      ::TW::Stellar::Proto::MemoId* temp = memo_type_oneof_.memo_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    memo_type_oneof_.memo_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::MemoId& SigningInput::_internal_memo_id() const {
  return _internal_has_memo_id()
      ? *memo_type_oneof_.memo_id_
      : reinterpret_cast< ::TW::Stellar::Proto::MemoId&>(::TW::Stellar::Proto::_MemoId_default_instance_);
}
inline const ::TW::Stellar::Proto::MemoId& SigningInput::memo_id() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.memo_id)
  return _internal_memo_id();
}
inline ::TW::Stellar::Proto::MemoId* SigningInput::unsafe_arena_release_memo_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.memo_id)
  if (_internal_has_memo_id()) {
    clear_has_memo_type_oneof();
    ::TW::Stellar::Proto::MemoId* temp = memo_type_oneof_.memo_id_;
    memo_type_oneof_.memo_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_memo_id(::TW::Stellar::Proto::MemoId* memo_id) {
  clear_memo_type_oneof();
  if (memo_id) {
    set_has_memo_id();
    memo_type_oneof_.memo_id_ = memo_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.memo_id)
}
inline ::TW::Stellar::Proto::MemoId* SigningInput::_internal_mutable_memo_id() {
  if (!_internal_has_memo_id()) {
    clear_memo_type_oneof();
    set_has_memo_id();
    memo_type_oneof_.memo_id_ = CreateMaybeMessage< ::TW::Stellar::Proto::MemoId >(GetArenaForAllocation());
  }
  return memo_type_oneof_.memo_id_;
}
inline ::TW::Stellar::Proto::MemoId* SigningInput::mutable_memo_id() {
  ::TW::Stellar::Proto::MemoId* _msg = _internal_mutable_memo_id();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.memo_id)
  return _msg;
}

// .TW.Stellar.Proto.MemoHash memo_hash = 12;
inline bool SigningInput::_internal_has_memo_hash() const {
  return memo_type_oneof_case() == kMemoHash;
}
inline bool SigningInput::has_memo_hash() const {
  return _internal_has_memo_hash();
}
inline void SigningInput::set_has_memo_hash() {
  _oneof_case_[1] = kMemoHash;
}
inline void SigningInput::clear_memo_hash() {
  if (_internal_has_memo_hash()) {
    if (GetArenaForAllocation() == nullptr) {
      delete memo_type_oneof_.memo_hash_;
    }
    clear_has_memo_type_oneof();
  }
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::release_memo_hash() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.memo_hash)
  if (_internal_has_memo_hash()) {
    clear_has_memo_type_oneof();
      ::TW::Stellar::Proto::MemoHash* temp = memo_type_oneof_.memo_hash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    memo_type_oneof_.memo_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::MemoHash& SigningInput::_internal_memo_hash() const {
  return _internal_has_memo_hash()
      ? *memo_type_oneof_.memo_hash_
      : reinterpret_cast< ::TW::Stellar::Proto::MemoHash&>(::TW::Stellar::Proto::_MemoHash_default_instance_);
}
inline const ::TW::Stellar::Proto::MemoHash& SigningInput::memo_hash() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.memo_hash)
  return _internal_memo_hash();
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::unsafe_arena_release_memo_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.memo_hash)
  if (_internal_has_memo_hash()) {
    clear_has_memo_type_oneof();
    ::TW::Stellar::Proto::MemoHash* temp = memo_type_oneof_.memo_hash_;
    memo_type_oneof_.memo_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_memo_hash(::TW::Stellar::Proto::MemoHash* memo_hash) {
  clear_memo_type_oneof();
  if (memo_hash) {
    set_has_memo_hash();
    memo_type_oneof_.memo_hash_ = memo_hash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.memo_hash)
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::_internal_mutable_memo_hash() {
  if (!_internal_has_memo_hash()) {
    clear_memo_type_oneof();
    set_has_memo_hash();
    memo_type_oneof_.memo_hash_ = CreateMaybeMessage< ::TW::Stellar::Proto::MemoHash >(GetArenaForAllocation());
  }
  return memo_type_oneof_.memo_hash_;
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::mutable_memo_hash() {
  ::TW::Stellar::Proto::MemoHash* _msg = _internal_mutable_memo_hash();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.memo_hash)
  return _msg;
}

// .TW.Stellar.Proto.MemoHash memo_return_hash = 13;
inline bool SigningInput::_internal_has_memo_return_hash() const {
  return memo_type_oneof_case() == kMemoReturnHash;
}
inline bool SigningInput::has_memo_return_hash() const {
  return _internal_has_memo_return_hash();
}
inline void SigningInput::set_has_memo_return_hash() {
  _oneof_case_[1] = kMemoReturnHash;
}
inline void SigningInput::clear_memo_return_hash() {
  if (_internal_has_memo_return_hash()) {
    if (GetArenaForAllocation() == nullptr) {
      delete memo_type_oneof_.memo_return_hash_;
    }
    clear_has_memo_type_oneof();
  }
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::release_memo_return_hash() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningInput.memo_return_hash)
  if (_internal_has_memo_return_hash()) {
    clear_has_memo_type_oneof();
      ::TW::Stellar::Proto::MemoHash* temp = memo_type_oneof_.memo_return_hash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    memo_type_oneof_.memo_return_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Stellar::Proto::MemoHash& SigningInput::_internal_memo_return_hash() const {
  return _internal_has_memo_return_hash()
      ? *memo_type_oneof_.memo_return_hash_
      : reinterpret_cast< ::TW::Stellar::Proto::MemoHash&>(::TW::Stellar::Proto::_MemoHash_default_instance_);
}
inline const ::TW::Stellar::Proto::MemoHash& SigningInput::memo_return_hash() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.memo_return_hash)
  return _internal_memo_return_hash();
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::unsafe_arena_release_memo_return_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Stellar.Proto.SigningInput.memo_return_hash)
  if (_internal_has_memo_return_hash()) {
    clear_has_memo_type_oneof();
    ::TW::Stellar::Proto::MemoHash* temp = memo_type_oneof_.memo_return_hash_;
    memo_type_oneof_.memo_return_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SigningInput::unsafe_arena_set_allocated_memo_return_hash(::TW::Stellar::Proto::MemoHash* memo_return_hash) {
  clear_memo_type_oneof();
  if (memo_return_hash) {
    set_has_memo_return_hash();
    memo_type_oneof_.memo_return_hash_ = memo_return_hash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Stellar.Proto.SigningInput.memo_return_hash)
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::_internal_mutable_memo_return_hash() {
  if (!_internal_has_memo_return_hash()) {
    clear_memo_type_oneof();
    set_has_memo_return_hash();
    memo_type_oneof_.memo_return_hash_ = CreateMaybeMessage< ::TW::Stellar::Proto::MemoHash >(GetArenaForAllocation());
  }
  return memo_type_oneof_.memo_return_hash_;
}
inline ::TW::Stellar::Proto::MemoHash* SigningInput::mutable_memo_return_hash() {
  ::TW::Stellar::Proto::MemoHash* _msg = _internal_mutable_memo_return_hash();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningInput.memo_return_hash)
  return _msg;
}

// int64 time_bounds = 16;
inline void SigningInput::clear_time_bounds() {
  time_bounds_ = int64_t{0};
}
inline int64_t SigningInput::_internal_time_bounds() const {
  return time_bounds_;
}
inline int64_t SigningInput::time_bounds() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningInput.time_bounds)
  return _internal_time_bounds();
}
inline void SigningInput::_internal_set_time_bounds(int64_t value) {
  
  time_bounds_ = value;
}
inline void SigningInput::set_time_bounds(int64_t value) {
  _internal_set_time_bounds(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningInput.time_bounds)
}

inline bool SigningInput::has_operation_oneof() const {
  return operation_oneof_case() != OPERATION_ONEOF_NOT_SET;
}
inline void SigningInput::clear_has_operation_oneof() {
  _oneof_case_[0] = OPERATION_ONEOF_NOT_SET;
}
inline bool SigningInput::has_memo_type_oneof() const {
  return memo_type_oneof_case() != MEMO_TYPE_ONEOF_NOT_SET;
}
inline void SigningInput::clear_has_memo_type_oneof() {
  _oneof_case_[1] = MEMO_TYPE_ONEOF_NOT_SET;
}
inline SigningInput::OperationOneofCase SigningInput::operation_oneof_case() const {
  return SigningInput::OperationOneofCase(_oneof_case_[0]);
}
inline SigningInput::MemoTypeOneofCase SigningInput::memo_type_oneof_case() const {
  return SigningInput::MemoTypeOneofCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// SigningOutput

// string signature = 1;
inline void SigningOutput::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& SigningOutput::signature() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningOutput.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningOutput.signature)
}
inline std::string* SigningOutput::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningOutput.signature)
  return _s;
}
inline const std::string& SigningOutput::_internal_signature() const {
  return signature_.Get();
}
inline void SigningOutput::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_signature() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningOutput.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.SigningOutput.signature)
}

// .TW.Common.Proto.SigningError error = 2;
inline void SigningOutput::clear_error() {
  error_ = 0;
}
inline ::TW::Common::Proto::SigningError SigningOutput::_internal_error() const {
  return static_cast< ::TW::Common::Proto::SigningError >(error_);
}
inline ::TW::Common::Proto::SigningError SigningOutput::error() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningOutput.error)
  return _internal_error();
}
inline void SigningOutput::_internal_set_error(::TW::Common::Proto::SigningError value) {
  
  error_ = value;
}
inline void SigningOutput::set_error(::TW::Common::Proto::SigningError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningOutput.error)
}

// string error_message = 3;
inline void SigningOutput::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& SigningOutput::error_message() const {
  // @@protoc_insertion_point(field_get:TW.Stellar.Proto.SigningOutput.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Stellar.Proto.SigningOutput.error_message)
}
inline std::string* SigningOutput::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:TW.Stellar.Proto.SigningOutput.error_message)
  return _s;
}
inline const std::string& SigningOutput::_internal_error_message() const {
  return error_message_.Get();
}
inline void SigningOutput::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_error_message() {
  // @@protoc_insertion_point(field_release:TW.Stellar.Proto.SigningOutput.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Stellar.Proto.SigningOutput.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Stellar
}  // namespace TW

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TW::Stellar::Proto::ClaimPredicate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TW::Stellar::Proto::ClaimPredicate>() {
  return ::TW::Stellar::Proto::ClaimPredicate_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Stellar_2eproto
