// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Tron.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Tron_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Tron_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Tron_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Tron_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Tron_2eproto;
namespace TW {
namespace Tron {
namespace Proto {
class BlockHeader;
struct BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class DelegateResourceContract;
struct DelegateResourceContractDefaultTypeInternal;
extern DelegateResourceContractDefaultTypeInternal _DelegateResourceContract_default_instance_;
class FreezeBalanceContract;
struct FreezeBalanceContractDefaultTypeInternal;
extern FreezeBalanceContractDefaultTypeInternal _FreezeBalanceContract_default_instance_;
class FreezeBalanceV2Contract;
struct FreezeBalanceV2ContractDefaultTypeInternal;
extern FreezeBalanceV2ContractDefaultTypeInternal _FreezeBalanceV2Contract_default_instance_;
class SigningInput;
struct SigningInputDefaultTypeInternal;
extern SigningInputDefaultTypeInternal _SigningInput_default_instance_;
class SigningOutput;
struct SigningOutputDefaultTypeInternal;
extern SigningOutputDefaultTypeInternal _SigningOutput_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransferAssetContract;
struct TransferAssetContractDefaultTypeInternal;
extern TransferAssetContractDefaultTypeInternal _TransferAssetContract_default_instance_;
class TransferContract;
struct TransferContractDefaultTypeInternal;
extern TransferContractDefaultTypeInternal _TransferContract_default_instance_;
class TransferTRC20Contract;
struct TransferTRC20ContractDefaultTypeInternal;
extern TransferTRC20ContractDefaultTypeInternal _TransferTRC20Contract_default_instance_;
class TriggerSmartContract;
struct TriggerSmartContractDefaultTypeInternal;
extern TriggerSmartContractDefaultTypeInternal _TriggerSmartContract_default_instance_;
class UnDelegateResourceContract;
struct UnDelegateResourceContractDefaultTypeInternal;
extern UnDelegateResourceContractDefaultTypeInternal _UnDelegateResourceContract_default_instance_;
class UnfreezeAssetContract;
struct UnfreezeAssetContractDefaultTypeInternal;
extern UnfreezeAssetContractDefaultTypeInternal _UnfreezeAssetContract_default_instance_;
class UnfreezeBalanceContract;
struct UnfreezeBalanceContractDefaultTypeInternal;
extern UnfreezeBalanceContractDefaultTypeInternal _UnfreezeBalanceContract_default_instance_;
class UnfreezeBalanceV2Contract;
struct UnfreezeBalanceV2ContractDefaultTypeInternal;
extern UnfreezeBalanceV2ContractDefaultTypeInternal _UnfreezeBalanceV2Contract_default_instance_;
class VoteAssetContract;
struct VoteAssetContractDefaultTypeInternal;
extern VoteAssetContractDefaultTypeInternal _VoteAssetContract_default_instance_;
class VoteWitnessContract;
struct VoteWitnessContractDefaultTypeInternal;
extern VoteWitnessContractDefaultTypeInternal _VoteWitnessContract_default_instance_;
class VoteWitnessContract_Vote;
struct VoteWitnessContract_VoteDefaultTypeInternal;
extern VoteWitnessContract_VoteDefaultTypeInternal _VoteWitnessContract_Vote_default_instance_;
class WithdrawBalanceContract;
struct WithdrawBalanceContractDefaultTypeInternal;
extern WithdrawBalanceContractDefaultTypeInternal _WithdrawBalanceContract_default_instance_;
class WithdrawExpireUnfreezeContract;
struct WithdrawExpireUnfreezeContractDefaultTypeInternal;
extern WithdrawExpireUnfreezeContractDefaultTypeInternal _WithdrawExpireUnfreezeContract_default_instance_;
}  // namespace Proto
}  // namespace Tron
}  // namespace TW
PROTOBUF_NAMESPACE_OPEN
template<> ::TW::Tron::Proto::BlockHeader* Arena::CreateMaybeMessage<::TW::Tron::Proto::BlockHeader>(Arena*);
template<> ::TW::Tron::Proto::DelegateResourceContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::DelegateResourceContract>(Arena*);
template<> ::TW::Tron::Proto::FreezeBalanceContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::FreezeBalanceContract>(Arena*);
template<> ::TW::Tron::Proto::FreezeBalanceV2Contract* Arena::CreateMaybeMessage<::TW::Tron::Proto::FreezeBalanceV2Contract>(Arena*);
template<> ::TW::Tron::Proto::SigningInput* Arena::CreateMaybeMessage<::TW::Tron::Proto::SigningInput>(Arena*);
template<> ::TW::Tron::Proto::SigningOutput* Arena::CreateMaybeMessage<::TW::Tron::Proto::SigningOutput>(Arena*);
template<> ::TW::Tron::Proto::Transaction* Arena::CreateMaybeMessage<::TW::Tron::Proto::Transaction>(Arena*);
template<> ::TW::Tron::Proto::TransferAssetContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::TransferAssetContract>(Arena*);
template<> ::TW::Tron::Proto::TransferContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::TransferContract>(Arena*);
template<> ::TW::Tron::Proto::TransferTRC20Contract* Arena::CreateMaybeMessage<::TW::Tron::Proto::TransferTRC20Contract>(Arena*);
template<> ::TW::Tron::Proto::TriggerSmartContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::TriggerSmartContract>(Arena*);
template<> ::TW::Tron::Proto::UnDelegateResourceContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::UnDelegateResourceContract>(Arena*);
template<> ::TW::Tron::Proto::UnfreezeAssetContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::UnfreezeAssetContract>(Arena*);
template<> ::TW::Tron::Proto::UnfreezeBalanceContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::UnfreezeBalanceContract>(Arena*);
template<> ::TW::Tron::Proto::UnfreezeBalanceV2Contract* Arena::CreateMaybeMessage<::TW::Tron::Proto::UnfreezeBalanceV2Contract>(Arena*);
template<> ::TW::Tron::Proto::VoteAssetContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::VoteAssetContract>(Arena*);
template<> ::TW::Tron::Proto::VoteWitnessContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::VoteWitnessContract>(Arena*);
template<> ::TW::Tron::Proto::VoteWitnessContract_Vote* Arena::CreateMaybeMessage<::TW::Tron::Proto::VoteWitnessContract_Vote>(Arena*);
template<> ::TW::Tron::Proto::WithdrawBalanceContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::WithdrawBalanceContract>(Arena*);
template<> ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* Arena::CreateMaybeMessage<::TW::Tron::Proto::WithdrawExpireUnfreezeContract>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TW {
namespace Tron {
namespace Proto {

// ===================================================================

class TransferContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.TransferContract) */ {
 public:
  inline TransferContract() : TransferContract(nullptr) {}
  ~TransferContract() override;
  explicit constexpr TransferContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferContract(const TransferContract& from);
  TransferContract(TransferContract&& from) noexcept
    : TransferContract() {
    *this = ::std::move(from);
  }

  inline TransferContract& operator=(const TransferContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferContract& operator=(TransferContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferContract* internal_default_instance() {
    return reinterpret_cast<const TransferContract*>(
               &_TransferContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransferContract& a, TransferContract& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.TransferContract";
  }
  protected:
  explicit TransferContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string to_address = 2;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // int64 amount = 3;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.TransferContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
  int64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class TransferAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.TransferAssetContract) */ {
 public:
  inline TransferAssetContract() : TransferAssetContract(nullptr) {}
  ~TransferAssetContract() override;
  explicit constexpr TransferAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferAssetContract(const TransferAssetContract& from);
  TransferAssetContract(TransferAssetContract&& from) noexcept
    : TransferAssetContract() {
    *this = ::std::move(from);
  }

  inline TransferAssetContract& operator=(const TransferAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferAssetContract& operator=(TransferAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferAssetContract* internal_default_instance() {
    return reinterpret_cast<const TransferAssetContract*>(
               &_TransferAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TransferAssetContract& a, TransferAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferAssetContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferAssetContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferAssetContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.TransferAssetContract";
  }
  protected:
  explicit TransferAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetNameFieldNumber = 1,
    kOwnerAddressFieldNumber = 2,
    kToAddressFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // string asset_name = 1;
  void clear_asset_name();
  const std::string& asset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_name();
  PROTOBUF_NODISCARD std::string* release_asset_name();
  void set_allocated_asset_name(std::string* asset_name);
  private:
  const std::string& _internal_asset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_name(const std::string& value);
  std::string* _internal_mutable_asset_name();
  public:

  // string owner_address = 2;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string to_address = 3;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // int64 amount = 4;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.TransferAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
  int64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class TransferTRC20Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.TransferTRC20Contract) */ {
 public:
  inline TransferTRC20Contract() : TransferTRC20Contract(nullptr) {}
  ~TransferTRC20Contract() override;
  explicit constexpr TransferTRC20Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferTRC20Contract(const TransferTRC20Contract& from);
  TransferTRC20Contract(TransferTRC20Contract&& from) noexcept
    : TransferTRC20Contract() {
    *this = ::std::move(from);
  }

  inline TransferTRC20Contract& operator=(const TransferTRC20Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferTRC20Contract& operator=(TransferTRC20Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferTRC20Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferTRC20Contract* internal_default_instance() {
    return reinterpret_cast<const TransferTRC20Contract*>(
               &_TransferTRC20Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TransferTRC20Contract& a, TransferTRC20Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferTRC20Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferTRC20Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferTRC20Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferTRC20Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferTRC20Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferTRC20Contract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferTRC20Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.TransferTRC20Contract";
  }
  protected:
  explicit TransferTRC20Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractAddressFieldNumber = 1,
    kOwnerAddressFieldNumber = 2,
    kToAddressFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // string contract_address = 1;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // string owner_address = 2;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string to_address = 3;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // bytes amount = 4;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.TransferTRC20Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class FreezeBalanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.FreezeBalanceContract) */ {
 public:
  inline FreezeBalanceContract() : FreezeBalanceContract(nullptr) {}
  ~FreezeBalanceContract() override;
  explicit constexpr FreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeBalanceContract(const FreezeBalanceContract& from);
  FreezeBalanceContract(FreezeBalanceContract&& from) noexcept
    : FreezeBalanceContract() {
    *this = ::std::move(from);
  }

  inline FreezeBalanceContract& operator=(const FreezeBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeBalanceContract& operator=(FreezeBalanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeBalanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeBalanceContract* internal_default_instance() {
    return reinterpret_cast<const FreezeBalanceContract*>(
               &_FreezeBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FreezeBalanceContract& a, FreezeBalanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeBalanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeBalanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeBalanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeBalanceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FreezeBalanceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FreezeBalanceContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreezeBalanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.FreezeBalanceContract";
  }
  protected:
  explicit FreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kResourceFieldNumber = 10,
    kReceiverAddressFieldNumber = 15,
    kFrozenBalanceFieldNumber = 2,
    kFrozenDurationFieldNumber = 3,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string resource = 10;
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // string receiver_address = 15;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // int64 frozen_balance = 2;
  void clear_frozen_balance();
  int64_t frozen_balance() const;
  void set_frozen_balance(int64_t value);
  private:
  int64_t _internal_frozen_balance() const;
  void _internal_set_frozen_balance(int64_t value);
  public:

  // int64 frozen_duration = 3;
  void clear_frozen_duration();
  int64_t frozen_duration() const;
  void set_frozen_duration(int64_t value);
  private:
  int64_t _internal_frozen_duration() const;
  void _internal_set_frozen_duration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.FreezeBalanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
  int64_t frozen_balance_;
  int64_t frozen_duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class FreezeBalanceV2Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.FreezeBalanceV2Contract) */ {
 public:
  inline FreezeBalanceV2Contract() : FreezeBalanceV2Contract(nullptr) {}
  ~FreezeBalanceV2Contract() override;
  explicit constexpr FreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeBalanceV2Contract(const FreezeBalanceV2Contract& from);
  FreezeBalanceV2Contract(FreezeBalanceV2Contract&& from) noexcept
    : FreezeBalanceV2Contract() {
    *this = ::std::move(from);
  }

  inline FreezeBalanceV2Contract& operator=(const FreezeBalanceV2Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeBalanceV2Contract& operator=(FreezeBalanceV2Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeBalanceV2Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeBalanceV2Contract* internal_default_instance() {
    return reinterpret_cast<const FreezeBalanceV2Contract*>(
               &_FreezeBalanceV2Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FreezeBalanceV2Contract& a, FreezeBalanceV2Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeBalanceV2Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeBalanceV2Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeBalanceV2Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeBalanceV2Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FreezeBalanceV2Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FreezeBalanceV2Contract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreezeBalanceV2Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.FreezeBalanceV2Contract";
  }
  protected:
  explicit FreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kResourceFieldNumber = 3,
    kFrozenBalanceFieldNumber = 2,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string resource = 3;
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // int64 frozen_balance = 2;
  void clear_frozen_balance();
  int64_t frozen_balance() const;
  void set_frozen_balance(int64_t value);
  private:
  int64_t _internal_frozen_balance() const;
  void _internal_set_frozen_balance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.FreezeBalanceV2Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  int64_t frozen_balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class UnfreezeBalanceV2Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.UnfreezeBalanceV2Contract) */ {
 public:
  inline UnfreezeBalanceV2Contract() : UnfreezeBalanceV2Contract(nullptr) {}
  ~UnfreezeBalanceV2Contract() override;
  explicit constexpr UnfreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnfreezeBalanceV2Contract(const UnfreezeBalanceV2Contract& from);
  UnfreezeBalanceV2Contract(UnfreezeBalanceV2Contract&& from) noexcept
    : UnfreezeBalanceV2Contract() {
    *this = ::std::move(from);
  }

  inline UnfreezeBalanceV2Contract& operator=(const UnfreezeBalanceV2Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnfreezeBalanceV2Contract& operator=(UnfreezeBalanceV2Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnfreezeBalanceV2Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnfreezeBalanceV2Contract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeBalanceV2Contract*>(
               &_UnfreezeBalanceV2Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UnfreezeBalanceV2Contract& a, UnfreezeBalanceV2Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnfreezeBalanceV2Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnfreezeBalanceV2Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnfreezeBalanceV2Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnfreezeBalanceV2Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnfreezeBalanceV2Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnfreezeBalanceV2Contract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeBalanceV2Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.UnfreezeBalanceV2Contract";
  }
  protected:
  explicit UnfreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kResourceFieldNumber = 3,
    kUnfreezeBalanceFieldNumber = 2,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string resource = 3;
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // int64 unfreeze_balance = 2;
  void clear_unfreeze_balance();
  int64_t unfreeze_balance() const;
  void set_unfreeze_balance(int64_t value);
  private:
  int64_t _internal_unfreeze_balance() const;
  void _internal_set_unfreeze_balance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.UnfreezeBalanceV2Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  int64_t unfreeze_balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class WithdrawExpireUnfreezeContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.WithdrawExpireUnfreezeContract) */ {
 public:
  inline WithdrawExpireUnfreezeContract() : WithdrawExpireUnfreezeContract(nullptr) {}
  ~WithdrawExpireUnfreezeContract() override;
  explicit constexpr WithdrawExpireUnfreezeContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WithdrawExpireUnfreezeContract(const WithdrawExpireUnfreezeContract& from);
  WithdrawExpireUnfreezeContract(WithdrawExpireUnfreezeContract&& from) noexcept
    : WithdrawExpireUnfreezeContract() {
    *this = ::std::move(from);
  }

  inline WithdrawExpireUnfreezeContract& operator=(const WithdrawExpireUnfreezeContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithdrawExpireUnfreezeContract& operator=(WithdrawExpireUnfreezeContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithdrawExpireUnfreezeContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WithdrawExpireUnfreezeContract* internal_default_instance() {
    return reinterpret_cast<const WithdrawExpireUnfreezeContract*>(
               &_WithdrawExpireUnfreezeContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WithdrawExpireUnfreezeContract& a, WithdrawExpireUnfreezeContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WithdrawExpireUnfreezeContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithdrawExpireUnfreezeContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithdrawExpireUnfreezeContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WithdrawExpireUnfreezeContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WithdrawExpireUnfreezeContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WithdrawExpireUnfreezeContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WithdrawExpireUnfreezeContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.WithdrawExpireUnfreezeContract";
  }
  protected:
  explicit WithdrawExpireUnfreezeContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.WithdrawExpireUnfreezeContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class DelegateResourceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.DelegateResourceContract) */ {
 public:
  inline DelegateResourceContract() : DelegateResourceContract(nullptr) {}
  ~DelegateResourceContract() override;
  explicit constexpr DelegateResourceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegateResourceContract(const DelegateResourceContract& from);
  DelegateResourceContract(DelegateResourceContract&& from) noexcept
    : DelegateResourceContract() {
    *this = ::std::move(from);
  }

  inline DelegateResourceContract& operator=(const DelegateResourceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateResourceContract& operator=(DelegateResourceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegateResourceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegateResourceContract* internal_default_instance() {
    return reinterpret_cast<const DelegateResourceContract*>(
               &_DelegateResourceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DelegateResourceContract& a, DelegateResourceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateResourceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateResourceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegateResourceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegateResourceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegateResourceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelegateResourceContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateResourceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.DelegateResourceContract";
  }
  protected:
  explicit DelegateResourceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kResourceFieldNumber = 2,
    kReceiverAddressFieldNumber = 4,
    kBalanceFieldNumber = 3,
    kLockFieldNumber = 5,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string resource = 2;
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // string receiver_address = 4;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // int64 balance = 3;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // bool lock = 5;
  void clear_lock();
  bool lock() const;
  void set_lock(bool value);
  private:
  bool _internal_lock() const;
  void _internal_set_lock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.DelegateResourceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
  int64_t balance_;
  bool lock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class UnDelegateResourceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.UnDelegateResourceContract) */ {
 public:
  inline UnDelegateResourceContract() : UnDelegateResourceContract(nullptr) {}
  ~UnDelegateResourceContract() override;
  explicit constexpr UnDelegateResourceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnDelegateResourceContract(const UnDelegateResourceContract& from);
  UnDelegateResourceContract(UnDelegateResourceContract&& from) noexcept
    : UnDelegateResourceContract() {
    *this = ::std::move(from);
  }

  inline UnDelegateResourceContract& operator=(const UnDelegateResourceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnDelegateResourceContract& operator=(UnDelegateResourceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnDelegateResourceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnDelegateResourceContract* internal_default_instance() {
    return reinterpret_cast<const UnDelegateResourceContract*>(
               &_UnDelegateResourceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UnDelegateResourceContract& a, UnDelegateResourceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnDelegateResourceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnDelegateResourceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnDelegateResourceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnDelegateResourceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnDelegateResourceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnDelegateResourceContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnDelegateResourceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.UnDelegateResourceContract";
  }
  protected:
  explicit UnDelegateResourceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kResourceFieldNumber = 2,
    kReceiverAddressFieldNumber = 4,
    kBalanceFieldNumber = 3,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string resource = 2;
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // string receiver_address = 4;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // int64 balance = 3;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.UnDelegateResourceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
  int64_t balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class UnfreezeBalanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.UnfreezeBalanceContract) */ {
 public:
  inline UnfreezeBalanceContract() : UnfreezeBalanceContract(nullptr) {}
  ~UnfreezeBalanceContract() override;
  explicit constexpr UnfreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnfreezeBalanceContract(const UnfreezeBalanceContract& from);
  UnfreezeBalanceContract(UnfreezeBalanceContract&& from) noexcept
    : UnfreezeBalanceContract() {
    *this = ::std::move(from);
  }

  inline UnfreezeBalanceContract& operator=(const UnfreezeBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnfreezeBalanceContract& operator=(UnfreezeBalanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnfreezeBalanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnfreezeBalanceContract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeBalanceContract*>(
               &_UnfreezeBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UnfreezeBalanceContract& a, UnfreezeBalanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnfreezeBalanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnfreezeBalanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnfreezeBalanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnfreezeBalanceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnfreezeBalanceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnfreezeBalanceContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeBalanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.UnfreezeBalanceContract";
  }
  protected:
  explicit UnfreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kResourceFieldNumber = 10,
    kReceiverAddressFieldNumber = 15,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string resource = 10;
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // string receiver_address = 15;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.UnfreezeBalanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class UnfreezeAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.UnfreezeAssetContract) */ {
 public:
  inline UnfreezeAssetContract() : UnfreezeAssetContract(nullptr) {}
  ~UnfreezeAssetContract() override;
  explicit constexpr UnfreezeAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnfreezeAssetContract(const UnfreezeAssetContract& from);
  UnfreezeAssetContract(UnfreezeAssetContract&& from) noexcept
    : UnfreezeAssetContract() {
    *this = ::std::move(from);
  }

  inline UnfreezeAssetContract& operator=(const UnfreezeAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnfreezeAssetContract& operator=(UnfreezeAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnfreezeAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnfreezeAssetContract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeAssetContract*>(
               &_UnfreezeAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UnfreezeAssetContract& a, UnfreezeAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnfreezeAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnfreezeAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnfreezeAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnfreezeAssetContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnfreezeAssetContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnfreezeAssetContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.UnfreezeAssetContract";
  }
  protected:
  explicit UnfreezeAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.UnfreezeAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class VoteAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.VoteAssetContract) */ {
 public:
  inline VoteAssetContract() : VoteAssetContract(nullptr) {}
  ~VoteAssetContract() override;
  explicit constexpr VoteAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteAssetContract(const VoteAssetContract& from);
  VoteAssetContract(VoteAssetContract&& from) noexcept
    : VoteAssetContract() {
    *this = ::std::move(from);
  }

  inline VoteAssetContract& operator=(const VoteAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteAssetContract& operator=(VoteAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteAssetContract* internal_default_instance() {
    return reinterpret_cast<const VoteAssetContract*>(
               &_VoteAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VoteAssetContract& a, VoteAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteAssetContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteAssetContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteAssetContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.VoteAssetContract";
  }
  protected:
  explicit VoteAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteAddressFieldNumber = 2,
    kOwnerAddressFieldNumber = 1,
    kSupportFieldNumber = 3,
    kCountFieldNumber = 5,
  };
  // repeated string vote_address = 2;
  int vote_address_size() const;
  private:
  int _internal_vote_address_size() const;
  public:
  void clear_vote_address();
  const std::string& vote_address(int index) const;
  std::string* mutable_vote_address(int index);
  void set_vote_address(int index, const std::string& value);
  void set_vote_address(int index, std::string&& value);
  void set_vote_address(int index, const char* value);
  void set_vote_address(int index, const char* value, size_t size);
  std::string* add_vote_address();
  void add_vote_address(const std::string& value);
  void add_vote_address(std::string&& value);
  void add_vote_address(const char* value);
  void add_vote_address(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vote_address() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vote_address();
  private:
  const std::string& _internal_vote_address(int index) const;
  std::string* _internal_add_vote_address();
  public:

  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bool support = 3;
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // int32 count = 5;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.VoteAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vote_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  bool support_;
  int32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class VoteWitnessContract_Vote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.VoteWitnessContract.Vote) */ {
 public:
  inline VoteWitnessContract_Vote() : VoteWitnessContract_Vote(nullptr) {}
  ~VoteWitnessContract_Vote() override;
  explicit constexpr VoteWitnessContract_Vote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteWitnessContract_Vote(const VoteWitnessContract_Vote& from);
  VoteWitnessContract_Vote(VoteWitnessContract_Vote&& from) noexcept
    : VoteWitnessContract_Vote() {
    *this = ::std::move(from);
  }

  inline VoteWitnessContract_Vote& operator=(const VoteWitnessContract_Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteWitnessContract_Vote& operator=(VoteWitnessContract_Vote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteWitnessContract_Vote& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteWitnessContract_Vote* internal_default_instance() {
    return reinterpret_cast<const VoteWitnessContract_Vote*>(
               &_VoteWitnessContract_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VoteWitnessContract_Vote& a, VoteWitnessContract_Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteWitnessContract_Vote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteWitnessContract_Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteWitnessContract_Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteWitnessContract_Vote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteWitnessContract_Vote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteWitnessContract_Vote& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteWitnessContract_Vote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.VoteWitnessContract.Vote";
  }
  protected:
  explicit VoteWitnessContract_Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteAddressFieldNumber = 1,
    kVoteCountFieldNumber = 2,
  };
  // string vote_address = 1;
  void clear_vote_address();
  const std::string& vote_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vote_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vote_address();
  PROTOBUF_NODISCARD std::string* release_vote_address();
  void set_allocated_vote_address(std::string* vote_address);
  private:
  const std::string& _internal_vote_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_address(const std::string& value);
  std::string* _internal_mutable_vote_address();
  public:

  // int64 vote_count = 2;
  void clear_vote_count();
  int64_t vote_count() const;
  void set_vote_count(int64_t value);
  private:
  int64_t _internal_vote_count() const;
  void _internal_set_vote_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.VoteWitnessContract.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_address_;
  int64_t vote_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class VoteWitnessContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.VoteWitnessContract) */ {
 public:
  inline VoteWitnessContract() : VoteWitnessContract(nullptr) {}
  ~VoteWitnessContract() override;
  explicit constexpr VoteWitnessContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteWitnessContract(const VoteWitnessContract& from);
  VoteWitnessContract(VoteWitnessContract&& from) noexcept
    : VoteWitnessContract() {
    *this = ::std::move(from);
  }

  inline VoteWitnessContract& operator=(const VoteWitnessContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteWitnessContract& operator=(VoteWitnessContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteWitnessContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteWitnessContract* internal_default_instance() {
    return reinterpret_cast<const VoteWitnessContract*>(
               &_VoteWitnessContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VoteWitnessContract& a, VoteWitnessContract& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteWitnessContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteWitnessContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteWitnessContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteWitnessContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteWitnessContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteWitnessContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteWitnessContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.VoteWitnessContract";
  }
  protected:
  explicit VoteWitnessContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VoteWitnessContract_Vote Vote;

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 2,
    kOwnerAddressFieldNumber = 1,
    kSupportFieldNumber = 3,
  };
  // repeated .TW.Tron.Proto.VoteWitnessContract.Vote votes = 2;
  int votes_size() const;
  private:
  int _internal_votes_size() const;
  public:
  void clear_votes();
  ::TW::Tron::Proto::VoteWitnessContract_Vote* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Tron::Proto::VoteWitnessContract_Vote >*
      mutable_votes();
  private:
  const ::TW::Tron::Proto::VoteWitnessContract_Vote& _internal_votes(int index) const;
  ::TW::Tron::Proto::VoteWitnessContract_Vote* _internal_add_votes();
  public:
  const ::TW::Tron::Proto::VoteWitnessContract_Vote& votes(int index) const;
  ::TW::Tron::Proto::VoteWitnessContract_Vote* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Tron::Proto::VoteWitnessContract_Vote >&
      votes() const;

  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bool support = 3;
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.VoteWitnessContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Tron::Proto::VoteWitnessContract_Vote > votes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  bool support_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class WithdrawBalanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.WithdrawBalanceContract) */ {
 public:
  inline WithdrawBalanceContract() : WithdrawBalanceContract(nullptr) {}
  ~WithdrawBalanceContract() override;
  explicit constexpr WithdrawBalanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WithdrawBalanceContract(const WithdrawBalanceContract& from);
  WithdrawBalanceContract(WithdrawBalanceContract&& from) noexcept
    : WithdrawBalanceContract() {
    *this = ::std::move(from);
  }

  inline WithdrawBalanceContract& operator=(const WithdrawBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithdrawBalanceContract& operator=(WithdrawBalanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithdrawBalanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WithdrawBalanceContract* internal_default_instance() {
    return reinterpret_cast<const WithdrawBalanceContract*>(
               &_WithdrawBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WithdrawBalanceContract& a, WithdrawBalanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WithdrawBalanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithdrawBalanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithdrawBalanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WithdrawBalanceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WithdrawBalanceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WithdrawBalanceContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WithdrawBalanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.WithdrawBalanceContract";
  }
  protected:
  explicit WithdrawBalanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.WithdrawBalanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class TriggerSmartContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.TriggerSmartContract) */ {
 public:
  inline TriggerSmartContract() : TriggerSmartContract(nullptr) {}
  ~TriggerSmartContract() override;
  explicit constexpr TriggerSmartContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerSmartContract(const TriggerSmartContract& from);
  TriggerSmartContract(TriggerSmartContract&& from) noexcept
    : TriggerSmartContract() {
    *this = ::std::move(from);
  }

  inline TriggerSmartContract& operator=(const TriggerSmartContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerSmartContract& operator=(TriggerSmartContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerSmartContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerSmartContract* internal_default_instance() {
    return reinterpret_cast<const TriggerSmartContract*>(
               &_TriggerSmartContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TriggerSmartContract& a, TriggerSmartContract& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerSmartContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerSmartContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerSmartContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerSmartContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriggerSmartContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TriggerSmartContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerSmartContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.TriggerSmartContract";
  }
  protected:
  explicit TriggerSmartContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kContractAddressFieldNumber = 2,
    kDataFieldNumber = 4,
    kCallValueFieldNumber = 3,
    kCallTokenValueFieldNumber = 5,
    kTokenIdFieldNumber = 6,
  };
  // string owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string contract_address = 2;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 call_value = 3;
  void clear_call_value();
  int64_t call_value() const;
  void set_call_value(int64_t value);
  private:
  int64_t _internal_call_value() const;
  void _internal_set_call_value(int64_t value);
  public:

  // int64 call_token_value = 5;
  void clear_call_token_value();
  int64_t call_token_value() const;
  void set_call_token_value(int64_t value);
  private:
  int64_t _internal_call_token_value() const;
  void _internal_set_call_token_value(int64_t value);
  public:

  // int64 token_id = 6;
  void clear_token_id();
  int64_t token_id() const;
  void set_token_id(int64_t value);
  private:
  int64_t _internal_token_id() const;
  void _internal_set_token_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.TriggerSmartContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int64_t call_value_;
  int64_t call_token_value_;
  int64_t token_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {}
  ~BlockHeader() override;
  explicit constexpr BlockHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeader(const BlockHeader& from);
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.BlockHeader";
  }
  protected:
  explicit BlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxTrieRootFieldNumber = 2,
    kParentHashFieldNumber = 3,
    kWitnessAddressFieldNumber = 9,
    kTimestampFieldNumber = 1,
    kNumberFieldNumber = 7,
    kVersionFieldNumber = 10,
  };
  // bytes tx_trie_root = 2;
  void clear_tx_trie_root();
  const std::string& tx_trie_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_trie_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_trie_root();
  PROTOBUF_NODISCARD std::string* release_tx_trie_root();
  void set_allocated_tx_trie_root(std::string* tx_trie_root);
  private:
  const std::string& _internal_tx_trie_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_trie_root(const std::string& value);
  std::string* _internal_mutable_tx_trie_root();
  public:

  // bytes parent_hash = 3;
  void clear_parent_hash();
  const std::string& parent_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_hash();
  PROTOBUF_NODISCARD std::string* release_parent_hash();
  void set_allocated_parent_hash(std::string* parent_hash);
  private:
  const std::string& _internal_parent_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_hash(const std::string& value);
  std::string* _internal_mutable_parent_hash();
  public:

  // bytes witness_address = 9;
  void clear_witness_address();
  const std::string& witness_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_witness_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_witness_address();
  PROTOBUF_NODISCARD std::string* release_witness_address();
  void set_allocated_witness_address(std::string* witness_address);
  private:
  const std::string& _internal_witness_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness_address(const std::string& value);
  std::string* _internal_mutable_witness_address();
  public:

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 number = 7;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // int32 version = 10;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.BlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_trie_root_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr witness_address_;
  int64_t timestamp_;
  int64_t number_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit constexpr Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  enum ContractOneofCase {
    kTransfer = 10,
    kTransferAsset = 11,
    kFreezeBalance = 12,
    kUnfreezeBalance = 13,
    kUnfreezeAsset = 14,
    kWithdrawBalance = 15,
    kVoteAsset = 16,
    kVoteWitness = 17,
    kTriggerSmartContract = 18,
    kTransferTrc20Contract = 19,
    kFreezeBalanceV2 = 20,
    kUnfreezeBalanceV2 = 21,
    kWithdrawExpireUnfreeze = 23,
    kDelegateResource = 24,
    kUndelegateResource = 25,
    CONTRACT_ONEOF_NOT_SET = 0,
  };

  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHeaderFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kExpirationFieldNumber = 2,
    kFeeLimitFieldNumber = 4,
    kTransferFieldNumber = 10,
    kTransferAssetFieldNumber = 11,
    kFreezeBalanceFieldNumber = 12,
    kUnfreezeBalanceFieldNumber = 13,
    kUnfreezeAssetFieldNumber = 14,
    kWithdrawBalanceFieldNumber = 15,
    kVoteAssetFieldNumber = 16,
    kVoteWitnessFieldNumber = 17,
    kTriggerSmartContractFieldNumber = 18,
    kTransferTrc20ContractFieldNumber = 19,
    kFreezeBalanceV2FieldNumber = 20,
    kUnfreezeBalanceV2FieldNumber = 21,
    kWithdrawExpireUnfreezeFieldNumber = 23,
    kDelegateResourceFieldNumber = 24,
    kUndelegateResourceFieldNumber = 25,
  };
  // .TW.Tron.Proto.BlockHeader block_header = 3;
  bool has_block_header() const;
  private:
  bool _internal_has_block_header() const;
  public:
  void clear_block_header();
  const ::TW::Tron::Proto::BlockHeader& block_header() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::BlockHeader* release_block_header();
  ::TW::Tron::Proto::BlockHeader* mutable_block_header();
  void set_allocated_block_header(::TW::Tron::Proto::BlockHeader* block_header);
  private:
  const ::TW::Tron::Proto::BlockHeader& _internal_block_header() const;
  ::TW::Tron::Proto::BlockHeader* _internal_mutable_block_header();
  public:
  void unsafe_arena_set_allocated_block_header(
      ::TW::Tron::Proto::BlockHeader* block_header);
  ::TW::Tron::Proto::BlockHeader* unsafe_arena_release_block_header();

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 expiration = 2;
  void clear_expiration();
  int64_t expiration() const;
  void set_expiration(int64_t value);
  private:
  int64_t _internal_expiration() const;
  void _internal_set_expiration(int64_t value);
  public:

  // int64 fee_limit = 4;
  void clear_fee_limit();
  int64_t fee_limit() const;
  void set_fee_limit(int64_t value);
  private:
  int64_t _internal_fee_limit() const;
  void _internal_set_fee_limit(int64_t value);
  public:

  // .TW.Tron.Proto.TransferContract transfer = 10;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::TW::Tron::Proto::TransferContract& transfer() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::TransferContract* release_transfer();
  ::TW::Tron::Proto::TransferContract* mutable_transfer();
  void set_allocated_transfer(::TW::Tron::Proto::TransferContract* transfer);
  private:
  const ::TW::Tron::Proto::TransferContract& _internal_transfer() const;
  ::TW::Tron::Proto::TransferContract* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::TW::Tron::Proto::TransferContract* transfer);
  ::TW::Tron::Proto::TransferContract* unsafe_arena_release_transfer();

  // .TW.Tron.Proto.TransferAssetContract transfer_asset = 11;
  bool has_transfer_asset() const;
  private:
  bool _internal_has_transfer_asset() const;
  public:
  void clear_transfer_asset();
  const ::TW::Tron::Proto::TransferAssetContract& transfer_asset() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::TransferAssetContract* release_transfer_asset();
  ::TW::Tron::Proto::TransferAssetContract* mutable_transfer_asset();
  void set_allocated_transfer_asset(::TW::Tron::Proto::TransferAssetContract* transfer_asset);
  private:
  const ::TW::Tron::Proto::TransferAssetContract& _internal_transfer_asset() const;
  ::TW::Tron::Proto::TransferAssetContract* _internal_mutable_transfer_asset();
  public:
  void unsafe_arena_set_allocated_transfer_asset(
      ::TW::Tron::Proto::TransferAssetContract* transfer_asset);
  ::TW::Tron::Proto::TransferAssetContract* unsafe_arena_release_transfer_asset();

  // .TW.Tron.Proto.FreezeBalanceContract freeze_balance = 12;
  bool has_freeze_balance() const;
  private:
  bool _internal_has_freeze_balance() const;
  public:
  void clear_freeze_balance();
  const ::TW::Tron::Proto::FreezeBalanceContract& freeze_balance() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::FreezeBalanceContract* release_freeze_balance();
  ::TW::Tron::Proto::FreezeBalanceContract* mutable_freeze_balance();
  void set_allocated_freeze_balance(::TW::Tron::Proto::FreezeBalanceContract* freeze_balance);
  private:
  const ::TW::Tron::Proto::FreezeBalanceContract& _internal_freeze_balance() const;
  ::TW::Tron::Proto::FreezeBalanceContract* _internal_mutable_freeze_balance();
  public:
  void unsafe_arena_set_allocated_freeze_balance(
      ::TW::Tron::Proto::FreezeBalanceContract* freeze_balance);
  ::TW::Tron::Proto::FreezeBalanceContract* unsafe_arena_release_freeze_balance();

  // .TW.Tron.Proto.UnfreezeBalanceContract unfreeze_balance = 13;
  bool has_unfreeze_balance() const;
  private:
  bool _internal_has_unfreeze_balance() const;
  public:
  void clear_unfreeze_balance();
  const ::TW::Tron::Proto::UnfreezeBalanceContract& unfreeze_balance() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::UnfreezeBalanceContract* release_unfreeze_balance();
  ::TW::Tron::Proto::UnfreezeBalanceContract* mutable_unfreeze_balance();
  void set_allocated_unfreeze_balance(::TW::Tron::Proto::UnfreezeBalanceContract* unfreeze_balance);
  private:
  const ::TW::Tron::Proto::UnfreezeBalanceContract& _internal_unfreeze_balance() const;
  ::TW::Tron::Proto::UnfreezeBalanceContract* _internal_mutable_unfreeze_balance();
  public:
  void unsafe_arena_set_allocated_unfreeze_balance(
      ::TW::Tron::Proto::UnfreezeBalanceContract* unfreeze_balance);
  ::TW::Tron::Proto::UnfreezeBalanceContract* unsafe_arena_release_unfreeze_balance();

  // .TW.Tron.Proto.UnfreezeAssetContract unfreeze_asset = 14;
  bool has_unfreeze_asset() const;
  private:
  bool _internal_has_unfreeze_asset() const;
  public:
  void clear_unfreeze_asset();
  const ::TW::Tron::Proto::UnfreezeAssetContract& unfreeze_asset() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::UnfreezeAssetContract* release_unfreeze_asset();
  ::TW::Tron::Proto::UnfreezeAssetContract* mutable_unfreeze_asset();
  void set_allocated_unfreeze_asset(::TW::Tron::Proto::UnfreezeAssetContract* unfreeze_asset);
  private:
  const ::TW::Tron::Proto::UnfreezeAssetContract& _internal_unfreeze_asset() const;
  ::TW::Tron::Proto::UnfreezeAssetContract* _internal_mutable_unfreeze_asset();
  public:
  void unsafe_arena_set_allocated_unfreeze_asset(
      ::TW::Tron::Proto::UnfreezeAssetContract* unfreeze_asset);
  ::TW::Tron::Proto::UnfreezeAssetContract* unsafe_arena_release_unfreeze_asset();

  // .TW.Tron.Proto.WithdrawBalanceContract withdraw_balance = 15;
  bool has_withdraw_balance() const;
  private:
  bool _internal_has_withdraw_balance() const;
  public:
  void clear_withdraw_balance();
  const ::TW::Tron::Proto::WithdrawBalanceContract& withdraw_balance() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::WithdrawBalanceContract* release_withdraw_balance();
  ::TW::Tron::Proto::WithdrawBalanceContract* mutable_withdraw_balance();
  void set_allocated_withdraw_balance(::TW::Tron::Proto::WithdrawBalanceContract* withdraw_balance);
  private:
  const ::TW::Tron::Proto::WithdrawBalanceContract& _internal_withdraw_balance() const;
  ::TW::Tron::Proto::WithdrawBalanceContract* _internal_mutable_withdraw_balance();
  public:
  void unsafe_arena_set_allocated_withdraw_balance(
      ::TW::Tron::Proto::WithdrawBalanceContract* withdraw_balance);
  ::TW::Tron::Proto::WithdrawBalanceContract* unsafe_arena_release_withdraw_balance();

  // .TW.Tron.Proto.VoteAssetContract vote_asset = 16;
  bool has_vote_asset() const;
  private:
  bool _internal_has_vote_asset() const;
  public:
  void clear_vote_asset();
  const ::TW::Tron::Proto::VoteAssetContract& vote_asset() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::VoteAssetContract* release_vote_asset();
  ::TW::Tron::Proto::VoteAssetContract* mutable_vote_asset();
  void set_allocated_vote_asset(::TW::Tron::Proto::VoteAssetContract* vote_asset);
  private:
  const ::TW::Tron::Proto::VoteAssetContract& _internal_vote_asset() const;
  ::TW::Tron::Proto::VoteAssetContract* _internal_mutable_vote_asset();
  public:
  void unsafe_arena_set_allocated_vote_asset(
      ::TW::Tron::Proto::VoteAssetContract* vote_asset);
  ::TW::Tron::Proto::VoteAssetContract* unsafe_arena_release_vote_asset();

  // .TW.Tron.Proto.VoteWitnessContract vote_witness = 17;
  bool has_vote_witness() const;
  private:
  bool _internal_has_vote_witness() const;
  public:
  void clear_vote_witness();
  const ::TW::Tron::Proto::VoteWitnessContract& vote_witness() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::VoteWitnessContract* release_vote_witness();
  ::TW::Tron::Proto::VoteWitnessContract* mutable_vote_witness();
  void set_allocated_vote_witness(::TW::Tron::Proto::VoteWitnessContract* vote_witness);
  private:
  const ::TW::Tron::Proto::VoteWitnessContract& _internal_vote_witness() const;
  ::TW::Tron::Proto::VoteWitnessContract* _internal_mutable_vote_witness();
  public:
  void unsafe_arena_set_allocated_vote_witness(
      ::TW::Tron::Proto::VoteWitnessContract* vote_witness);
  ::TW::Tron::Proto::VoteWitnessContract* unsafe_arena_release_vote_witness();

  // .TW.Tron.Proto.TriggerSmartContract trigger_smart_contract = 18;
  bool has_trigger_smart_contract() const;
  private:
  bool _internal_has_trigger_smart_contract() const;
  public:
  void clear_trigger_smart_contract();
  const ::TW::Tron::Proto::TriggerSmartContract& trigger_smart_contract() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::TriggerSmartContract* release_trigger_smart_contract();
  ::TW::Tron::Proto::TriggerSmartContract* mutable_trigger_smart_contract();
  void set_allocated_trigger_smart_contract(::TW::Tron::Proto::TriggerSmartContract* trigger_smart_contract);
  private:
  const ::TW::Tron::Proto::TriggerSmartContract& _internal_trigger_smart_contract() const;
  ::TW::Tron::Proto::TriggerSmartContract* _internal_mutable_trigger_smart_contract();
  public:
  void unsafe_arena_set_allocated_trigger_smart_contract(
      ::TW::Tron::Proto::TriggerSmartContract* trigger_smart_contract);
  ::TW::Tron::Proto::TriggerSmartContract* unsafe_arena_release_trigger_smart_contract();

  // .TW.Tron.Proto.TransferTRC20Contract transfer_trc20_contract = 19;
  bool has_transfer_trc20_contract() const;
  private:
  bool _internal_has_transfer_trc20_contract() const;
  public:
  void clear_transfer_trc20_contract();
  const ::TW::Tron::Proto::TransferTRC20Contract& transfer_trc20_contract() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::TransferTRC20Contract* release_transfer_trc20_contract();
  ::TW::Tron::Proto::TransferTRC20Contract* mutable_transfer_trc20_contract();
  void set_allocated_transfer_trc20_contract(::TW::Tron::Proto::TransferTRC20Contract* transfer_trc20_contract);
  private:
  const ::TW::Tron::Proto::TransferTRC20Contract& _internal_transfer_trc20_contract() const;
  ::TW::Tron::Proto::TransferTRC20Contract* _internal_mutable_transfer_trc20_contract();
  public:
  void unsafe_arena_set_allocated_transfer_trc20_contract(
      ::TW::Tron::Proto::TransferTRC20Contract* transfer_trc20_contract);
  ::TW::Tron::Proto::TransferTRC20Contract* unsafe_arena_release_transfer_trc20_contract();

  // .TW.Tron.Proto.FreezeBalanceV2Contract freeze_balance_v2 = 20;
  bool has_freeze_balance_v2() const;
  private:
  bool _internal_has_freeze_balance_v2() const;
  public:
  void clear_freeze_balance_v2();
  const ::TW::Tron::Proto::FreezeBalanceV2Contract& freeze_balance_v2() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::FreezeBalanceV2Contract* release_freeze_balance_v2();
  ::TW::Tron::Proto::FreezeBalanceV2Contract* mutable_freeze_balance_v2();
  void set_allocated_freeze_balance_v2(::TW::Tron::Proto::FreezeBalanceV2Contract* freeze_balance_v2);
  private:
  const ::TW::Tron::Proto::FreezeBalanceV2Contract& _internal_freeze_balance_v2() const;
  ::TW::Tron::Proto::FreezeBalanceV2Contract* _internal_mutable_freeze_balance_v2();
  public:
  void unsafe_arena_set_allocated_freeze_balance_v2(
      ::TW::Tron::Proto::FreezeBalanceV2Contract* freeze_balance_v2);
  ::TW::Tron::Proto::FreezeBalanceV2Contract* unsafe_arena_release_freeze_balance_v2();

  // .TW.Tron.Proto.UnfreezeBalanceV2Contract unfreeze_balance_v2 = 21;
  bool has_unfreeze_balance_v2() const;
  private:
  bool _internal_has_unfreeze_balance_v2() const;
  public:
  void clear_unfreeze_balance_v2();
  const ::TW::Tron::Proto::UnfreezeBalanceV2Contract& unfreeze_balance_v2() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::UnfreezeBalanceV2Contract* release_unfreeze_balance_v2();
  ::TW::Tron::Proto::UnfreezeBalanceV2Contract* mutable_unfreeze_balance_v2();
  void set_allocated_unfreeze_balance_v2(::TW::Tron::Proto::UnfreezeBalanceV2Contract* unfreeze_balance_v2);
  private:
  const ::TW::Tron::Proto::UnfreezeBalanceV2Contract& _internal_unfreeze_balance_v2() const;
  ::TW::Tron::Proto::UnfreezeBalanceV2Contract* _internal_mutable_unfreeze_balance_v2();
  public:
  void unsafe_arena_set_allocated_unfreeze_balance_v2(
      ::TW::Tron::Proto::UnfreezeBalanceV2Contract* unfreeze_balance_v2);
  ::TW::Tron::Proto::UnfreezeBalanceV2Contract* unsafe_arena_release_unfreeze_balance_v2();

  // .TW.Tron.Proto.WithdrawExpireUnfreezeContract withdraw_expire_unfreeze = 23;
  bool has_withdraw_expire_unfreeze() const;
  private:
  bool _internal_has_withdraw_expire_unfreeze() const;
  public:
  void clear_withdraw_expire_unfreeze();
  const ::TW::Tron::Proto::WithdrawExpireUnfreezeContract& withdraw_expire_unfreeze() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* release_withdraw_expire_unfreeze();
  ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* mutable_withdraw_expire_unfreeze();
  void set_allocated_withdraw_expire_unfreeze(::TW::Tron::Proto::WithdrawExpireUnfreezeContract* withdraw_expire_unfreeze);
  private:
  const ::TW::Tron::Proto::WithdrawExpireUnfreezeContract& _internal_withdraw_expire_unfreeze() const;
  ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* _internal_mutable_withdraw_expire_unfreeze();
  public:
  void unsafe_arena_set_allocated_withdraw_expire_unfreeze(
      ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* withdraw_expire_unfreeze);
  ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* unsafe_arena_release_withdraw_expire_unfreeze();

  // .TW.Tron.Proto.DelegateResourceContract delegate_resource = 24;
  bool has_delegate_resource() const;
  private:
  bool _internal_has_delegate_resource() const;
  public:
  void clear_delegate_resource();
  const ::TW::Tron::Proto::DelegateResourceContract& delegate_resource() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::DelegateResourceContract* release_delegate_resource();
  ::TW::Tron::Proto::DelegateResourceContract* mutable_delegate_resource();
  void set_allocated_delegate_resource(::TW::Tron::Proto::DelegateResourceContract* delegate_resource);
  private:
  const ::TW::Tron::Proto::DelegateResourceContract& _internal_delegate_resource() const;
  ::TW::Tron::Proto::DelegateResourceContract* _internal_mutable_delegate_resource();
  public:
  void unsafe_arena_set_allocated_delegate_resource(
      ::TW::Tron::Proto::DelegateResourceContract* delegate_resource);
  ::TW::Tron::Proto::DelegateResourceContract* unsafe_arena_release_delegate_resource();

  // .TW.Tron.Proto.UnDelegateResourceContract undelegate_resource = 25;
  bool has_undelegate_resource() const;
  private:
  bool _internal_has_undelegate_resource() const;
  public:
  void clear_undelegate_resource();
  const ::TW::Tron::Proto::UnDelegateResourceContract& undelegate_resource() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::UnDelegateResourceContract* release_undelegate_resource();
  ::TW::Tron::Proto::UnDelegateResourceContract* mutable_undelegate_resource();
  void set_allocated_undelegate_resource(::TW::Tron::Proto::UnDelegateResourceContract* undelegate_resource);
  private:
  const ::TW::Tron::Proto::UnDelegateResourceContract& _internal_undelegate_resource() const;
  ::TW::Tron::Proto::UnDelegateResourceContract* _internal_mutable_undelegate_resource();
  public:
  void unsafe_arena_set_allocated_undelegate_resource(
      ::TW::Tron::Proto::UnDelegateResourceContract* undelegate_resource);
  ::TW::Tron::Proto::UnDelegateResourceContract* unsafe_arena_release_undelegate_resource();

  void clear_contract_oneof();
  ContractOneofCase contract_oneof_case() const;
  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.Transaction)
 private:
  class _Internal;
  void set_has_transfer();
  void set_has_transfer_asset();
  void set_has_freeze_balance();
  void set_has_unfreeze_balance();
  void set_has_unfreeze_asset();
  void set_has_withdraw_balance();
  void set_has_vote_asset();
  void set_has_vote_witness();
  void set_has_trigger_smart_contract();
  void set_has_transfer_trc20_contract();
  void set_has_freeze_balance_v2();
  void set_has_unfreeze_balance_v2();
  void set_has_withdraw_expire_unfreeze();
  void set_has_delegate_resource();
  void set_has_undelegate_resource();

  inline bool has_contract_oneof() const;
  inline void clear_has_contract_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TW::Tron::Proto::BlockHeader* block_header_;
  int64_t timestamp_;
  int64_t expiration_;
  int64_t fee_limit_;
  union ContractOneofUnion {
    constexpr ContractOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::TW::Tron::Proto::TransferContract* transfer_;
    ::TW::Tron::Proto::TransferAssetContract* transfer_asset_;
    ::TW::Tron::Proto::FreezeBalanceContract* freeze_balance_;
    ::TW::Tron::Proto::UnfreezeBalanceContract* unfreeze_balance_;
    ::TW::Tron::Proto::UnfreezeAssetContract* unfreeze_asset_;
    ::TW::Tron::Proto::WithdrawBalanceContract* withdraw_balance_;
    ::TW::Tron::Proto::VoteAssetContract* vote_asset_;
    ::TW::Tron::Proto::VoteWitnessContract* vote_witness_;
    ::TW::Tron::Proto::TriggerSmartContract* trigger_smart_contract_;
    ::TW::Tron::Proto::TransferTRC20Contract* transfer_trc20_contract_;
    ::TW::Tron::Proto::FreezeBalanceV2Contract* freeze_balance_v2_;
    ::TW::Tron::Proto::UnfreezeBalanceV2Contract* unfreeze_balance_v2_;
    ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* withdraw_expire_unfreeze_;
    ::TW::Tron::Proto::DelegateResourceContract* delegate_resource_;
    ::TW::Tron::Proto::UnDelegateResourceContract* undelegate_resource_;
  } contract_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class SigningInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.SigningInput) */ {
 public:
  inline SigningInput() : SigningInput(nullptr) {}
  ~SigningInput() override;
  explicit constexpr SigningInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningInput(const SigningInput& from);
  SigningInput(SigningInput&& from) noexcept
    : SigningInput() {
    *this = ::std::move(from);
  }

  inline SigningInput& operator=(const SigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningInput& operator=(SigningInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningInput* internal_default_instance() {
    return reinterpret_cast<const SigningInput*>(
               &_SigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SigningInput& a, SigningInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.SigningInput";
  }
  protected:
  explicit SigningInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 2,
    kTxIdFieldNumber = 3,
    kTransactionFieldNumber = 1,
  };
  // bytes private_key = 2;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // string txId = 3;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_NODISCARD std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // .TW.Tron.Proto.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::TW::Tron::Proto::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::TW::Tron::Proto::Transaction* release_transaction();
  ::TW::Tron::Proto::Transaction* mutable_transaction();
  void set_allocated_transaction(::TW::Tron::Proto::Transaction* transaction);
  private:
  const ::TW::Tron::Proto::Transaction& _internal_transaction() const;
  ::TW::Tron::Proto::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::TW::Tron::Proto::Transaction* transaction);
  ::TW::Tron::Proto::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.SigningInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::TW::Tron::Proto::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// -------------------------------------------------------------------

class SigningOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Tron.Proto.SigningOutput) */ {
 public:
  inline SigningOutput() : SigningOutput(nullptr) {}
  ~SigningOutput() override;
  explicit constexpr SigningOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningOutput(const SigningOutput& from);
  SigningOutput(SigningOutput&& from) noexcept
    : SigningOutput() {
    *this = ::std::move(from);
  }

  inline SigningOutput& operator=(const SigningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningOutput& operator=(SigningOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningOutput* internal_default_instance() {
    return reinterpret_cast<const SigningOutput*>(
               &_SigningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SigningOutput& a, SigningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Tron.Proto.SigningOutput";
  }
  protected:
  explicit SigningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kRefBlockBytesFieldNumber = 3,
    kRefBlockHashFieldNumber = 4,
    kJsonFieldNumber = 5,
    kErrorMessageFieldNumber = 7,
    kErrorFieldNumber = 6,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes ref_block_bytes = 3;
  void clear_ref_block_bytes();
  const std::string& ref_block_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref_block_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref_block_bytes();
  PROTOBUF_NODISCARD std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(std::string* ref_block_bytes);
  private:
  const std::string& _internal_ref_block_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_block_bytes(const std::string& value);
  std::string* _internal_mutable_ref_block_bytes();
  public:

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  const std::string& ref_block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref_block_hash();
  PROTOBUF_NODISCARD std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(std::string* ref_block_hash);
  private:
  const std::string& _internal_ref_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_block_hash(const std::string& value);
  std::string* _internal_mutable_ref_block_hash();
  public:

  // string json = 5;
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // string error_message = 7;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .TW.Common.Proto.SigningError error = 6;
  void clear_error();
  ::TW::Common::Proto::SigningError error() const;
  void set_error(::TW::Common::Proto::SigningError value);
  private:
  ::TW::Common::Proto::SigningError _internal_error() const;
  void _internal_set_error(::TW::Common::Proto::SigningError value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Tron.Proto.SigningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_block_bytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_block_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Tron_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransferContract

// string owner_address = 1;
inline void TransferContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& TransferContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferContract.owner_address)
}
inline std::string* TransferContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferContract.owner_address)
  return _s;
}
inline const std::string& TransferContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void TransferContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferContract.owner_address)
}

// string to_address = 2;
inline void TransferContract::clear_to_address() {
  to_address_.ClearToEmpty();
}
inline const std::string& TransferContract::to_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferContract.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferContract::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferContract.to_address)
}
inline std::string* TransferContract::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferContract.to_address)
  return _s;
}
inline const std::string& TransferContract::_internal_to_address() const {
  return to_address_.Get();
}
inline void TransferContract::_internal_set_to_address(const std::string& value) {
  
  to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferContract::_internal_mutable_to_address() {
  
  return to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferContract::release_to_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferContract.to_address)
  return to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferContract::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferContract.to_address)
}

// int64 amount = 3;
inline void TransferContract::clear_amount() {
  amount_ = int64_t{0};
}
inline int64_t TransferContract::_internal_amount() const {
  return amount_;
}
inline int64_t TransferContract::amount() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferContract.amount)
  return _internal_amount();
}
inline void TransferContract::_internal_set_amount(int64_t value) {
  
  amount_ = value;
}
inline void TransferContract::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferContract.amount)
}

// -------------------------------------------------------------------

// TransferAssetContract

// string asset_name = 1;
inline void TransferAssetContract::clear_asset_name() {
  asset_name_.ClearToEmpty();
}
inline const std::string& TransferAssetContract::asset_name() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferAssetContract.asset_name)
  return _internal_asset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAssetContract::set_asset_name(ArgT0&& arg0, ArgT... args) {
 
 asset_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferAssetContract.asset_name)
}
inline std::string* TransferAssetContract::mutable_asset_name() {
  std::string* _s = _internal_mutable_asset_name();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferAssetContract.asset_name)
  return _s;
}
inline const std::string& TransferAssetContract::_internal_asset_name() const {
  return asset_name_.Get();
}
inline void TransferAssetContract::_internal_set_asset_name(const std::string& value) {
  
  asset_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::_internal_mutable_asset_name() {
  
  return asset_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::release_asset_name() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferAssetContract.asset_name)
  return asset_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferAssetContract::set_allocated_asset_name(std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  asset_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferAssetContract.asset_name)
}

// string owner_address = 2;
inline void TransferAssetContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& TransferAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferAssetContract.owner_address)
}
inline std::string* TransferAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferAssetContract.owner_address)
  return _s;
}
inline const std::string& TransferAssetContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void TransferAssetContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferAssetContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferAssetContract.owner_address)
}

// string to_address = 3;
inline void TransferAssetContract::clear_to_address() {
  to_address_.ClearToEmpty();
}
inline const std::string& TransferAssetContract::to_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferAssetContract.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAssetContract::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferAssetContract.to_address)
}
inline std::string* TransferAssetContract::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferAssetContract.to_address)
  return _s;
}
inline const std::string& TransferAssetContract::_internal_to_address() const {
  return to_address_.Get();
}
inline void TransferAssetContract::_internal_set_to_address(const std::string& value) {
  
  to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::_internal_mutable_to_address() {
  
  return to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::release_to_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferAssetContract.to_address)
  return to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferAssetContract::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferAssetContract.to_address)
}

// int64 amount = 4;
inline void TransferAssetContract::clear_amount() {
  amount_ = int64_t{0};
}
inline int64_t TransferAssetContract::_internal_amount() const {
  return amount_;
}
inline int64_t TransferAssetContract::amount() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferAssetContract.amount)
  return _internal_amount();
}
inline void TransferAssetContract::_internal_set_amount(int64_t value) {
  
  amount_ = value;
}
inline void TransferAssetContract::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferAssetContract.amount)
}

// -------------------------------------------------------------------

// TransferTRC20Contract

// string contract_address = 1;
inline void TransferTRC20Contract::clear_contract_address() {
  contract_address_.ClearToEmpty();
}
inline const std::string& TransferTRC20Contract::contract_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferTRC20Contract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferTRC20Contract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferTRC20Contract.contract_address)
}
inline std::string* TransferTRC20Contract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferTRC20Contract.contract_address)
  return _s;
}
inline const std::string& TransferTRC20Contract::_internal_contract_address() const {
  return contract_address_.Get();
}
inline void TransferTRC20Contract::_internal_set_contract_address(const std::string& value) {
  
  contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::_internal_mutable_contract_address() {
  
  return contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::release_contract_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferTRC20Contract.contract_address)
  return contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferTRC20Contract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferTRC20Contract.contract_address)
}

// string owner_address = 2;
inline void TransferTRC20Contract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& TransferTRC20Contract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferTRC20Contract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferTRC20Contract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferTRC20Contract.owner_address)
}
inline std::string* TransferTRC20Contract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferTRC20Contract.owner_address)
  return _s;
}
inline const std::string& TransferTRC20Contract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void TransferTRC20Contract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferTRC20Contract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferTRC20Contract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferTRC20Contract.owner_address)
}

// string to_address = 3;
inline void TransferTRC20Contract::clear_to_address() {
  to_address_.ClearToEmpty();
}
inline const std::string& TransferTRC20Contract::to_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferTRC20Contract.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferTRC20Contract::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferTRC20Contract.to_address)
}
inline std::string* TransferTRC20Contract::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferTRC20Contract.to_address)
  return _s;
}
inline const std::string& TransferTRC20Contract::_internal_to_address() const {
  return to_address_.Get();
}
inline void TransferTRC20Contract::_internal_set_to_address(const std::string& value) {
  
  to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::_internal_mutable_to_address() {
  
  return to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::release_to_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferTRC20Contract.to_address)
  return to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferTRC20Contract::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferTRC20Contract.to_address)
}

// bytes amount = 4;
inline void TransferTRC20Contract::clear_amount() {
  amount_.ClearToEmpty();
}
inline const std::string& TransferTRC20Contract::amount() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TransferTRC20Contract.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferTRC20Contract::set_amount(ArgT0&& arg0, ArgT... args) {
 
 amount_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TransferTRC20Contract.amount)
}
inline std::string* TransferTRC20Contract::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TransferTRC20Contract.amount)
  return _s;
}
inline const std::string& TransferTRC20Contract::_internal_amount() const {
  return amount_.Get();
}
inline void TransferTRC20Contract::_internal_set_amount(const std::string& value) {
  
  amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::_internal_mutable_amount() {
  
  return amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferTRC20Contract::release_amount() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TransferTRC20Contract.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferTRC20Contract::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amount_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TransferTRC20Contract.amount)
}

// -------------------------------------------------------------------

// FreezeBalanceContract

// string owner_address = 1;
inline void FreezeBalanceContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& FreezeBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceContract.owner_address)
}
inline std::string* FreezeBalanceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.FreezeBalanceContract.owner_address)
  return _s;
}
inline const std::string& FreezeBalanceContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void FreezeBalanceContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.FreezeBalanceContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FreezeBalanceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.FreezeBalanceContract.owner_address)
}

// int64 frozen_balance = 2;
inline void FreezeBalanceContract::clear_frozen_balance() {
  frozen_balance_ = int64_t{0};
}
inline int64_t FreezeBalanceContract::_internal_frozen_balance() const {
  return frozen_balance_;
}
inline int64_t FreezeBalanceContract::frozen_balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceContract.frozen_balance)
  return _internal_frozen_balance();
}
inline void FreezeBalanceContract::_internal_set_frozen_balance(int64_t value) {
  
  frozen_balance_ = value;
}
inline void FreezeBalanceContract::set_frozen_balance(int64_t value) {
  _internal_set_frozen_balance(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceContract.frozen_balance)
}

// int64 frozen_duration = 3;
inline void FreezeBalanceContract::clear_frozen_duration() {
  frozen_duration_ = int64_t{0};
}
inline int64_t FreezeBalanceContract::_internal_frozen_duration() const {
  return frozen_duration_;
}
inline int64_t FreezeBalanceContract::frozen_duration() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceContract.frozen_duration)
  return _internal_frozen_duration();
}
inline void FreezeBalanceContract::_internal_set_frozen_duration(int64_t value) {
  
  frozen_duration_ = value;
}
inline void FreezeBalanceContract::set_frozen_duration(int64_t value) {
  _internal_set_frozen_duration(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceContract.frozen_duration)
}

// string resource = 10;
inline void FreezeBalanceContract::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& FreezeBalanceContract::resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceContract.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceContract::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceContract.resource)
}
inline std::string* FreezeBalanceContract::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.FreezeBalanceContract.resource)
  return _s;
}
inline const std::string& FreezeBalanceContract::_internal_resource() const {
  return resource_.Get();
}
inline void FreezeBalanceContract::_internal_set_resource(const std::string& value) {
  
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::_internal_mutable_resource() {
  
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::release_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.FreezeBalanceContract.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FreezeBalanceContract::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.FreezeBalanceContract.resource)
}

// string receiver_address = 15;
inline void FreezeBalanceContract::clear_receiver_address() {
  receiver_address_.ClearToEmpty();
}
inline const std::string& FreezeBalanceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceContract.receiver_address)
}
inline std::string* FreezeBalanceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.FreezeBalanceContract.receiver_address)
  return _s;
}
inline const std::string& FreezeBalanceContract::_internal_receiver_address() const {
  return receiver_address_.Get();
}
inline void FreezeBalanceContract::_internal_set_receiver_address(const std::string& value) {
  
  receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::_internal_mutable_receiver_address() {
  
  return receiver_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.FreezeBalanceContract.receiver_address)
  return receiver_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FreezeBalanceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  receiver_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receiver_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receiver_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.FreezeBalanceContract.receiver_address)
}

// -------------------------------------------------------------------

// FreezeBalanceV2Contract

// string owner_address = 1;
inline void FreezeBalanceV2Contract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& FreezeBalanceV2Contract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceV2Contract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceV2Contract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceV2Contract.owner_address)
}
inline std::string* FreezeBalanceV2Contract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.FreezeBalanceV2Contract.owner_address)
  return _s;
}
inline const std::string& FreezeBalanceV2Contract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void FreezeBalanceV2Contract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceV2Contract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FreezeBalanceV2Contract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.FreezeBalanceV2Contract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FreezeBalanceV2Contract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.FreezeBalanceV2Contract.owner_address)
}

// int64 frozen_balance = 2;
inline void FreezeBalanceV2Contract::clear_frozen_balance() {
  frozen_balance_ = int64_t{0};
}
inline int64_t FreezeBalanceV2Contract::_internal_frozen_balance() const {
  return frozen_balance_;
}
inline int64_t FreezeBalanceV2Contract::frozen_balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceV2Contract.frozen_balance)
  return _internal_frozen_balance();
}
inline void FreezeBalanceV2Contract::_internal_set_frozen_balance(int64_t value) {
  
  frozen_balance_ = value;
}
inline void FreezeBalanceV2Contract::set_frozen_balance(int64_t value) {
  _internal_set_frozen_balance(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceV2Contract.frozen_balance)
}

// string resource = 3;
inline void FreezeBalanceV2Contract::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& FreezeBalanceV2Contract::resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.FreezeBalanceV2Contract.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceV2Contract::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.FreezeBalanceV2Contract.resource)
}
inline std::string* FreezeBalanceV2Contract::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.FreezeBalanceV2Contract.resource)
  return _s;
}
inline const std::string& FreezeBalanceV2Contract::_internal_resource() const {
  return resource_.Get();
}
inline void FreezeBalanceV2Contract::_internal_set_resource(const std::string& value) {
  
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceV2Contract::_internal_mutable_resource() {
  
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FreezeBalanceV2Contract::release_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.FreezeBalanceV2Contract.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FreezeBalanceV2Contract::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.FreezeBalanceV2Contract.resource)
}

// -------------------------------------------------------------------

// UnfreezeBalanceV2Contract

// string owner_address = 1;
inline void UnfreezeBalanceV2Contract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceV2Contract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeBalanceV2Contract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceV2Contract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeBalanceV2Contract.owner_address)
}
inline std::string* UnfreezeBalanceV2Contract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnfreezeBalanceV2Contract.owner_address)
  return _s;
}
inline const std::string& UnfreezeBalanceV2Contract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void UnfreezeBalanceV2Contract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceV2Contract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceV2Contract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnfreezeBalanceV2Contract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnfreezeBalanceV2Contract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnfreezeBalanceV2Contract.owner_address)
}

// int64 unfreeze_balance = 2;
inline void UnfreezeBalanceV2Contract::clear_unfreeze_balance() {
  unfreeze_balance_ = int64_t{0};
}
inline int64_t UnfreezeBalanceV2Contract::_internal_unfreeze_balance() const {
  return unfreeze_balance_;
}
inline int64_t UnfreezeBalanceV2Contract::unfreeze_balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeBalanceV2Contract.unfreeze_balance)
  return _internal_unfreeze_balance();
}
inline void UnfreezeBalanceV2Contract::_internal_set_unfreeze_balance(int64_t value) {
  
  unfreeze_balance_ = value;
}
inline void UnfreezeBalanceV2Contract::set_unfreeze_balance(int64_t value) {
  _internal_set_unfreeze_balance(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeBalanceV2Contract.unfreeze_balance)
}

// string resource = 3;
inline void UnfreezeBalanceV2Contract::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceV2Contract::resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeBalanceV2Contract.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceV2Contract::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeBalanceV2Contract.resource)
}
inline std::string* UnfreezeBalanceV2Contract::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnfreezeBalanceV2Contract.resource)
  return _s;
}
inline const std::string& UnfreezeBalanceV2Contract::_internal_resource() const {
  return resource_.Get();
}
inline void UnfreezeBalanceV2Contract::_internal_set_resource(const std::string& value) {
  
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceV2Contract::_internal_mutable_resource() {
  
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceV2Contract::release_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnfreezeBalanceV2Contract.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnfreezeBalanceV2Contract::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnfreezeBalanceV2Contract.resource)
}

// -------------------------------------------------------------------

// WithdrawExpireUnfreezeContract

// string owner_address = 1;
inline void WithdrawExpireUnfreezeContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& WithdrawExpireUnfreezeContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.WithdrawExpireUnfreezeContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WithdrawExpireUnfreezeContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.WithdrawExpireUnfreezeContract.owner_address)
}
inline std::string* WithdrawExpireUnfreezeContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.WithdrawExpireUnfreezeContract.owner_address)
  return _s;
}
inline const std::string& WithdrawExpireUnfreezeContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void WithdrawExpireUnfreezeContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WithdrawExpireUnfreezeContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WithdrawExpireUnfreezeContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.WithdrawExpireUnfreezeContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WithdrawExpireUnfreezeContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.WithdrawExpireUnfreezeContract.owner_address)
}

// -------------------------------------------------------------------

// DelegateResourceContract

// string owner_address = 1;
inline void DelegateResourceContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& DelegateResourceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.DelegateResourceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateResourceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.DelegateResourceContract.owner_address)
}
inline std::string* DelegateResourceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.DelegateResourceContract.owner_address)
  return _s;
}
inline const std::string& DelegateResourceContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void DelegateResourceContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.DelegateResourceContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegateResourceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.DelegateResourceContract.owner_address)
}

// string resource = 2;
inline void DelegateResourceContract::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& DelegateResourceContract::resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.DelegateResourceContract.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateResourceContract::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.DelegateResourceContract.resource)
}
inline std::string* DelegateResourceContract::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.DelegateResourceContract.resource)
  return _s;
}
inline const std::string& DelegateResourceContract::_internal_resource() const {
  return resource_.Get();
}
inline void DelegateResourceContract::_internal_set_resource(const std::string& value) {
  
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::_internal_mutable_resource() {
  
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::release_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.DelegateResourceContract.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegateResourceContract::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.DelegateResourceContract.resource)
}

// int64 balance = 3;
inline void DelegateResourceContract::clear_balance() {
  balance_ = int64_t{0};
}
inline int64_t DelegateResourceContract::_internal_balance() const {
  return balance_;
}
inline int64_t DelegateResourceContract::balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.DelegateResourceContract.balance)
  return _internal_balance();
}
inline void DelegateResourceContract::_internal_set_balance(int64_t value) {
  
  balance_ = value;
}
inline void DelegateResourceContract::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.DelegateResourceContract.balance)
}

// string receiver_address = 4;
inline void DelegateResourceContract::clear_receiver_address() {
  receiver_address_.ClearToEmpty();
}
inline const std::string& DelegateResourceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.DelegateResourceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateResourceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.DelegateResourceContract.receiver_address)
}
inline std::string* DelegateResourceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.DelegateResourceContract.receiver_address)
  return _s;
}
inline const std::string& DelegateResourceContract::_internal_receiver_address() const {
  return receiver_address_.Get();
}
inline void DelegateResourceContract::_internal_set_receiver_address(const std::string& value) {
  
  receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::_internal_mutable_receiver_address() {
  
  return receiver_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.DelegateResourceContract.receiver_address)
  return receiver_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegateResourceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  receiver_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receiver_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receiver_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.DelegateResourceContract.receiver_address)
}

// bool lock = 5;
inline void DelegateResourceContract::clear_lock() {
  lock_ = false;
}
inline bool DelegateResourceContract::_internal_lock() const {
  return lock_;
}
inline bool DelegateResourceContract::lock() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.DelegateResourceContract.lock)
  return _internal_lock();
}
inline void DelegateResourceContract::_internal_set_lock(bool value) {
  
  lock_ = value;
}
inline void DelegateResourceContract::set_lock(bool value) {
  _internal_set_lock(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.DelegateResourceContract.lock)
}

// -------------------------------------------------------------------

// UnDelegateResourceContract

// string owner_address = 1;
inline void UnDelegateResourceContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& UnDelegateResourceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnDelegateResourceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnDelegateResourceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnDelegateResourceContract.owner_address)
}
inline std::string* UnDelegateResourceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnDelegateResourceContract.owner_address)
  return _s;
}
inline const std::string& UnDelegateResourceContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void UnDelegateResourceContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnDelegateResourceContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnDelegateResourceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnDelegateResourceContract.owner_address)
}

// string resource = 2;
inline void UnDelegateResourceContract::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& UnDelegateResourceContract::resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnDelegateResourceContract.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnDelegateResourceContract::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnDelegateResourceContract.resource)
}
inline std::string* UnDelegateResourceContract::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnDelegateResourceContract.resource)
  return _s;
}
inline const std::string& UnDelegateResourceContract::_internal_resource() const {
  return resource_.Get();
}
inline void UnDelegateResourceContract::_internal_set_resource(const std::string& value) {
  
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::_internal_mutable_resource() {
  
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::release_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnDelegateResourceContract.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnDelegateResourceContract::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnDelegateResourceContract.resource)
}

// int64 balance = 3;
inline void UnDelegateResourceContract::clear_balance() {
  balance_ = int64_t{0};
}
inline int64_t UnDelegateResourceContract::_internal_balance() const {
  return balance_;
}
inline int64_t UnDelegateResourceContract::balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnDelegateResourceContract.balance)
  return _internal_balance();
}
inline void UnDelegateResourceContract::_internal_set_balance(int64_t value) {
  
  balance_ = value;
}
inline void UnDelegateResourceContract::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnDelegateResourceContract.balance)
}

// string receiver_address = 4;
inline void UnDelegateResourceContract::clear_receiver_address() {
  receiver_address_.ClearToEmpty();
}
inline const std::string& UnDelegateResourceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnDelegateResourceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnDelegateResourceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnDelegateResourceContract.receiver_address)
}
inline std::string* UnDelegateResourceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnDelegateResourceContract.receiver_address)
  return _s;
}
inline const std::string& UnDelegateResourceContract::_internal_receiver_address() const {
  return receiver_address_.Get();
}
inline void UnDelegateResourceContract::_internal_set_receiver_address(const std::string& value) {
  
  receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::_internal_mutable_receiver_address() {
  
  return receiver_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnDelegateResourceContract.receiver_address)
  return receiver_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnDelegateResourceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  receiver_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receiver_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receiver_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnDelegateResourceContract.receiver_address)
}

// -------------------------------------------------------------------

// UnfreezeBalanceContract

// string owner_address = 1;
inline void UnfreezeBalanceContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeBalanceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeBalanceContract.owner_address)
}
inline std::string* UnfreezeBalanceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnfreezeBalanceContract.owner_address)
  return _s;
}
inline const std::string& UnfreezeBalanceContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void UnfreezeBalanceContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnfreezeBalanceContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnfreezeBalanceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnfreezeBalanceContract.owner_address)
}

// string resource = 10;
inline void UnfreezeBalanceContract::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceContract::resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeBalanceContract.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceContract::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeBalanceContract.resource)
}
inline std::string* UnfreezeBalanceContract::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnfreezeBalanceContract.resource)
  return _s;
}
inline const std::string& UnfreezeBalanceContract::_internal_resource() const {
  return resource_.Get();
}
inline void UnfreezeBalanceContract::_internal_set_resource(const std::string& value) {
  
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::_internal_mutable_resource() {
  
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::release_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnfreezeBalanceContract.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnfreezeBalanceContract::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnfreezeBalanceContract.resource)
}

// string receiver_address = 15;
inline void UnfreezeBalanceContract::clear_receiver_address() {
  receiver_address_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeBalanceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeBalanceContract.receiver_address)
}
inline std::string* UnfreezeBalanceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnfreezeBalanceContract.receiver_address)
  return _s;
}
inline const std::string& UnfreezeBalanceContract::_internal_receiver_address() const {
  return receiver_address_.Get();
}
inline void UnfreezeBalanceContract::_internal_set_receiver_address(const std::string& value) {
  
  receiver_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::_internal_mutable_receiver_address() {
  
  return receiver_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnfreezeBalanceContract.receiver_address)
  return receiver_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnfreezeBalanceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  receiver_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receiver_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receiver_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnfreezeBalanceContract.receiver_address)
}

// -------------------------------------------------------------------

// UnfreezeAssetContract

// string owner_address = 1;
inline void UnfreezeAssetContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& UnfreezeAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.UnfreezeAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.UnfreezeAssetContract.owner_address)
}
inline std::string* UnfreezeAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.UnfreezeAssetContract.owner_address)
  return _s;
}
inline const std::string& UnfreezeAssetContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void UnfreezeAssetContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnfreezeAssetContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnfreezeAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.UnfreezeAssetContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnfreezeAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.UnfreezeAssetContract.owner_address)
}

// -------------------------------------------------------------------

// VoteAssetContract

// string owner_address = 1;
inline void VoteAssetContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& VoteAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteAssetContract.owner_address)
}
inline std::string* VoteAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.VoteAssetContract.owner_address)
  return _s;
}
inline const std::string& VoteAssetContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void VoteAssetContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteAssetContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.VoteAssetContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.VoteAssetContract.owner_address)
}

// repeated string vote_address = 2;
inline int VoteAssetContract::_internal_vote_address_size() const {
  return vote_address_.size();
}
inline int VoteAssetContract::vote_address_size() const {
  return _internal_vote_address_size();
}
inline void VoteAssetContract::clear_vote_address() {
  vote_address_.Clear();
}
inline std::string* VoteAssetContract::add_vote_address() {
  std::string* _s = _internal_add_vote_address();
  // @@protoc_insertion_point(field_add_mutable:TW.Tron.Proto.VoteAssetContract.vote_address)
  return _s;
}
inline const std::string& VoteAssetContract::_internal_vote_address(int index) const {
  return vote_address_.Get(index);
}
inline const std::string& VoteAssetContract::vote_address(int index) const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteAssetContract.vote_address)
  return _internal_vote_address(index);
}
inline std::string* VoteAssetContract::mutable_vote_address(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.VoteAssetContract.vote_address)
  return vote_address_.Mutable(index);
}
inline void VoteAssetContract::set_vote_address(int index, const std::string& value) {
  vote_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::set_vote_address(int index, std::string&& value) {
  vote_address_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::set_vote_address(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vote_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::set_vote_address(int index, const char* value, size_t size) {
  vote_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline std::string* VoteAssetContract::_internal_add_vote_address() {
  return vote_address_.Add();
}
inline void VoteAssetContract::add_vote_address(const std::string& value) {
  vote_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::add_vote_address(std::string&& value) {
  vote_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::add_vote_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vote_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::add_vote_address(const char* value, size_t size) {
  vote_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TW.Tron.Proto.VoteAssetContract.vote_address)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VoteAssetContract::vote_address() const {
  // @@protoc_insertion_point(field_list:TW.Tron.Proto.VoteAssetContract.vote_address)
  return vote_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VoteAssetContract::mutable_vote_address() {
  // @@protoc_insertion_point(field_mutable_list:TW.Tron.Proto.VoteAssetContract.vote_address)
  return &vote_address_;
}

// bool support = 3;
inline void VoteAssetContract::clear_support() {
  support_ = false;
}
inline bool VoteAssetContract::_internal_support() const {
  return support_;
}
inline bool VoteAssetContract::support() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteAssetContract.support)
  return _internal_support();
}
inline void VoteAssetContract::_internal_set_support(bool value) {
  
  support_ = value;
}
inline void VoteAssetContract::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteAssetContract.support)
}

// int32 count = 5;
inline void VoteAssetContract::clear_count() {
  count_ = 0;
}
inline int32_t VoteAssetContract::_internal_count() const {
  return count_;
}
inline int32_t VoteAssetContract::count() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteAssetContract.count)
  return _internal_count();
}
inline void VoteAssetContract::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void VoteAssetContract::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteAssetContract.count)
}

// -------------------------------------------------------------------

// VoteWitnessContract_Vote

// string vote_address = 1;
inline void VoteWitnessContract_Vote::clear_vote_address() {
  vote_address_.ClearToEmpty();
}
inline const std::string& VoteWitnessContract_Vote::vote_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteWitnessContract.Vote.vote_address)
  return _internal_vote_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteWitnessContract_Vote::set_vote_address(ArgT0&& arg0, ArgT... args) {
 
 vote_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteWitnessContract.Vote.vote_address)
}
inline std::string* VoteWitnessContract_Vote::mutable_vote_address() {
  std::string* _s = _internal_mutable_vote_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.VoteWitnessContract.Vote.vote_address)
  return _s;
}
inline const std::string& VoteWitnessContract_Vote::_internal_vote_address() const {
  return vote_address_.Get();
}
inline void VoteWitnessContract_Vote::_internal_set_vote_address(const std::string& value) {
  
  vote_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteWitnessContract_Vote::_internal_mutable_vote_address() {
  
  return vote_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteWitnessContract_Vote::release_vote_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.VoteWitnessContract.Vote.vote_address)
  return vote_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteWitnessContract_Vote::set_allocated_vote_address(std::string* vote_address) {
  if (vote_address != nullptr) {
    
  } else {
    
  }
  vote_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vote_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vote_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vote_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.VoteWitnessContract.Vote.vote_address)
}

// int64 vote_count = 2;
inline void VoteWitnessContract_Vote::clear_vote_count() {
  vote_count_ = int64_t{0};
}
inline int64_t VoteWitnessContract_Vote::_internal_vote_count() const {
  return vote_count_;
}
inline int64_t VoteWitnessContract_Vote::vote_count() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteWitnessContract.Vote.vote_count)
  return _internal_vote_count();
}
inline void VoteWitnessContract_Vote::_internal_set_vote_count(int64_t value) {
  
  vote_count_ = value;
}
inline void VoteWitnessContract_Vote::set_vote_count(int64_t value) {
  _internal_set_vote_count(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteWitnessContract.Vote.vote_count)
}

// -------------------------------------------------------------------

// VoteWitnessContract

// string owner_address = 1;
inline void VoteWitnessContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& VoteWitnessContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteWitnessContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteWitnessContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteWitnessContract.owner_address)
}
inline std::string* VoteWitnessContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.VoteWitnessContract.owner_address)
  return _s;
}
inline const std::string& VoteWitnessContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void VoteWitnessContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteWitnessContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteWitnessContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.VoteWitnessContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteWitnessContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.VoteWitnessContract.owner_address)
}

// repeated .TW.Tron.Proto.VoteWitnessContract.Vote votes = 2;
inline int VoteWitnessContract::_internal_votes_size() const {
  return votes_.size();
}
inline int VoteWitnessContract::votes_size() const {
  return _internal_votes_size();
}
inline void VoteWitnessContract::clear_votes() {
  votes_.Clear();
}
inline ::TW::Tron::Proto::VoteWitnessContract_Vote* VoteWitnessContract::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.VoteWitnessContract.votes)
  return votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Tron::Proto::VoteWitnessContract_Vote >*
VoteWitnessContract::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:TW.Tron.Proto.VoteWitnessContract.votes)
  return &votes_;
}
inline const ::TW::Tron::Proto::VoteWitnessContract_Vote& VoteWitnessContract::_internal_votes(int index) const {
  return votes_.Get(index);
}
inline const ::TW::Tron::Proto::VoteWitnessContract_Vote& VoteWitnessContract::votes(int index) const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteWitnessContract.votes)
  return _internal_votes(index);
}
inline ::TW::Tron::Proto::VoteWitnessContract_Vote* VoteWitnessContract::_internal_add_votes() {
  return votes_.Add();
}
inline ::TW::Tron::Proto::VoteWitnessContract_Vote* VoteWitnessContract::add_votes() {
  ::TW::Tron::Proto::VoteWitnessContract_Vote* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:TW.Tron.Proto.VoteWitnessContract.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Tron::Proto::VoteWitnessContract_Vote >&
VoteWitnessContract::votes() const {
  // @@protoc_insertion_point(field_list:TW.Tron.Proto.VoteWitnessContract.votes)
  return votes_;
}

// bool support = 3;
inline void VoteWitnessContract::clear_support() {
  support_ = false;
}
inline bool VoteWitnessContract::_internal_support() const {
  return support_;
}
inline bool VoteWitnessContract::support() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.VoteWitnessContract.support)
  return _internal_support();
}
inline void VoteWitnessContract::_internal_set_support(bool value) {
  
  support_ = value;
}
inline void VoteWitnessContract::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.VoteWitnessContract.support)
}

// -------------------------------------------------------------------

// WithdrawBalanceContract

// string owner_address = 1;
inline void WithdrawBalanceContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& WithdrawBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.WithdrawBalanceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WithdrawBalanceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.WithdrawBalanceContract.owner_address)
}
inline std::string* WithdrawBalanceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.WithdrawBalanceContract.owner_address)
  return _s;
}
inline const std::string& WithdrawBalanceContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void WithdrawBalanceContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WithdrawBalanceContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WithdrawBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.WithdrawBalanceContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WithdrawBalanceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.WithdrawBalanceContract.owner_address)
}

// -------------------------------------------------------------------

// TriggerSmartContract

// string owner_address = 1;
inline void TriggerSmartContract::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& TriggerSmartContract::owner_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TriggerSmartContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerSmartContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TriggerSmartContract.owner_address)
}
inline std::string* TriggerSmartContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TriggerSmartContract.owner_address)
  return _s;
}
inline const std::string& TriggerSmartContract::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void TriggerSmartContract::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TriggerSmartContract.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TriggerSmartContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TriggerSmartContract.owner_address)
}

// string contract_address = 2;
inline void TriggerSmartContract::clear_contract_address() {
  contract_address_.ClearToEmpty();
}
inline const std::string& TriggerSmartContract::contract_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TriggerSmartContract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerSmartContract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TriggerSmartContract.contract_address)
}
inline std::string* TriggerSmartContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TriggerSmartContract.contract_address)
  return _s;
}
inline const std::string& TriggerSmartContract::_internal_contract_address() const {
  return contract_address_.Get();
}
inline void TriggerSmartContract::_internal_set_contract_address(const std::string& value) {
  
  contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::_internal_mutable_contract_address() {
  
  return contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TriggerSmartContract.contract_address)
  return contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TriggerSmartContract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TriggerSmartContract.contract_address)
}

// int64 call_value = 3;
inline void TriggerSmartContract::clear_call_value() {
  call_value_ = int64_t{0};
}
inline int64_t TriggerSmartContract::_internal_call_value() const {
  return call_value_;
}
inline int64_t TriggerSmartContract::call_value() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TriggerSmartContract.call_value)
  return _internal_call_value();
}
inline void TriggerSmartContract::_internal_set_call_value(int64_t value) {
  
  call_value_ = value;
}
inline void TriggerSmartContract::set_call_value(int64_t value) {
  _internal_set_call_value(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TriggerSmartContract.call_value)
}

// bytes data = 4;
inline void TriggerSmartContract::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& TriggerSmartContract::data() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TriggerSmartContract.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerSmartContract::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TriggerSmartContract.data)
}
inline std::string* TriggerSmartContract::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.TriggerSmartContract.data)
  return _s;
}
inline const std::string& TriggerSmartContract::_internal_data() const {
  return data_.Get();
}
inline void TriggerSmartContract::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::release_data() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.TriggerSmartContract.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TriggerSmartContract::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.TriggerSmartContract.data)
}

// int64 call_token_value = 5;
inline void TriggerSmartContract::clear_call_token_value() {
  call_token_value_ = int64_t{0};
}
inline int64_t TriggerSmartContract::_internal_call_token_value() const {
  return call_token_value_;
}
inline int64_t TriggerSmartContract::call_token_value() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TriggerSmartContract.call_token_value)
  return _internal_call_token_value();
}
inline void TriggerSmartContract::_internal_set_call_token_value(int64_t value) {
  
  call_token_value_ = value;
}
inline void TriggerSmartContract::set_call_token_value(int64_t value) {
  _internal_set_call_token_value(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TriggerSmartContract.call_token_value)
}

// int64 token_id = 6;
inline void TriggerSmartContract::clear_token_id() {
  token_id_ = int64_t{0};
}
inline int64_t TriggerSmartContract::_internal_token_id() const {
  return token_id_;
}
inline int64_t TriggerSmartContract::token_id() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.TriggerSmartContract.token_id)
  return _internal_token_id();
}
inline void TriggerSmartContract::_internal_set_token_id(int64_t value) {
  
  token_id_ = value;
}
inline void TriggerSmartContract::set_token_id(int64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.TriggerSmartContract.token_id)
}

// -------------------------------------------------------------------

// BlockHeader

// int64 timestamp = 1;
inline void BlockHeader::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t BlockHeader::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t BlockHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.BlockHeader.timestamp)
  return _internal_timestamp();
}
inline void BlockHeader::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void BlockHeader::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.BlockHeader.timestamp)
}

// bytes tx_trie_root = 2;
inline void BlockHeader::clear_tx_trie_root() {
  tx_trie_root_.ClearToEmpty();
}
inline const std::string& BlockHeader::tx_trie_root() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.BlockHeader.tx_trie_root)
  return _internal_tx_trie_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_tx_trie_root(ArgT0&& arg0, ArgT... args) {
 
 tx_trie_root_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.BlockHeader.tx_trie_root)
}
inline std::string* BlockHeader::mutable_tx_trie_root() {
  std::string* _s = _internal_mutable_tx_trie_root();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.BlockHeader.tx_trie_root)
  return _s;
}
inline const std::string& BlockHeader::_internal_tx_trie_root() const {
  return tx_trie_root_.Get();
}
inline void BlockHeader::_internal_set_tx_trie_root(const std::string& value) {
  
  tx_trie_root_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_tx_trie_root() {
  
  return tx_trie_root_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader::release_tx_trie_root() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.BlockHeader.tx_trie_root)
  return tx_trie_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader::set_allocated_tx_trie_root(std::string* tx_trie_root) {
  if (tx_trie_root != nullptr) {
    
  } else {
    
  }
  tx_trie_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx_trie_root,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_trie_root_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_trie_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.BlockHeader.tx_trie_root)
}

// bytes parent_hash = 3;
inline void BlockHeader::clear_parent_hash() {
  parent_hash_.ClearToEmpty();
}
inline const std::string& BlockHeader::parent_hash() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.BlockHeader.parent_hash)
  return _internal_parent_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_parent_hash(ArgT0&& arg0, ArgT... args) {
 
 parent_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.BlockHeader.parent_hash)
}
inline std::string* BlockHeader::mutable_parent_hash() {
  std::string* _s = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.BlockHeader.parent_hash)
  return _s;
}
inline const std::string& BlockHeader::_internal_parent_hash() const {
  return parent_hash_.Get();
}
inline void BlockHeader::_internal_set_parent_hash(const std::string& value) {
  
  parent_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_parent_hash() {
  
  return parent_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader::release_parent_hash() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.BlockHeader.parent_hash)
  return parent_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader::set_allocated_parent_hash(std::string* parent_hash) {
  if (parent_hash != nullptr) {
    
  } else {
    
  }
  parent_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.BlockHeader.parent_hash)
}

// int64 number = 7;
inline void BlockHeader::clear_number() {
  number_ = int64_t{0};
}
inline int64_t BlockHeader::_internal_number() const {
  return number_;
}
inline int64_t BlockHeader::number() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.BlockHeader.number)
  return _internal_number();
}
inline void BlockHeader::_internal_set_number(int64_t value) {
  
  number_ = value;
}
inline void BlockHeader::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.BlockHeader.number)
}

// bytes witness_address = 9;
inline void BlockHeader::clear_witness_address() {
  witness_address_.ClearToEmpty();
}
inline const std::string& BlockHeader::witness_address() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.BlockHeader.witness_address)
  return _internal_witness_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_witness_address(ArgT0&& arg0, ArgT... args) {
 
 witness_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.BlockHeader.witness_address)
}
inline std::string* BlockHeader::mutable_witness_address() {
  std::string* _s = _internal_mutable_witness_address();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.BlockHeader.witness_address)
  return _s;
}
inline const std::string& BlockHeader::_internal_witness_address() const {
  return witness_address_.Get();
}
inline void BlockHeader::_internal_set_witness_address(const std::string& value) {
  
  witness_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_witness_address() {
  
  return witness_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader::release_witness_address() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.BlockHeader.witness_address)
  return witness_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader::set_allocated_witness_address(std::string* witness_address) {
  if (witness_address != nullptr) {
    
  } else {
    
  }
  witness_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), witness_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (witness_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    witness_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.BlockHeader.witness_address)
}

// int32 version = 10;
inline void BlockHeader::clear_version() {
  version_ = 0;
}
inline int32_t BlockHeader::_internal_version() const {
  return version_;
}
inline int32_t BlockHeader::version() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.BlockHeader.version)
  return _internal_version();
}
inline void BlockHeader::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void BlockHeader::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.BlockHeader.version)
}

// -------------------------------------------------------------------

// Transaction

// int64 timestamp = 1;
inline void Transaction::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t Transaction::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.timestamp)
  return _internal_timestamp();
}
inline void Transaction::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void Transaction::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.Transaction.timestamp)
}

// int64 expiration = 2;
inline void Transaction::clear_expiration() {
  expiration_ = int64_t{0};
}
inline int64_t Transaction::_internal_expiration() const {
  return expiration_;
}
inline int64_t Transaction::expiration() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.expiration)
  return _internal_expiration();
}
inline void Transaction::_internal_set_expiration(int64_t value) {
  
  expiration_ = value;
}
inline void Transaction::set_expiration(int64_t value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.Transaction.expiration)
}

// .TW.Tron.Proto.BlockHeader block_header = 3;
inline bool Transaction::_internal_has_block_header() const {
  return this != internal_default_instance() && block_header_ != nullptr;
}
inline bool Transaction::has_block_header() const {
  return _internal_has_block_header();
}
inline void Transaction::clear_block_header() {
  if (GetArenaForAllocation() == nullptr && block_header_ != nullptr) {
    delete block_header_;
  }
  block_header_ = nullptr;
}
inline const ::TW::Tron::Proto::BlockHeader& Transaction::_internal_block_header() const {
  const ::TW::Tron::Proto::BlockHeader* p = block_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Tron::Proto::BlockHeader&>(
      ::TW::Tron::Proto::_BlockHeader_default_instance_);
}
inline const ::TW::Tron::Proto::BlockHeader& Transaction::block_header() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.block_header)
  return _internal_block_header();
}
inline void Transaction::unsafe_arena_set_allocated_block_header(
    ::TW::Tron::Proto::BlockHeader* block_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_header_);
  }
  block_header_ = block_header;
  if (block_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.block_header)
}
inline ::TW::Tron::Proto::BlockHeader* Transaction::release_block_header() {
  
  ::TW::Tron::Proto::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Tron::Proto::BlockHeader* Transaction::unsafe_arena_release_block_header() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.block_header)
  
  ::TW::Tron::Proto::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
  return temp;
}
inline ::TW::Tron::Proto::BlockHeader* Transaction::_internal_mutable_block_header() {
  
  if (block_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Tron::Proto::BlockHeader>(GetArenaForAllocation());
    block_header_ = p;
  }
  return block_header_;
}
inline ::TW::Tron::Proto::BlockHeader* Transaction::mutable_block_header() {
  ::TW::Tron::Proto::BlockHeader* _msg = _internal_mutable_block_header();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.block_header)
  return _msg;
}
inline void Transaction::set_allocated_block_header(::TW::Tron::Proto::BlockHeader* block_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete block_header_;
  }
  if (block_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Tron::Proto::BlockHeader>::GetOwningArena(block_header);
    if (message_arena != submessage_arena) {
      block_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_header, submessage_arena);
    }
    
  } else {
    
  }
  block_header_ = block_header;
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.Transaction.block_header)
}

// int64 fee_limit = 4;
inline void Transaction::clear_fee_limit() {
  fee_limit_ = int64_t{0};
}
inline int64_t Transaction::_internal_fee_limit() const {
  return fee_limit_;
}
inline int64_t Transaction::fee_limit() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.fee_limit)
  return _internal_fee_limit();
}
inline void Transaction::_internal_set_fee_limit(int64_t value) {
  
  fee_limit_ = value;
}
inline void Transaction::set_fee_limit(int64_t value) {
  _internal_set_fee_limit(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.Transaction.fee_limit)
}

// .TW.Tron.Proto.TransferContract transfer = 10;
inline bool Transaction::_internal_has_transfer() const {
  return contract_oneof_case() == kTransfer;
}
inline bool Transaction::has_transfer() const {
  return _internal_has_transfer();
}
inline void Transaction::set_has_transfer() {
  _oneof_case_[0] = kTransfer;
}
inline void Transaction::clear_transfer() {
  if (_internal_has_transfer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.transfer_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::TransferContract* Transaction::release_transfer() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.transfer)
  if (_internal_has_transfer()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::TransferContract* temp = contract_oneof_.transfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::TransferContract& Transaction::_internal_transfer() const {
  return _internal_has_transfer()
      ? *contract_oneof_.transfer_
      : reinterpret_cast< ::TW::Tron::Proto::TransferContract&>(::TW::Tron::Proto::_TransferContract_default_instance_);
}
inline const ::TW::Tron::Proto::TransferContract& Transaction::transfer() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.transfer)
  return _internal_transfer();
}
inline ::TW::Tron::Proto::TransferContract* Transaction::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.transfer)
  if (_internal_has_transfer()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::TransferContract* temp = contract_oneof_.transfer_;
    contract_oneof_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_transfer(::TW::Tron::Proto::TransferContract* transfer) {
  clear_contract_oneof();
  if (transfer) {
    set_has_transfer();
    contract_oneof_.transfer_ = transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.transfer)
}
inline ::TW::Tron::Proto::TransferContract* Transaction::_internal_mutable_transfer() {
  if (!_internal_has_transfer()) {
    clear_contract_oneof();
    set_has_transfer();
    contract_oneof_.transfer_ = CreateMaybeMessage< ::TW::Tron::Proto::TransferContract >(GetArenaForAllocation());
  }
  return contract_oneof_.transfer_;
}
inline ::TW::Tron::Proto::TransferContract* Transaction::mutable_transfer() {
  ::TW::Tron::Proto::TransferContract* _msg = _internal_mutable_transfer();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.transfer)
  return _msg;
}

// .TW.Tron.Proto.TransferAssetContract transfer_asset = 11;
inline bool Transaction::_internal_has_transfer_asset() const {
  return contract_oneof_case() == kTransferAsset;
}
inline bool Transaction::has_transfer_asset() const {
  return _internal_has_transfer_asset();
}
inline void Transaction::set_has_transfer_asset() {
  _oneof_case_[0] = kTransferAsset;
}
inline void Transaction::clear_transfer_asset() {
  if (_internal_has_transfer_asset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.transfer_asset_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::TransferAssetContract* Transaction::release_transfer_asset() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.transfer_asset)
  if (_internal_has_transfer_asset()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::TransferAssetContract* temp = contract_oneof_.transfer_asset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.transfer_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::TransferAssetContract& Transaction::_internal_transfer_asset() const {
  return _internal_has_transfer_asset()
      ? *contract_oneof_.transfer_asset_
      : reinterpret_cast< ::TW::Tron::Proto::TransferAssetContract&>(::TW::Tron::Proto::_TransferAssetContract_default_instance_);
}
inline const ::TW::Tron::Proto::TransferAssetContract& Transaction::transfer_asset() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.transfer_asset)
  return _internal_transfer_asset();
}
inline ::TW::Tron::Proto::TransferAssetContract* Transaction::unsafe_arena_release_transfer_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.transfer_asset)
  if (_internal_has_transfer_asset()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::TransferAssetContract* temp = contract_oneof_.transfer_asset_;
    contract_oneof_.transfer_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_transfer_asset(::TW::Tron::Proto::TransferAssetContract* transfer_asset) {
  clear_contract_oneof();
  if (transfer_asset) {
    set_has_transfer_asset();
    contract_oneof_.transfer_asset_ = transfer_asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.transfer_asset)
}
inline ::TW::Tron::Proto::TransferAssetContract* Transaction::_internal_mutable_transfer_asset() {
  if (!_internal_has_transfer_asset()) {
    clear_contract_oneof();
    set_has_transfer_asset();
    contract_oneof_.transfer_asset_ = CreateMaybeMessage< ::TW::Tron::Proto::TransferAssetContract >(GetArenaForAllocation());
  }
  return contract_oneof_.transfer_asset_;
}
inline ::TW::Tron::Proto::TransferAssetContract* Transaction::mutable_transfer_asset() {
  ::TW::Tron::Proto::TransferAssetContract* _msg = _internal_mutable_transfer_asset();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.transfer_asset)
  return _msg;
}

// .TW.Tron.Proto.FreezeBalanceContract freeze_balance = 12;
inline bool Transaction::_internal_has_freeze_balance() const {
  return contract_oneof_case() == kFreezeBalance;
}
inline bool Transaction::has_freeze_balance() const {
  return _internal_has_freeze_balance();
}
inline void Transaction::set_has_freeze_balance() {
  _oneof_case_[0] = kFreezeBalance;
}
inline void Transaction::clear_freeze_balance() {
  if (_internal_has_freeze_balance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.freeze_balance_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::FreezeBalanceContract* Transaction::release_freeze_balance() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.freeze_balance)
  if (_internal_has_freeze_balance()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::FreezeBalanceContract* temp = contract_oneof_.freeze_balance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.freeze_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::FreezeBalanceContract& Transaction::_internal_freeze_balance() const {
  return _internal_has_freeze_balance()
      ? *contract_oneof_.freeze_balance_
      : reinterpret_cast< ::TW::Tron::Proto::FreezeBalanceContract&>(::TW::Tron::Proto::_FreezeBalanceContract_default_instance_);
}
inline const ::TW::Tron::Proto::FreezeBalanceContract& Transaction::freeze_balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.freeze_balance)
  return _internal_freeze_balance();
}
inline ::TW::Tron::Proto::FreezeBalanceContract* Transaction::unsafe_arena_release_freeze_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.freeze_balance)
  if (_internal_has_freeze_balance()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::FreezeBalanceContract* temp = contract_oneof_.freeze_balance_;
    contract_oneof_.freeze_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_freeze_balance(::TW::Tron::Proto::FreezeBalanceContract* freeze_balance) {
  clear_contract_oneof();
  if (freeze_balance) {
    set_has_freeze_balance();
    contract_oneof_.freeze_balance_ = freeze_balance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.freeze_balance)
}
inline ::TW::Tron::Proto::FreezeBalanceContract* Transaction::_internal_mutable_freeze_balance() {
  if (!_internal_has_freeze_balance()) {
    clear_contract_oneof();
    set_has_freeze_balance();
    contract_oneof_.freeze_balance_ = CreateMaybeMessage< ::TW::Tron::Proto::FreezeBalanceContract >(GetArenaForAllocation());
  }
  return contract_oneof_.freeze_balance_;
}
inline ::TW::Tron::Proto::FreezeBalanceContract* Transaction::mutable_freeze_balance() {
  ::TW::Tron::Proto::FreezeBalanceContract* _msg = _internal_mutable_freeze_balance();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.freeze_balance)
  return _msg;
}

// .TW.Tron.Proto.UnfreezeBalanceContract unfreeze_balance = 13;
inline bool Transaction::_internal_has_unfreeze_balance() const {
  return contract_oneof_case() == kUnfreezeBalance;
}
inline bool Transaction::has_unfreeze_balance() const {
  return _internal_has_unfreeze_balance();
}
inline void Transaction::set_has_unfreeze_balance() {
  _oneof_case_[0] = kUnfreezeBalance;
}
inline void Transaction::clear_unfreeze_balance() {
  if (_internal_has_unfreeze_balance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.unfreeze_balance_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::UnfreezeBalanceContract* Transaction::release_unfreeze_balance() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.unfreeze_balance)
  if (_internal_has_unfreeze_balance()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::UnfreezeBalanceContract* temp = contract_oneof_.unfreeze_balance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.unfreeze_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::UnfreezeBalanceContract& Transaction::_internal_unfreeze_balance() const {
  return _internal_has_unfreeze_balance()
      ? *contract_oneof_.unfreeze_balance_
      : reinterpret_cast< ::TW::Tron::Proto::UnfreezeBalanceContract&>(::TW::Tron::Proto::_UnfreezeBalanceContract_default_instance_);
}
inline const ::TW::Tron::Proto::UnfreezeBalanceContract& Transaction::unfreeze_balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.unfreeze_balance)
  return _internal_unfreeze_balance();
}
inline ::TW::Tron::Proto::UnfreezeBalanceContract* Transaction::unsafe_arena_release_unfreeze_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.unfreeze_balance)
  if (_internal_has_unfreeze_balance()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::UnfreezeBalanceContract* temp = contract_oneof_.unfreeze_balance_;
    contract_oneof_.unfreeze_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_unfreeze_balance(::TW::Tron::Proto::UnfreezeBalanceContract* unfreeze_balance) {
  clear_contract_oneof();
  if (unfreeze_balance) {
    set_has_unfreeze_balance();
    contract_oneof_.unfreeze_balance_ = unfreeze_balance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.unfreeze_balance)
}
inline ::TW::Tron::Proto::UnfreezeBalanceContract* Transaction::_internal_mutable_unfreeze_balance() {
  if (!_internal_has_unfreeze_balance()) {
    clear_contract_oneof();
    set_has_unfreeze_balance();
    contract_oneof_.unfreeze_balance_ = CreateMaybeMessage< ::TW::Tron::Proto::UnfreezeBalanceContract >(GetArenaForAllocation());
  }
  return contract_oneof_.unfreeze_balance_;
}
inline ::TW::Tron::Proto::UnfreezeBalanceContract* Transaction::mutable_unfreeze_balance() {
  ::TW::Tron::Proto::UnfreezeBalanceContract* _msg = _internal_mutable_unfreeze_balance();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.unfreeze_balance)
  return _msg;
}

// .TW.Tron.Proto.UnfreezeAssetContract unfreeze_asset = 14;
inline bool Transaction::_internal_has_unfreeze_asset() const {
  return contract_oneof_case() == kUnfreezeAsset;
}
inline bool Transaction::has_unfreeze_asset() const {
  return _internal_has_unfreeze_asset();
}
inline void Transaction::set_has_unfreeze_asset() {
  _oneof_case_[0] = kUnfreezeAsset;
}
inline void Transaction::clear_unfreeze_asset() {
  if (_internal_has_unfreeze_asset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.unfreeze_asset_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::UnfreezeAssetContract* Transaction::release_unfreeze_asset() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.unfreeze_asset)
  if (_internal_has_unfreeze_asset()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::UnfreezeAssetContract* temp = contract_oneof_.unfreeze_asset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.unfreeze_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::UnfreezeAssetContract& Transaction::_internal_unfreeze_asset() const {
  return _internal_has_unfreeze_asset()
      ? *contract_oneof_.unfreeze_asset_
      : reinterpret_cast< ::TW::Tron::Proto::UnfreezeAssetContract&>(::TW::Tron::Proto::_UnfreezeAssetContract_default_instance_);
}
inline const ::TW::Tron::Proto::UnfreezeAssetContract& Transaction::unfreeze_asset() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.unfreeze_asset)
  return _internal_unfreeze_asset();
}
inline ::TW::Tron::Proto::UnfreezeAssetContract* Transaction::unsafe_arena_release_unfreeze_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.unfreeze_asset)
  if (_internal_has_unfreeze_asset()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::UnfreezeAssetContract* temp = contract_oneof_.unfreeze_asset_;
    contract_oneof_.unfreeze_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_unfreeze_asset(::TW::Tron::Proto::UnfreezeAssetContract* unfreeze_asset) {
  clear_contract_oneof();
  if (unfreeze_asset) {
    set_has_unfreeze_asset();
    contract_oneof_.unfreeze_asset_ = unfreeze_asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.unfreeze_asset)
}
inline ::TW::Tron::Proto::UnfreezeAssetContract* Transaction::_internal_mutable_unfreeze_asset() {
  if (!_internal_has_unfreeze_asset()) {
    clear_contract_oneof();
    set_has_unfreeze_asset();
    contract_oneof_.unfreeze_asset_ = CreateMaybeMessage< ::TW::Tron::Proto::UnfreezeAssetContract >(GetArenaForAllocation());
  }
  return contract_oneof_.unfreeze_asset_;
}
inline ::TW::Tron::Proto::UnfreezeAssetContract* Transaction::mutable_unfreeze_asset() {
  ::TW::Tron::Proto::UnfreezeAssetContract* _msg = _internal_mutable_unfreeze_asset();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.unfreeze_asset)
  return _msg;
}

// .TW.Tron.Proto.WithdrawBalanceContract withdraw_balance = 15;
inline bool Transaction::_internal_has_withdraw_balance() const {
  return contract_oneof_case() == kWithdrawBalance;
}
inline bool Transaction::has_withdraw_balance() const {
  return _internal_has_withdraw_balance();
}
inline void Transaction::set_has_withdraw_balance() {
  _oneof_case_[0] = kWithdrawBalance;
}
inline void Transaction::clear_withdraw_balance() {
  if (_internal_has_withdraw_balance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.withdraw_balance_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::WithdrawBalanceContract* Transaction::release_withdraw_balance() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.withdraw_balance)
  if (_internal_has_withdraw_balance()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::WithdrawBalanceContract* temp = contract_oneof_.withdraw_balance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.withdraw_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::WithdrawBalanceContract& Transaction::_internal_withdraw_balance() const {
  return _internal_has_withdraw_balance()
      ? *contract_oneof_.withdraw_balance_
      : reinterpret_cast< ::TW::Tron::Proto::WithdrawBalanceContract&>(::TW::Tron::Proto::_WithdrawBalanceContract_default_instance_);
}
inline const ::TW::Tron::Proto::WithdrawBalanceContract& Transaction::withdraw_balance() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.withdraw_balance)
  return _internal_withdraw_balance();
}
inline ::TW::Tron::Proto::WithdrawBalanceContract* Transaction::unsafe_arena_release_withdraw_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.withdraw_balance)
  if (_internal_has_withdraw_balance()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::WithdrawBalanceContract* temp = contract_oneof_.withdraw_balance_;
    contract_oneof_.withdraw_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_withdraw_balance(::TW::Tron::Proto::WithdrawBalanceContract* withdraw_balance) {
  clear_contract_oneof();
  if (withdraw_balance) {
    set_has_withdraw_balance();
    contract_oneof_.withdraw_balance_ = withdraw_balance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.withdraw_balance)
}
inline ::TW::Tron::Proto::WithdrawBalanceContract* Transaction::_internal_mutable_withdraw_balance() {
  if (!_internal_has_withdraw_balance()) {
    clear_contract_oneof();
    set_has_withdraw_balance();
    contract_oneof_.withdraw_balance_ = CreateMaybeMessage< ::TW::Tron::Proto::WithdrawBalanceContract >(GetArenaForAllocation());
  }
  return contract_oneof_.withdraw_balance_;
}
inline ::TW::Tron::Proto::WithdrawBalanceContract* Transaction::mutable_withdraw_balance() {
  ::TW::Tron::Proto::WithdrawBalanceContract* _msg = _internal_mutable_withdraw_balance();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.withdraw_balance)
  return _msg;
}

// .TW.Tron.Proto.VoteAssetContract vote_asset = 16;
inline bool Transaction::_internal_has_vote_asset() const {
  return contract_oneof_case() == kVoteAsset;
}
inline bool Transaction::has_vote_asset() const {
  return _internal_has_vote_asset();
}
inline void Transaction::set_has_vote_asset() {
  _oneof_case_[0] = kVoteAsset;
}
inline void Transaction::clear_vote_asset() {
  if (_internal_has_vote_asset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.vote_asset_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::VoteAssetContract* Transaction::release_vote_asset() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.vote_asset)
  if (_internal_has_vote_asset()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::VoteAssetContract* temp = contract_oneof_.vote_asset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.vote_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::VoteAssetContract& Transaction::_internal_vote_asset() const {
  return _internal_has_vote_asset()
      ? *contract_oneof_.vote_asset_
      : reinterpret_cast< ::TW::Tron::Proto::VoteAssetContract&>(::TW::Tron::Proto::_VoteAssetContract_default_instance_);
}
inline const ::TW::Tron::Proto::VoteAssetContract& Transaction::vote_asset() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.vote_asset)
  return _internal_vote_asset();
}
inline ::TW::Tron::Proto::VoteAssetContract* Transaction::unsafe_arena_release_vote_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.vote_asset)
  if (_internal_has_vote_asset()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::VoteAssetContract* temp = contract_oneof_.vote_asset_;
    contract_oneof_.vote_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_vote_asset(::TW::Tron::Proto::VoteAssetContract* vote_asset) {
  clear_contract_oneof();
  if (vote_asset) {
    set_has_vote_asset();
    contract_oneof_.vote_asset_ = vote_asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.vote_asset)
}
inline ::TW::Tron::Proto::VoteAssetContract* Transaction::_internal_mutable_vote_asset() {
  if (!_internal_has_vote_asset()) {
    clear_contract_oneof();
    set_has_vote_asset();
    contract_oneof_.vote_asset_ = CreateMaybeMessage< ::TW::Tron::Proto::VoteAssetContract >(GetArenaForAllocation());
  }
  return contract_oneof_.vote_asset_;
}
inline ::TW::Tron::Proto::VoteAssetContract* Transaction::mutable_vote_asset() {
  ::TW::Tron::Proto::VoteAssetContract* _msg = _internal_mutable_vote_asset();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.vote_asset)
  return _msg;
}

// .TW.Tron.Proto.VoteWitnessContract vote_witness = 17;
inline bool Transaction::_internal_has_vote_witness() const {
  return contract_oneof_case() == kVoteWitness;
}
inline bool Transaction::has_vote_witness() const {
  return _internal_has_vote_witness();
}
inline void Transaction::set_has_vote_witness() {
  _oneof_case_[0] = kVoteWitness;
}
inline void Transaction::clear_vote_witness() {
  if (_internal_has_vote_witness()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.vote_witness_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::VoteWitnessContract* Transaction::release_vote_witness() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.vote_witness)
  if (_internal_has_vote_witness()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::VoteWitnessContract* temp = contract_oneof_.vote_witness_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.vote_witness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::VoteWitnessContract& Transaction::_internal_vote_witness() const {
  return _internal_has_vote_witness()
      ? *contract_oneof_.vote_witness_
      : reinterpret_cast< ::TW::Tron::Proto::VoteWitnessContract&>(::TW::Tron::Proto::_VoteWitnessContract_default_instance_);
}
inline const ::TW::Tron::Proto::VoteWitnessContract& Transaction::vote_witness() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.vote_witness)
  return _internal_vote_witness();
}
inline ::TW::Tron::Proto::VoteWitnessContract* Transaction::unsafe_arena_release_vote_witness() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.vote_witness)
  if (_internal_has_vote_witness()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::VoteWitnessContract* temp = contract_oneof_.vote_witness_;
    contract_oneof_.vote_witness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_vote_witness(::TW::Tron::Proto::VoteWitnessContract* vote_witness) {
  clear_contract_oneof();
  if (vote_witness) {
    set_has_vote_witness();
    contract_oneof_.vote_witness_ = vote_witness;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.vote_witness)
}
inline ::TW::Tron::Proto::VoteWitnessContract* Transaction::_internal_mutable_vote_witness() {
  if (!_internal_has_vote_witness()) {
    clear_contract_oneof();
    set_has_vote_witness();
    contract_oneof_.vote_witness_ = CreateMaybeMessage< ::TW::Tron::Proto::VoteWitnessContract >(GetArenaForAllocation());
  }
  return contract_oneof_.vote_witness_;
}
inline ::TW::Tron::Proto::VoteWitnessContract* Transaction::mutable_vote_witness() {
  ::TW::Tron::Proto::VoteWitnessContract* _msg = _internal_mutable_vote_witness();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.vote_witness)
  return _msg;
}

// .TW.Tron.Proto.TriggerSmartContract trigger_smart_contract = 18;
inline bool Transaction::_internal_has_trigger_smart_contract() const {
  return contract_oneof_case() == kTriggerSmartContract;
}
inline bool Transaction::has_trigger_smart_contract() const {
  return _internal_has_trigger_smart_contract();
}
inline void Transaction::set_has_trigger_smart_contract() {
  _oneof_case_[0] = kTriggerSmartContract;
}
inline void Transaction::clear_trigger_smart_contract() {
  if (_internal_has_trigger_smart_contract()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.trigger_smart_contract_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::TriggerSmartContract* Transaction::release_trigger_smart_contract() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.trigger_smart_contract)
  if (_internal_has_trigger_smart_contract()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::TriggerSmartContract* temp = contract_oneof_.trigger_smart_contract_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.trigger_smart_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::TriggerSmartContract& Transaction::_internal_trigger_smart_contract() const {
  return _internal_has_trigger_smart_contract()
      ? *contract_oneof_.trigger_smart_contract_
      : reinterpret_cast< ::TW::Tron::Proto::TriggerSmartContract&>(::TW::Tron::Proto::_TriggerSmartContract_default_instance_);
}
inline const ::TW::Tron::Proto::TriggerSmartContract& Transaction::trigger_smart_contract() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.trigger_smart_contract)
  return _internal_trigger_smart_contract();
}
inline ::TW::Tron::Proto::TriggerSmartContract* Transaction::unsafe_arena_release_trigger_smart_contract() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.trigger_smart_contract)
  if (_internal_has_trigger_smart_contract()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::TriggerSmartContract* temp = contract_oneof_.trigger_smart_contract_;
    contract_oneof_.trigger_smart_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_trigger_smart_contract(::TW::Tron::Proto::TriggerSmartContract* trigger_smart_contract) {
  clear_contract_oneof();
  if (trigger_smart_contract) {
    set_has_trigger_smart_contract();
    contract_oneof_.trigger_smart_contract_ = trigger_smart_contract;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.trigger_smart_contract)
}
inline ::TW::Tron::Proto::TriggerSmartContract* Transaction::_internal_mutable_trigger_smart_contract() {
  if (!_internal_has_trigger_smart_contract()) {
    clear_contract_oneof();
    set_has_trigger_smart_contract();
    contract_oneof_.trigger_smart_contract_ = CreateMaybeMessage< ::TW::Tron::Proto::TriggerSmartContract >(GetArenaForAllocation());
  }
  return contract_oneof_.trigger_smart_contract_;
}
inline ::TW::Tron::Proto::TriggerSmartContract* Transaction::mutable_trigger_smart_contract() {
  ::TW::Tron::Proto::TriggerSmartContract* _msg = _internal_mutable_trigger_smart_contract();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.trigger_smart_contract)
  return _msg;
}

// .TW.Tron.Proto.TransferTRC20Contract transfer_trc20_contract = 19;
inline bool Transaction::_internal_has_transfer_trc20_contract() const {
  return contract_oneof_case() == kTransferTrc20Contract;
}
inline bool Transaction::has_transfer_trc20_contract() const {
  return _internal_has_transfer_trc20_contract();
}
inline void Transaction::set_has_transfer_trc20_contract() {
  _oneof_case_[0] = kTransferTrc20Contract;
}
inline void Transaction::clear_transfer_trc20_contract() {
  if (_internal_has_transfer_trc20_contract()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.transfer_trc20_contract_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::TransferTRC20Contract* Transaction::release_transfer_trc20_contract() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.transfer_trc20_contract)
  if (_internal_has_transfer_trc20_contract()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::TransferTRC20Contract* temp = contract_oneof_.transfer_trc20_contract_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.transfer_trc20_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::TransferTRC20Contract& Transaction::_internal_transfer_trc20_contract() const {
  return _internal_has_transfer_trc20_contract()
      ? *contract_oneof_.transfer_trc20_contract_
      : reinterpret_cast< ::TW::Tron::Proto::TransferTRC20Contract&>(::TW::Tron::Proto::_TransferTRC20Contract_default_instance_);
}
inline const ::TW::Tron::Proto::TransferTRC20Contract& Transaction::transfer_trc20_contract() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.transfer_trc20_contract)
  return _internal_transfer_trc20_contract();
}
inline ::TW::Tron::Proto::TransferTRC20Contract* Transaction::unsafe_arena_release_transfer_trc20_contract() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.transfer_trc20_contract)
  if (_internal_has_transfer_trc20_contract()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::TransferTRC20Contract* temp = contract_oneof_.transfer_trc20_contract_;
    contract_oneof_.transfer_trc20_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_transfer_trc20_contract(::TW::Tron::Proto::TransferTRC20Contract* transfer_trc20_contract) {
  clear_contract_oneof();
  if (transfer_trc20_contract) {
    set_has_transfer_trc20_contract();
    contract_oneof_.transfer_trc20_contract_ = transfer_trc20_contract;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.transfer_trc20_contract)
}
inline ::TW::Tron::Proto::TransferTRC20Contract* Transaction::_internal_mutable_transfer_trc20_contract() {
  if (!_internal_has_transfer_trc20_contract()) {
    clear_contract_oneof();
    set_has_transfer_trc20_contract();
    contract_oneof_.transfer_trc20_contract_ = CreateMaybeMessage< ::TW::Tron::Proto::TransferTRC20Contract >(GetArenaForAllocation());
  }
  return contract_oneof_.transfer_trc20_contract_;
}
inline ::TW::Tron::Proto::TransferTRC20Contract* Transaction::mutable_transfer_trc20_contract() {
  ::TW::Tron::Proto::TransferTRC20Contract* _msg = _internal_mutable_transfer_trc20_contract();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.transfer_trc20_contract)
  return _msg;
}

// .TW.Tron.Proto.FreezeBalanceV2Contract freeze_balance_v2 = 20;
inline bool Transaction::_internal_has_freeze_balance_v2() const {
  return contract_oneof_case() == kFreezeBalanceV2;
}
inline bool Transaction::has_freeze_balance_v2() const {
  return _internal_has_freeze_balance_v2();
}
inline void Transaction::set_has_freeze_balance_v2() {
  _oneof_case_[0] = kFreezeBalanceV2;
}
inline void Transaction::clear_freeze_balance_v2() {
  if (_internal_has_freeze_balance_v2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.freeze_balance_v2_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::FreezeBalanceV2Contract* Transaction::release_freeze_balance_v2() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.freeze_balance_v2)
  if (_internal_has_freeze_balance_v2()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::FreezeBalanceV2Contract* temp = contract_oneof_.freeze_balance_v2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.freeze_balance_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::FreezeBalanceV2Contract& Transaction::_internal_freeze_balance_v2() const {
  return _internal_has_freeze_balance_v2()
      ? *contract_oneof_.freeze_balance_v2_
      : reinterpret_cast< ::TW::Tron::Proto::FreezeBalanceV2Contract&>(::TW::Tron::Proto::_FreezeBalanceV2Contract_default_instance_);
}
inline const ::TW::Tron::Proto::FreezeBalanceV2Contract& Transaction::freeze_balance_v2() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.freeze_balance_v2)
  return _internal_freeze_balance_v2();
}
inline ::TW::Tron::Proto::FreezeBalanceV2Contract* Transaction::unsafe_arena_release_freeze_balance_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.freeze_balance_v2)
  if (_internal_has_freeze_balance_v2()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::FreezeBalanceV2Contract* temp = contract_oneof_.freeze_balance_v2_;
    contract_oneof_.freeze_balance_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_freeze_balance_v2(::TW::Tron::Proto::FreezeBalanceV2Contract* freeze_balance_v2) {
  clear_contract_oneof();
  if (freeze_balance_v2) {
    set_has_freeze_balance_v2();
    contract_oneof_.freeze_balance_v2_ = freeze_balance_v2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.freeze_balance_v2)
}
inline ::TW::Tron::Proto::FreezeBalanceV2Contract* Transaction::_internal_mutable_freeze_balance_v2() {
  if (!_internal_has_freeze_balance_v2()) {
    clear_contract_oneof();
    set_has_freeze_balance_v2();
    contract_oneof_.freeze_balance_v2_ = CreateMaybeMessage< ::TW::Tron::Proto::FreezeBalanceV2Contract >(GetArenaForAllocation());
  }
  return contract_oneof_.freeze_balance_v2_;
}
inline ::TW::Tron::Proto::FreezeBalanceV2Contract* Transaction::mutable_freeze_balance_v2() {
  ::TW::Tron::Proto::FreezeBalanceV2Contract* _msg = _internal_mutable_freeze_balance_v2();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.freeze_balance_v2)
  return _msg;
}

// .TW.Tron.Proto.UnfreezeBalanceV2Contract unfreeze_balance_v2 = 21;
inline bool Transaction::_internal_has_unfreeze_balance_v2() const {
  return contract_oneof_case() == kUnfreezeBalanceV2;
}
inline bool Transaction::has_unfreeze_balance_v2() const {
  return _internal_has_unfreeze_balance_v2();
}
inline void Transaction::set_has_unfreeze_balance_v2() {
  _oneof_case_[0] = kUnfreezeBalanceV2;
}
inline void Transaction::clear_unfreeze_balance_v2() {
  if (_internal_has_unfreeze_balance_v2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.unfreeze_balance_v2_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::UnfreezeBalanceV2Contract* Transaction::release_unfreeze_balance_v2() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.unfreeze_balance_v2)
  if (_internal_has_unfreeze_balance_v2()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::UnfreezeBalanceV2Contract* temp = contract_oneof_.unfreeze_balance_v2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.unfreeze_balance_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::UnfreezeBalanceV2Contract& Transaction::_internal_unfreeze_balance_v2() const {
  return _internal_has_unfreeze_balance_v2()
      ? *contract_oneof_.unfreeze_balance_v2_
      : reinterpret_cast< ::TW::Tron::Proto::UnfreezeBalanceV2Contract&>(::TW::Tron::Proto::_UnfreezeBalanceV2Contract_default_instance_);
}
inline const ::TW::Tron::Proto::UnfreezeBalanceV2Contract& Transaction::unfreeze_balance_v2() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.unfreeze_balance_v2)
  return _internal_unfreeze_balance_v2();
}
inline ::TW::Tron::Proto::UnfreezeBalanceV2Contract* Transaction::unsafe_arena_release_unfreeze_balance_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.unfreeze_balance_v2)
  if (_internal_has_unfreeze_balance_v2()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::UnfreezeBalanceV2Contract* temp = contract_oneof_.unfreeze_balance_v2_;
    contract_oneof_.unfreeze_balance_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_unfreeze_balance_v2(::TW::Tron::Proto::UnfreezeBalanceV2Contract* unfreeze_balance_v2) {
  clear_contract_oneof();
  if (unfreeze_balance_v2) {
    set_has_unfreeze_balance_v2();
    contract_oneof_.unfreeze_balance_v2_ = unfreeze_balance_v2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.unfreeze_balance_v2)
}
inline ::TW::Tron::Proto::UnfreezeBalanceV2Contract* Transaction::_internal_mutable_unfreeze_balance_v2() {
  if (!_internal_has_unfreeze_balance_v2()) {
    clear_contract_oneof();
    set_has_unfreeze_balance_v2();
    contract_oneof_.unfreeze_balance_v2_ = CreateMaybeMessage< ::TW::Tron::Proto::UnfreezeBalanceV2Contract >(GetArenaForAllocation());
  }
  return contract_oneof_.unfreeze_balance_v2_;
}
inline ::TW::Tron::Proto::UnfreezeBalanceV2Contract* Transaction::mutable_unfreeze_balance_v2() {
  ::TW::Tron::Proto::UnfreezeBalanceV2Contract* _msg = _internal_mutable_unfreeze_balance_v2();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.unfreeze_balance_v2)
  return _msg;
}

// .TW.Tron.Proto.WithdrawExpireUnfreezeContract withdraw_expire_unfreeze = 23;
inline bool Transaction::_internal_has_withdraw_expire_unfreeze() const {
  return contract_oneof_case() == kWithdrawExpireUnfreeze;
}
inline bool Transaction::has_withdraw_expire_unfreeze() const {
  return _internal_has_withdraw_expire_unfreeze();
}
inline void Transaction::set_has_withdraw_expire_unfreeze() {
  _oneof_case_[0] = kWithdrawExpireUnfreeze;
}
inline void Transaction::clear_withdraw_expire_unfreeze() {
  if (_internal_has_withdraw_expire_unfreeze()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.withdraw_expire_unfreeze_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* Transaction::release_withdraw_expire_unfreeze() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.withdraw_expire_unfreeze)
  if (_internal_has_withdraw_expire_unfreeze()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* temp = contract_oneof_.withdraw_expire_unfreeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.withdraw_expire_unfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::WithdrawExpireUnfreezeContract& Transaction::_internal_withdraw_expire_unfreeze() const {
  return _internal_has_withdraw_expire_unfreeze()
      ? *contract_oneof_.withdraw_expire_unfreeze_
      : reinterpret_cast< ::TW::Tron::Proto::WithdrawExpireUnfreezeContract&>(::TW::Tron::Proto::_WithdrawExpireUnfreezeContract_default_instance_);
}
inline const ::TW::Tron::Proto::WithdrawExpireUnfreezeContract& Transaction::withdraw_expire_unfreeze() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.withdraw_expire_unfreeze)
  return _internal_withdraw_expire_unfreeze();
}
inline ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* Transaction::unsafe_arena_release_withdraw_expire_unfreeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.withdraw_expire_unfreeze)
  if (_internal_has_withdraw_expire_unfreeze()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* temp = contract_oneof_.withdraw_expire_unfreeze_;
    contract_oneof_.withdraw_expire_unfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_withdraw_expire_unfreeze(::TW::Tron::Proto::WithdrawExpireUnfreezeContract* withdraw_expire_unfreeze) {
  clear_contract_oneof();
  if (withdraw_expire_unfreeze) {
    set_has_withdraw_expire_unfreeze();
    contract_oneof_.withdraw_expire_unfreeze_ = withdraw_expire_unfreeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.withdraw_expire_unfreeze)
}
inline ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* Transaction::_internal_mutable_withdraw_expire_unfreeze() {
  if (!_internal_has_withdraw_expire_unfreeze()) {
    clear_contract_oneof();
    set_has_withdraw_expire_unfreeze();
    contract_oneof_.withdraw_expire_unfreeze_ = CreateMaybeMessage< ::TW::Tron::Proto::WithdrawExpireUnfreezeContract >(GetArenaForAllocation());
  }
  return contract_oneof_.withdraw_expire_unfreeze_;
}
inline ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* Transaction::mutable_withdraw_expire_unfreeze() {
  ::TW::Tron::Proto::WithdrawExpireUnfreezeContract* _msg = _internal_mutable_withdraw_expire_unfreeze();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.withdraw_expire_unfreeze)
  return _msg;
}

// .TW.Tron.Proto.DelegateResourceContract delegate_resource = 24;
inline bool Transaction::_internal_has_delegate_resource() const {
  return contract_oneof_case() == kDelegateResource;
}
inline bool Transaction::has_delegate_resource() const {
  return _internal_has_delegate_resource();
}
inline void Transaction::set_has_delegate_resource() {
  _oneof_case_[0] = kDelegateResource;
}
inline void Transaction::clear_delegate_resource() {
  if (_internal_has_delegate_resource()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.delegate_resource_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::DelegateResourceContract* Transaction::release_delegate_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.delegate_resource)
  if (_internal_has_delegate_resource()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::DelegateResourceContract* temp = contract_oneof_.delegate_resource_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.delegate_resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::DelegateResourceContract& Transaction::_internal_delegate_resource() const {
  return _internal_has_delegate_resource()
      ? *contract_oneof_.delegate_resource_
      : reinterpret_cast< ::TW::Tron::Proto::DelegateResourceContract&>(::TW::Tron::Proto::_DelegateResourceContract_default_instance_);
}
inline const ::TW::Tron::Proto::DelegateResourceContract& Transaction::delegate_resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.delegate_resource)
  return _internal_delegate_resource();
}
inline ::TW::Tron::Proto::DelegateResourceContract* Transaction::unsafe_arena_release_delegate_resource() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.delegate_resource)
  if (_internal_has_delegate_resource()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::DelegateResourceContract* temp = contract_oneof_.delegate_resource_;
    contract_oneof_.delegate_resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_delegate_resource(::TW::Tron::Proto::DelegateResourceContract* delegate_resource) {
  clear_contract_oneof();
  if (delegate_resource) {
    set_has_delegate_resource();
    contract_oneof_.delegate_resource_ = delegate_resource;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.delegate_resource)
}
inline ::TW::Tron::Proto::DelegateResourceContract* Transaction::_internal_mutable_delegate_resource() {
  if (!_internal_has_delegate_resource()) {
    clear_contract_oneof();
    set_has_delegate_resource();
    contract_oneof_.delegate_resource_ = CreateMaybeMessage< ::TW::Tron::Proto::DelegateResourceContract >(GetArenaForAllocation());
  }
  return contract_oneof_.delegate_resource_;
}
inline ::TW::Tron::Proto::DelegateResourceContract* Transaction::mutable_delegate_resource() {
  ::TW::Tron::Proto::DelegateResourceContract* _msg = _internal_mutable_delegate_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.delegate_resource)
  return _msg;
}

// .TW.Tron.Proto.UnDelegateResourceContract undelegate_resource = 25;
inline bool Transaction::_internal_has_undelegate_resource() const {
  return contract_oneof_case() == kUndelegateResource;
}
inline bool Transaction::has_undelegate_resource() const {
  return _internal_has_undelegate_resource();
}
inline void Transaction::set_has_undelegate_resource() {
  _oneof_case_[0] = kUndelegateResource;
}
inline void Transaction::clear_undelegate_resource() {
  if (_internal_has_undelegate_resource()) {
    if (GetArenaForAllocation() == nullptr) {
      delete contract_oneof_.undelegate_resource_;
    }
    clear_has_contract_oneof();
  }
}
inline ::TW::Tron::Proto::UnDelegateResourceContract* Transaction::release_undelegate_resource() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.Transaction.undelegate_resource)
  if (_internal_has_undelegate_resource()) {
    clear_has_contract_oneof();
      ::TW::Tron::Proto::UnDelegateResourceContract* temp = contract_oneof_.undelegate_resource_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    contract_oneof_.undelegate_resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::Tron::Proto::UnDelegateResourceContract& Transaction::_internal_undelegate_resource() const {
  return _internal_has_undelegate_resource()
      ? *contract_oneof_.undelegate_resource_
      : reinterpret_cast< ::TW::Tron::Proto::UnDelegateResourceContract&>(::TW::Tron::Proto::_UnDelegateResourceContract_default_instance_);
}
inline const ::TW::Tron::Proto::UnDelegateResourceContract& Transaction::undelegate_resource() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.Transaction.undelegate_resource)
  return _internal_undelegate_resource();
}
inline ::TW::Tron::Proto::UnDelegateResourceContract* Transaction::unsafe_arena_release_undelegate_resource() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.Tron.Proto.Transaction.undelegate_resource)
  if (_internal_has_undelegate_resource()) {
    clear_has_contract_oneof();
    ::TW::Tron::Proto::UnDelegateResourceContract* temp = contract_oneof_.undelegate_resource_;
    contract_oneof_.undelegate_resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_undelegate_resource(::TW::Tron::Proto::UnDelegateResourceContract* undelegate_resource) {
  clear_contract_oneof();
  if (undelegate_resource) {
    set_has_undelegate_resource();
    contract_oneof_.undelegate_resource_ = undelegate_resource;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.Transaction.undelegate_resource)
}
inline ::TW::Tron::Proto::UnDelegateResourceContract* Transaction::_internal_mutable_undelegate_resource() {
  if (!_internal_has_undelegate_resource()) {
    clear_contract_oneof();
    set_has_undelegate_resource();
    contract_oneof_.undelegate_resource_ = CreateMaybeMessage< ::TW::Tron::Proto::UnDelegateResourceContract >(GetArenaForAllocation());
  }
  return contract_oneof_.undelegate_resource_;
}
inline ::TW::Tron::Proto::UnDelegateResourceContract* Transaction::mutable_undelegate_resource() {
  ::TW::Tron::Proto::UnDelegateResourceContract* _msg = _internal_mutable_undelegate_resource();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.Transaction.undelegate_resource)
  return _msg;
}

inline bool Transaction::has_contract_oneof() const {
  return contract_oneof_case() != CONTRACT_ONEOF_NOT_SET;
}
inline void Transaction::clear_has_contract_oneof() {
  _oneof_case_[0] = CONTRACT_ONEOF_NOT_SET;
}
inline Transaction::ContractOneofCase Transaction::contract_oneof_case() const {
  return Transaction::ContractOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SigningInput

// .TW.Tron.Proto.Transaction transaction = 1;
inline bool SigningInput::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool SigningInput::has_transaction() const {
  return _internal_has_transaction();
}
inline void SigningInput::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::TW::Tron::Proto::Transaction& SigningInput::_internal_transaction() const {
  const ::TW::Tron::Proto::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Tron::Proto::Transaction&>(
      ::TW::Tron::Proto::_Transaction_default_instance_);
}
inline const ::TW::Tron::Proto::Transaction& SigningInput::transaction() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningInput.transaction)
  return _internal_transaction();
}
inline void SigningInput::unsafe_arena_set_allocated_transaction(
    ::TW::Tron::Proto::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Tron.Proto.SigningInput.transaction)
}
inline ::TW::Tron::Proto::Transaction* SigningInput::release_transaction() {
  
  ::TW::Tron::Proto::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Tron::Proto::Transaction* SigningInput::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningInput.transaction)
  
  ::TW::Tron::Proto::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::TW::Tron::Proto::Transaction* SigningInput::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Tron::Proto::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::TW::Tron::Proto::Transaction* SigningInput::mutable_transaction() {
  ::TW::Tron::Proto::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningInput.transaction)
  return _msg;
}
inline void SigningInput::set_allocated_transaction(::TW::Tron::Proto::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Tron::Proto::Transaction>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningInput.transaction)
}

// bytes private_key = 2;
inline void SigningInput::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& SigningInput::private_key() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningInput.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 private_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningInput.private_key)
  return _s;
}
inline const std::string& SigningInput::_internal_private_key() const {
  return private_key_.Get();
}
inline void SigningInput::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_private_key() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningInput.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningInput.private_key)
}

// string txId = 3;
inline void SigningInput::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& SigningInput::txid() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningInput.txId)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningInput::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningInput.txId)
}
inline std::string* SigningInput::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningInput.txId)
  return _s;
}
inline const std::string& SigningInput::_internal_txid() const {
  return txid_.Get();
}
inline void SigningInput::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningInput::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningInput::release_txid() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningInput.txId)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningInput::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningInput.txId)
}

// -------------------------------------------------------------------

// SigningOutput

// bytes id = 1;
inline void SigningOutput::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SigningOutput::id() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.id)
}
inline std::string* SigningOutput::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningOutput.id)
  return _s;
}
inline const std::string& SigningOutput::_internal_id() const {
  return id_.Get();
}
inline void SigningOutput::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_id() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningOutput.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningOutput.id)
}

// bytes signature = 2;
inline void SigningOutput::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& SigningOutput::signature() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.signature)
}
inline std::string* SigningOutput::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningOutput.signature)
  return _s;
}
inline const std::string& SigningOutput::_internal_signature() const {
  return signature_.Get();
}
inline void SigningOutput::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_signature() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningOutput.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningOutput.signature)
}

// bytes ref_block_bytes = 3;
inline void SigningOutput::clear_ref_block_bytes() {
  ref_block_bytes_.ClearToEmpty();
}
inline const std::string& SigningOutput::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.ref_block_bytes)
  return _internal_ref_block_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_ref_block_bytes(ArgT0&& arg0, ArgT... args) {
 
 ref_block_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.ref_block_bytes)
}
inline std::string* SigningOutput::mutable_ref_block_bytes() {
  std::string* _s = _internal_mutable_ref_block_bytes();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningOutput.ref_block_bytes)
  return _s;
}
inline const std::string& SigningOutput::_internal_ref_block_bytes() const {
  return ref_block_bytes_.Get();
}
inline void SigningOutput::_internal_set_ref_block_bytes(const std::string& value) {
  
  ref_block_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_ref_block_bytes() {
  
  return ref_block_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningOutput.ref_block_bytes)
  return ref_block_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_ref_block_bytes(std::string* ref_block_bytes) {
  if (ref_block_bytes != nullptr) {
    
  } else {
    
  }
  ref_block_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref_block_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ref_block_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ref_block_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningOutput.ref_block_bytes)
}

// bytes ref_block_hash = 4;
inline void SigningOutput::clear_ref_block_hash() {
  ref_block_hash_.ClearToEmpty();
}
inline const std::string& SigningOutput::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.ref_block_hash)
  return _internal_ref_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_ref_block_hash(ArgT0&& arg0, ArgT... args) {
 
 ref_block_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.ref_block_hash)
}
inline std::string* SigningOutput::mutable_ref_block_hash() {
  std::string* _s = _internal_mutable_ref_block_hash();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningOutput.ref_block_hash)
  return _s;
}
inline const std::string& SigningOutput::_internal_ref_block_hash() const {
  return ref_block_hash_.Get();
}
inline void SigningOutput::_internal_set_ref_block_hash(const std::string& value) {
  
  ref_block_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_ref_block_hash() {
  
  return ref_block_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningOutput.ref_block_hash)
  return ref_block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_ref_block_hash(std::string* ref_block_hash) {
  if (ref_block_hash != nullptr) {
    
  } else {
    
  }
  ref_block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref_block_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ref_block_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ref_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningOutput.ref_block_hash)
}

// string json = 5;
inline void SigningOutput::clear_json() {
  json_.ClearToEmpty();
}
inline const std::string& SigningOutput::json() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_json(ArgT0&& arg0, ArgT... args) {
 
 json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.json)
}
inline std::string* SigningOutput::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningOutput.json)
  return _s;
}
inline const std::string& SigningOutput::_internal_json() const {
  return json_.Get();
}
inline void SigningOutput::_internal_set_json(const std::string& value) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_json() {
  
  return json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_json() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningOutput.json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (json_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningOutput.json)
}

// .TW.Common.Proto.SigningError error = 6;
inline void SigningOutput::clear_error() {
  error_ = 0;
}
inline ::TW::Common::Proto::SigningError SigningOutput::_internal_error() const {
  return static_cast< ::TW::Common::Proto::SigningError >(error_);
}
inline ::TW::Common::Proto::SigningError SigningOutput::error() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.error)
  return _internal_error();
}
inline void SigningOutput::_internal_set_error(::TW::Common::Proto::SigningError value) {
  
  error_ = value;
}
inline void SigningOutput::set_error(::TW::Common::Proto::SigningError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.error)
}

// string error_message = 7;
inline void SigningOutput::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& SigningOutput::error_message() const {
  // @@protoc_insertion_point(field_get:TW.Tron.Proto.SigningOutput.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Tron.Proto.SigningOutput.error_message)
}
inline std::string* SigningOutput::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:TW.Tron.Proto.SigningOutput.error_message)
  return _s;
}
inline const std::string& SigningOutput::_internal_error_message() const {
  return error_message_.Get();
}
inline void SigningOutput::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_error_message() {
  // @@protoc_insertion_point(field_release:TW.Tron.Proto.SigningOutput.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Tron.Proto.SigningOutput.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Tron
}  // namespace TW

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Tron_2eproto
