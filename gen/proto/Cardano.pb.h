// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cardano.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Cardano_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Cardano_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Cardano_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Cardano_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Cardano_2eproto;
namespace TW {
namespace Cardano {
namespace Proto {
class Delegate;
struct DelegateDefaultTypeInternal;
extern DelegateDefaultTypeInternal _Delegate_default_instance_;
class DeregisterStakingKey;
struct DeregisterStakingKeyDefaultTypeInternal;
extern DeregisterStakingKeyDefaultTypeInternal _DeregisterStakingKey_default_instance_;
class OutPoint;
struct OutPointDefaultTypeInternal;
extern OutPointDefaultTypeInternal _OutPoint_default_instance_;
class RegisterStakingKey;
struct RegisterStakingKeyDefaultTypeInternal;
extern RegisterStakingKeyDefaultTypeInternal _RegisterStakingKey_default_instance_;
class SigningInput;
struct SigningInputDefaultTypeInternal;
extern SigningInputDefaultTypeInternal _SigningInput_default_instance_;
class SigningOutput;
struct SigningOutputDefaultTypeInternal;
extern SigningOutputDefaultTypeInternal _SigningOutput_default_instance_;
class TokenAmount;
struct TokenAmountDefaultTypeInternal;
extern TokenAmountDefaultTypeInternal _TokenAmount_default_instance_;
class TokenBundle;
struct TokenBundleDefaultTypeInternal;
extern TokenBundleDefaultTypeInternal _TokenBundle_default_instance_;
class TransactionPlan;
struct TransactionPlanDefaultTypeInternal;
extern TransactionPlanDefaultTypeInternal _TransactionPlan_default_instance_;
class Transfer;
struct TransferDefaultTypeInternal;
extern TransferDefaultTypeInternal _Transfer_default_instance_;
class TxInput;
struct TxInputDefaultTypeInternal;
extern TxInputDefaultTypeInternal _TxInput_default_instance_;
class TxOutput;
struct TxOutputDefaultTypeInternal;
extern TxOutputDefaultTypeInternal _TxOutput_default_instance_;
class Withdraw;
struct WithdrawDefaultTypeInternal;
extern WithdrawDefaultTypeInternal _Withdraw_default_instance_;
}  // namespace Proto
}  // namespace Cardano
}  // namespace TW
PROTOBUF_NAMESPACE_OPEN
template<> ::TW::Cardano::Proto::Delegate* Arena::CreateMaybeMessage<::TW::Cardano::Proto::Delegate>(Arena*);
template<> ::TW::Cardano::Proto::DeregisterStakingKey* Arena::CreateMaybeMessage<::TW::Cardano::Proto::DeregisterStakingKey>(Arena*);
template<> ::TW::Cardano::Proto::OutPoint* Arena::CreateMaybeMessage<::TW::Cardano::Proto::OutPoint>(Arena*);
template<> ::TW::Cardano::Proto::RegisterStakingKey* Arena::CreateMaybeMessage<::TW::Cardano::Proto::RegisterStakingKey>(Arena*);
template<> ::TW::Cardano::Proto::SigningInput* Arena::CreateMaybeMessage<::TW::Cardano::Proto::SigningInput>(Arena*);
template<> ::TW::Cardano::Proto::SigningOutput* Arena::CreateMaybeMessage<::TW::Cardano::Proto::SigningOutput>(Arena*);
template<> ::TW::Cardano::Proto::TokenAmount* Arena::CreateMaybeMessage<::TW::Cardano::Proto::TokenAmount>(Arena*);
template<> ::TW::Cardano::Proto::TokenBundle* Arena::CreateMaybeMessage<::TW::Cardano::Proto::TokenBundle>(Arena*);
template<> ::TW::Cardano::Proto::TransactionPlan* Arena::CreateMaybeMessage<::TW::Cardano::Proto::TransactionPlan>(Arena*);
template<> ::TW::Cardano::Proto::Transfer* Arena::CreateMaybeMessage<::TW::Cardano::Proto::Transfer>(Arena*);
template<> ::TW::Cardano::Proto::TxInput* Arena::CreateMaybeMessage<::TW::Cardano::Proto::TxInput>(Arena*);
template<> ::TW::Cardano::Proto::TxOutput* Arena::CreateMaybeMessage<::TW::Cardano::Proto::TxOutput>(Arena*);
template<> ::TW::Cardano::Proto::Withdraw* Arena::CreateMaybeMessage<::TW::Cardano::Proto::Withdraw>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TW {
namespace Cardano {
namespace Proto {

// ===================================================================

class OutPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.OutPoint) */ {
 public:
  inline OutPoint() : OutPoint(nullptr) {}
  ~OutPoint() override;
  explicit constexpr OutPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutPoint(const OutPoint& from);
  OutPoint(OutPoint&& from) noexcept
    : OutPoint() {
    *this = ::std::move(from);
  }

  inline OutPoint& operator=(const OutPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutPoint& operator=(OutPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutPoint* internal_default_instance() {
    return reinterpret_cast<const OutPoint*>(
               &_OutPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OutPoint& a, OutPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(OutPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OutPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.OutPoint";
  }
  protected:
  explicit OutPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 1,
    kOutputIndexFieldNumber = 2,
  };
  // bytes tx_hash = 1;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // uint64 output_index = 2;
  void clear_output_index();
  uint64_t output_index() const;
  void set_output_index(uint64_t value);
  private:
  uint64_t _internal_output_index() const;
  void _internal_set_output_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.OutPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
  uint64_t output_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class TokenAmount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.TokenAmount) */ {
 public:
  inline TokenAmount() : TokenAmount(nullptr) {}
  ~TokenAmount() override;
  explicit constexpr TokenAmount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenAmount(const TokenAmount& from);
  TokenAmount(TokenAmount&& from) noexcept
    : TokenAmount() {
    *this = ::std::move(from);
  }

  inline TokenAmount& operator=(const TokenAmount& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenAmount& operator=(TokenAmount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenAmount& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenAmount* internal_default_instance() {
    return reinterpret_cast<const TokenAmount*>(
               &_TokenAmount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TokenAmount& a, TokenAmount& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenAmount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenAmount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenAmount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenAmount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenAmount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenAmount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenAmount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.TokenAmount";
  }
  protected:
  explicit TokenAmount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyIdFieldNumber = 1,
    kAssetNameFieldNumber = 2,
    kAmountFieldNumber = 3,
    kAssetNameHexFieldNumber = 4,
  };
  // string policy_id = 1;
  void clear_policy_id();
  const std::string& policy_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_id();
  PROTOBUF_NODISCARD std::string* release_policy_id();
  void set_allocated_policy_id(std::string* policy_id);
  private:
  const std::string& _internal_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_id(const std::string& value);
  std::string* _internal_mutable_policy_id();
  public:

  // string asset_name = 2;
  void clear_asset_name();
  const std::string& asset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_name();
  PROTOBUF_NODISCARD std::string* release_asset_name();
  void set_allocated_asset_name(std::string* asset_name);
  private:
  const std::string& _internal_asset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_name(const std::string& value);
  std::string* _internal_mutable_asset_name();
  public:

  // bytes amount = 3;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // string asset_name_hex = 4;
  void clear_asset_name_hex();
  const std::string& asset_name_hex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_name_hex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_name_hex();
  PROTOBUF_NODISCARD std::string* release_asset_name_hex();
  void set_allocated_asset_name_hex(std::string* asset_name_hex);
  private:
  const std::string& _internal_asset_name_hex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_name_hex(const std::string& value);
  std::string* _internal_mutable_asset_name_hex();
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.TokenAmount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_name_hex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class TxInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.TxInput) */ {
 public:
  inline TxInput() : TxInput(nullptr) {}
  ~TxInput() override;
  explicit constexpr TxInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxInput(const TxInput& from);
  TxInput(TxInput&& from) noexcept
    : TxInput() {
    *this = ::std::move(from);
  }

  inline TxInput& operator=(const TxInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxInput& operator=(TxInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxInput* internal_default_instance() {
    return reinterpret_cast<const TxInput*>(
               &_TxInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TxInput& a, TxInput& b) {
    a.Swap(&b);
  }
  inline void Swap(TxInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.TxInput";
  }
  protected:
  explicit TxInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenAmountFieldNumber = 4,
    kAddressFieldNumber = 2,
    kOutPointFieldNumber = 1,
    kAmountFieldNumber = 3,
  };
  // repeated .TW.Cardano.Proto.TokenAmount token_amount = 4;
  int token_amount_size() const;
  private:
  int _internal_token_amount_size() const;
  public:
  void clear_token_amount();
  ::TW::Cardano::Proto::TokenAmount* mutable_token_amount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
      mutable_token_amount();
  private:
  const ::TW::Cardano::Proto::TokenAmount& _internal_token_amount(int index) const;
  ::TW::Cardano::Proto::TokenAmount* _internal_add_token_amount();
  public:
  const ::TW::Cardano::Proto::TokenAmount& token_amount(int index) const;
  ::TW::Cardano::Proto::TokenAmount* add_token_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
      token_amount() const;

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .TW.Cardano.Proto.OutPoint out_point = 1;
  bool has_out_point() const;
  private:
  bool _internal_has_out_point() const;
  public:
  void clear_out_point();
  const ::TW::Cardano::Proto::OutPoint& out_point() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::OutPoint* release_out_point();
  ::TW::Cardano::Proto::OutPoint* mutable_out_point();
  void set_allocated_out_point(::TW::Cardano::Proto::OutPoint* out_point);
  private:
  const ::TW::Cardano::Proto::OutPoint& _internal_out_point() const;
  ::TW::Cardano::Proto::OutPoint* _internal_mutable_out_point();
  public:
  void unsafe_arena_set_allocated_out_point(
      ::TW::Cardano::Proto::OutPoint* out_point);
  ::TW::Cardano::Proto::OutPoint* unsafe_arena_release_out_point();

  // uint64 amount = 3;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.TxInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount > token_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::TW::Cardano::Proto::OutPoint* out_point_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class TxOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.TxOutput) */ {
 public:
  inline TxOutput() : TxOutput(nullptr) {}
  ~TxOutput() override;
  explicit constexpr TxOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxOutput(const TxOutput& from);
  TxOutput(TxOutput&& from) noexcept
    : TxOutput() {
    *this = ::std::move(from);
  }

  inline TxOutput& operator=(const TxOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxOutput& operator=(TxOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxOutput* internal_default_instance() {
    return reinterpret_cast<const TxOutput*>(
               &_TxOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TxOutput& a, TxOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(TxOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.TxOutput";
  }
  protected:
  explicit TxOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenAmountFieldNumber = 3,
    kAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // repeated .TW.Cardano.Proto.TokenAmount token_amount = 3;
  int token_amount_size() const;
  private:
  int _internal_token_amount_size() const;
  public:
  void clear_token_amount();
  ::TW::Cardano::Proto::TokenAmount* mutable_token_amount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
      mutable_token_amount();
  private:
  const ::TW::Cardano::Proto::TokenAmount& _internal_token_amount(int index) const;
  ::TW::Cardano::Proto::TokenAmount* _internal_add_token_amount();
  public:
  const ::TW::Cardano::Proto::TokenAmount& token_amount(int index) const;
  ::TW::Cardano::Proto::TokenAmount* add_token_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
      token_amount() const;

  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.TxOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount > token_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class TokenBundle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.TokenBundle) */ {
 public:
  inline TokenBundle() : TokenBundle(nullptr) {}
  ~TokenBundle() override;
  explicit constexpr TokenBundle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenBundle(const TokenBundle& from);
  TokenBundle(TokenBundle&& from) noexcept
    : TokenBundle() {
    *this = ::std::move(from);
  }

  inline TokenBundle& operator=(const TokenBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenBundle& operator=(TokenBundle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenBundle& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenBundle* internal_default_instance() {
    return reinterpret_cast<const TokenBundle*>(
               &_TokenBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TokenBundle& a, TokenBundle& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenBundle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenBundle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenBundle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenBundle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenBundle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenBundle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenBundle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.TokenBundle";
  }
  protected:
  explicit TokenBundle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // repeated .TW.Cardano.Proto.TokenAmount token = 1;
  int token_size() const;
  private:
  int _internal_token_size() const;
  public:
  void clear_token();
  ::TW::Cardano::Proto::TokenAmount* mutable_token(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
      mutable_token();
  private:
  const ::TW::Cardano::Proto::TokenAmount& _internal_token(int index) const;
  ::TW::Cardano::Proto::TokenAmount* _internal_add_token();
  public:
  const ::TW::Cardano::Proto::TokenAmount& token(int index) const;
  ::TW::Cardano::Proto::TokenAmount* add_token();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
      token() const;

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.TokenBundle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount > token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class Transfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.Transfer) */ {
 public:
  inline Transfer() : Transfer(nullptr) {}
  ~Transfer() override;
  explicit constexpr Transfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transfer(const Transfer& from);
  Transfer(Transfer&& from) noexcept
    : Transfer() {
    *this = ::std::move(from);
  }

  inline Transfer& operator=(const Transfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transfer& operator=(Transfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transfer* internal_default_instance() {
    return reinterpret_cast<const Transfer*>(
               &_Transfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Transfer& a, Transfer& b) {
    a.Swap(&b);
  }
  inline void Swap(Transfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transfer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transfer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.Transfer";
  }
  protected:
  explicit Transfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToAddressFieldNumber = 1,
    kChangeAddressFieldNumber = 2,
    kTokenAmountFieldNumber = 4,
    kAmountFieldNumber = 3,
    kForceFeeFieldNumber = 6,
    kUseMaxAmountFieldNumber = 5,
  };
  // string to_address = 1;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // string change_address = 2;
  void clear_change_address();
  const std::string& change_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_change_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_change_address();
  PROTOBUF_NODISCARD std::string* release_change_address();
  void set_allocated_change_address(std::string* change_address);
  private:
  const std::string& _internal_change_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_change_address(const std::string& value);
  std::string* _internal_mutable_change_address();
  public:

  // .TW.Cardano.Proto.TokenBundle token_amount = 4;
  bool has_token_amount() const;
  private:
  bool _internal_has_token_amount() const;
  public:
  void clear_token_amount();
  const ::TW::Cardano::Proto::TokenBundle& token_amount() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::TokenBundle* release_token_amount();
  ::TW::Cardano::Proto::TokenBundle* mutable_token_amount();
  void set_allocated_token_amount(::TW::Cardano::Proto::TokenBundle* token_amount);
  private:
  const ::TW::Cardano::Proto::TokenBundle& _internal_token_amount() const;
  ::TW::Cardano::Proto::TokenBundle* _internal_mutable_token_amount();
  public:
  void unsafe_arena_set_allocated_token_amount(
      ::TW::Cardano::Proto::TokenBundle* token_amount);
  ::TW::Cardano::Proto::TokenBundle* unsafe_arena_release_token_amount();

  // uint64 amount = 3;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 force_fee = 6;
  void clear_force_fee();
  uint64_t force_fee() const;
  void set_force_fee(uint64_t value);
  private:
  uint64_t _internal_force_fee() const;
  void _internal_set_force_fee(uint64_t value);
  public:

  // bool use_max_amount = 5;
  void clear_use_max_amount();
  bool use_max_amount() const;
  void set_use_max_amount(bool value);
  private:
  bool _internal_use_max_amount() const;
  void _internal_set_use_max_amount(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.Transfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr change_address_;
  ::TW::Cardano::Proto::TokenBundle* token_amount_;
  uint64_t amount_;
  uint64_t force_fee_;
  bool use_max_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class RegisterStakingKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.RegisterStakingKey) */ {
 public:
  inline RegisterStakingKey() : RegisterStakingKey(nullptr) {}
  ~RegisterStakingKey() override;
  explicit constexpr RegisterStakingKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterStakingKey(const RegisterStakingKey& from);
  RegisterStakingKey(RegisterStakingKey&& from) noexcept
    : RegisterStakingKey() {
    *this = ::std::move(from);
  }

  inline RegisterStakingKey& operator=(const RegisterStakingKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterStakingKey& operator=(RegisterStakingKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterStakingKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterStakingKey* internal_default_instance() {
    return reinterpret_cast<const RegisterStakingKey*>(
               &_RegisterStakingKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterStakingKey& a, RegisterStakingKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterStakingKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterStakingKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterStakingKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterStakingKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterStakingKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterStakingKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterStakingKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.RegisterStakingKey";
  }
  protected:
  explicit RegisterStakingKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakingAddressFieldNumber = 1,
    kDepositAmountFieldNumber = 2,
  };
  // string staking_address = 1;
  void clear_staking_address();
  const std::string& staking_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_staking_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_staking_address();
  PROTOBUF_NODISCARD std::string* release_staking_address();
  void set_allocated_staking_address(std::string* staking_address);
  private:
  const std::string& _internal_staking_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staking_address(const std::string& value);
  std::string* _internal_mutable_staking_address();
  public:

  // uint64 deposit_amount = 2;
  void clear_deposit_amount();
  uint64_t deposit_amount() const;
  void set_deposit_amount(uint64_t value);
  private:
  uint64_t _internal_deposit_amount() const;
  void _internal_set_deposit_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.RegisterStakingKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staking_address_;
  uint64_t deposit_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class DeregisterStakingKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.DeregisterStakingKey) */ {
 public:
  inline DeregisterStakingKey() : DeregisterStakingKey(nullptr) {}
  ~DeregisterStakingKey() override;
  explicit constexpr DeregisterStakingKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregisterStakingKey(const DeregisterStakingKey& from);
  DeregisterStakingKey(DeregisterStakingKey&& from) noexcept
    : DeregisterStakingKey() {
    *this = ::std::move(from);
  }

  inline DeregisterStakingKey& operator=(const DeregisterStakingKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterStakingKey& operator=(DeregisterStakingKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterStakingKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterStakingKey* internal_default_instance() {
    return reinterpret_cast<const DeregisterStakingKey*>(
               &_DeregisterStakingKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeregisterStakingKey& a, DeregisterStakingKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterStakingKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterStakingKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterStakingKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregisterStakingKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregisterStakingKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeregisterStakingKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterStakingKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.DeregisterStakingKey";
  }
  protected:
  explicit DeregisterStakingKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakingAddressFieldNumber = 1,
    kUndepositAmountFieldNumber = 2,
  };
  // string staking_address = 1;
  void clear_staking_address();
  const std::string& staking_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_staking_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_staking_address();
  PROTOBUF_NODISCARD std::string* release_staking_address();
  void set_allocated_staking_address(std::string* staking_address);
  private:
  const std::string& _internal_staking_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staking_address(const std::string& value);
  std::string* _internal_mutable_staking_address();
  public:

  // uint64 undeposit_amount = 2;
  void clear_undeposit_amount();
  uint64_t undeposit_amount() const;
  void set_undeposit_amount(uint64_t value);
  private:
  uint64_t _internal_undeposit_amount() const;
  void _internal_set_undeposit_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.DeregisterStakingKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staking_address_;
  uint64_t undeposit_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class Delegate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.Delegate) */ {
 public:
  inline Delegate() : Delegate(nullptr) {}
  ~Delegate() override;
  explicit constexpr Delegate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Delegate(const Delegate& from);
  Delegate(Delegate&& from) noexcept
    : Delegate() {
    *this = ::std::move(from);
  }

  inline Delegate& operator=(const Delegate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegate& operator=(Delegate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Delegate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Delegate* internal_default_instance() {
    return reinterpret_cast<const Delegate*>(
               &_Delegate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Delegate& a, Delegate& b) {
    a.Swap(&b);
  }
  inline void Swap(Delegate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Delegate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Delegate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Delegate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Delegate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delegate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.Delegate";
  }
  protected:
  explicit Delegate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakingAddressFieldNumber = 1,
    kPoolIdFieldNumber = 2,
    kDepositAmountFieldNumber = 3,
  };
  // string staking_address = 1;
  void clear_staking_address();
  const std::string& staking_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_staking_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_staking_address();
  PROTOBUF_NODISCARD std::string* release_staking_address();
  void set_allocated_staking_address(std::string* staking_address);
  private:
  const std::string& _internal_staking_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staking_address(const std::string& value);
  std::string* _internal_mutable_staking_address();
  public:

  // bytes pool_id = 2;
  void clear_pool_id();
  const std::string& pool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pool_id();
  PROTOBUF_NODISCARD std::string* release_pool_id();
  void set_allocated_pool_id(std::string* pool_id);
  private:
  const std::string& _internal_pool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pool_id(const std::string& value);
  std::string* _internal_mutable_pool_id();
  public:

  // uint64 deposit_amount = 3;
  void clear_deposit_amount();
  uint64_t deposit_amount() const;
  void set_deposit_amount(uint64_t value);
  private:
  uint64_t _internal_deposit_amount() const;
  void _internal_set_deposit_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.Delegate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staking_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pool_id_;
  uint64_t deposit_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class Withdraw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.Withdraw) */ {
 public:
  inline Withdraw() : Withdraw(nullptr) {}
  ~Withdraw() override;
  explicit constexpr Withdraw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Withdraw(const Withdraw& from);
  Withdraw(Withdraw&& from) noexcept
    : Withdraw() {
    *this = ::std::move(from);
  }

  inline Withdraw& operator=(const Withdraw& from) {
    CopyFrom(from);
    return *this;
  }
  inline Withdraw& operator=(Withdraw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Withdraw& default_instance() {
    return *internal_default_instance();
  }
  static inline const Withdraw* internal_default_instance() {
    return reinterpret_cast<const Withdraw*>(
               &_Withdraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Withdraw& a, Withdraw& b) {
    a.Swap(&b);
  }
  inline void Swap(Withdraw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Withdraw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Withdraw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Withdraw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Withdraw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Withdraw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Withdraw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.Withdraw";
  }
  protected:
  explicit Withdraw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakingAddressFieldNumber = 1,
    kWithdrawAmountFieldNumber = 2,
  };
  // string staking_address = 1;
  void clear_staking_address();
  const std::string& staking_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_staking_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_staking_address();
  PROTOBUF_NODISCARD std::string* release_staking_address();
  void set_allocated_staking_address(std::string* staking_address);
  private:
  const std::string& _internal_staking_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staking_address(const std::string& value);
  std::string* _internal_mutable_staking_address();
  public:

  // uint64 withdraw_amount = 2;
  void clear_withdraw_amount();
  uint64_t withdraw_amount() const;
  void set_withdraw_amount(uint64_t value);
  private:
  uint64_t _internal_withdraw_amount() const;
  void _internal_set_withdraw_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.Withdraw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staking_address_;
  uint64_t withdraw_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class TransactionPlan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.TransactionPlan) */ {
 public:
  inline TransactionPlan() : TransactionPlan(nullptr) {}
  ~TransactionPlan() override;
  explicit constexpr TransactionPlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionPlan(const TransactionPlan& from);
  TransactionPlan(TransactionPlan&& from) noexcept
    : TransactionPlan() {
    *this = ::std::move(from);
  }

  inline TransactionPlan& operator=(const TransactionPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionPlan& operator=(TransactionPlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionPlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionPlan* internal_default_instance() {
    return reinterpret_cast<const TransactionPlan*>(
               &_TransactionPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TransactionPlan& a, TransactionPlan& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionPlan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionPlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionPlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionPlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionPlan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionPlan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionPlan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.TransactionPlan";
  }
  protected:
  explicit TransactionPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableTokensFieldNumber = 5,
    kOutputTokensFieldNumber = 6,
    kChangeTokensFieldNumber = 7,
    kUtxosFieldNumber = 8,
    kExtraOutputsFieldNumber = 12,
    kAvailableAmountFieldNumber = 1,
    kAmountFieldNumber = 2,
    kFeeFieldNumber = 3,
    kChangeFieldNumber = 4,
    kDepositFieldNumber = 10,
    kUndepositFieldNumber = 11,
    kErrorFieldNumber = 9,
  };
  // repeated .TW.Cardano.Proto.TokenAmount available_tokens = 5;
  int available_tokens_size() const;
  private:
  int _internal_available_tokens_size() const;
  public:
  void clear_available_tokens();
  ::TW::Cardano::Proto::TokenAmount* mutable_available_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
      mutable_available_tokens();
  private:
  const ::TW::Cardano::Proto::TokenAmount& _internal_available_tokens(int index) const;
  ::TW::Cardano::Proto::TokenAmount* _internal_add_available_tokens();
  public:
  const ::TW::Cardano::Proto::TokenAmount& available_tokens(int index) const;
  ::TW::Cardano::Proto::TokenAmount* add_available_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
      available_tokens() const;

  // repeated .TW.Cardano.Proto.TokenAmount output_tokens = 6;
  int output_tokens_size() const;
  private:
  int _internal_output_tokens_size() const;
  public:
  void clear_output_tokens();
  ::TW::Cardano::Proto::TokenAmount* mutable_output_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
      mutable_output_tokens();
  private:
  const ::TW::Cardano::Proto::TokenAmount& _internal_output_tokens(int index) const;
  ::TW::Cardano::Proto::TokenAmount* _internal_add_output_tokens();
  public:
  const ::TW::Cardano::Proto::TokenAmount& output_tokens(int index) const;
  ::TW::Cardano::Proto::TokenAmount* add_output_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
      output_tokens() const;

  // repeated .TW.Cardano.Proto.TokenAmount change_tokens = 7;
  int change_tokens_size() const;
  private:
  int _internal_change_tokens_size() const;
  public:
  void clear_change_tokens();
  ::TW::Cardano::Proto::TokenAmount* mutable_change_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
      mutable_change_tokens();
  private:
  const ::TW::Cardano::Proto::TokenAmount& _internal_change_tokens(int index) const;
  ::TW::Cardano::Proto::TokenAmount* _internal_add_change_tokens();
  public:
  const ::TW::Cardano::Proto::TokenAmount& change_tokens(int index) const;
  ::TW::Cardano::Proto::TokenAmount* add_change_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
      change_tokens() const;

  // repeated .TW.Cardano.Proto.TxInput utxos = 8;
  int utxos_size() const;
  private:
  int _internal_utxos_size() const;
  public:
  void clear_utxos();
  ::TW::Cardano::Proto::TxInput* mutable_utxos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >*
      mutable_utxos();
  private:
  const ::TW::Cardano::Proto::TxInput& _internal_utxos(int index) const;
  ::TW::Cardano::Proto::TxInput* _internal_add_utxos();
  public:
  const ::TW::Cardano::Proto::TxInput& utxos(int index) const;
  ::TW::Cardano::Proto::TxInput* add_utxos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >&
      utxos() const;

  // repeated .TW.Cardano.Proto.TxOutput extra_outputs = 12;
  int extra_outputs_size() const;
  private:
  int _internal_extra_outputs_size() const;
  public:
  void clear_extra_outputs();
  ::TW::Cardano::Proto::TxOutput* mutable_extra_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >*
      mutable_extra_outputs();
  private:
  const ::TW::Cardano::Proto::TxOutput& _internal_extra_outputs(int index) const;
  ::TW::Cardano::Proto::TxOutput* _internal_add_extra_outputs();
  public:
  const ::TW::Cardano::Proto::TxOutput& extra_outputs(int index) const;
  ::TW::Cardano::Proto::TxOutput* add_extra_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >&
      extra_outputs() const;

  // uint64 available_amount = 1;
  void clear_available_amount();
  uint64_t available_amount() const;
  void set_available_amount(uint64_t value);
  private:
  uint64_t _internal_available_amount() const;
  void _internal_set_available_amount(uint64_t value);
  public:

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 fee = 3;
  void clear_fee();
  uint64_t fee() const;
  void set_fee(uint64_t value);
  private:
  uint64_t _internal_fee() const;
  void _internal_set_fee(uint64_t value);
  public:

  // uint64 change = 4;
  void clear_change();
  uint64_t change() const;
  void set_change(uint64_t value);
  private:
  uint64_t _internal_change() const;
  void _internal_set_change(uint64_t value);
  public:

  // uint64 deposit = 10;
  void clear_deposit();
  uint64_t deposit() const;
  void set_deposit(uint64_t value);
  private:
  uint64_t _internal_deposit() const;
  void _internal_set_deposit(uint64_t value);
  public:

  // uint64 undeposit = 11;
  void clear_undeposit();
  uint64_t undeposit() const;
  void set_undeposit(uint64_t value);
  private:
  uint64_t _internal_undeposit() const;
  void _internal_set_undeposit(uint64_t value);
  public:

  // .TW.Common.Proto.SigningError error = 9;
  void clear_error();
  ::TW::Common::Proto::SigningError error() const;
  void set_error(::TW::Common::Proto::SigningError value);
  private:
  ::TW::Common::Proto::SigningError _internal_error() const;
  void _internal_set_error(::TW::Common::Proto::SigningError value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.TransactionPlan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount > available_tokens_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount > output_tokens_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount > change_tokens_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput > utxos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput > extra_outputs_;
  uint64_t available_amount_;
  uint64_t amount_;
  uint64_t fee_;
  uint64_t change_;
  uint64_t deposit_;
  uint64_t undeposit_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class SigningInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.SigningInput) */ {
 public:
  inline SigningInput() : SigningInput(nullptr) {}
  ~SigningInput() override;
  explicit constexpr SigningInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningInput(const SigningInput& from);
  SigningInput(SigningInput&& from) noexcept
    : SigningInput() {
    *this = ::std::move(from);
  }

  inline SigningInput& operator=(const SigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningInput& operator=(SigningInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningInput* internal_default_instance() {
    return reinterpret_cast<const SigningInput*>(
               &_SigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SigningInput& a, SigningInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.SigningInput";
  }
  protected:
  explicit SigningInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtxosFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
    kExtraOutputsFieldNumber = 10,
    kTransferMessageFieldNumber = 3,
    kPlanFieldNumber = 5,
    kRegisterStakingKeyFieldNumber = 6,
    kDelegateFieldNumber = 7,
    kWithdrawFieldNumber = 8,
    kDeregisterStakingKeyFieldNumber = 9,
    kTtlFieldNumber = 4,
  };
  // repeated .TW.Cardano.Proto.TxInput utxos = 1;
  int utxos_size() const;
  private:
  int _internal_utxos_size() const;
  public:
  void clear_utxos();
  ::TW::Cardano::Proto::TxInput* mutable_utxos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >*
      mutable_utxos();
  private:
  const ::TW::Cardano::Proto::TxInput& _internal_utxos(int index) const;
  ::TW::Cardano::Proto::TxInput* _internal_add_utxos();
  public:
  const ::TW::Cardano::Proto::TxInput& utxos(int index) const;
  ::TW::Cardano::Proto::TxInput* add_utxos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >&
      utxos() const;

  // repeated bytes private_key = 2;
  int private_key_size() const;
  private:
  int _internal_private_key_size() const;
  public:
  void clear_private_key();
  const std::string& private_key(int index) const;
  std::string* mutable_private_key(int index);
  void set_private_key(int index, const std::string& value);
  void set_private_key(int index, std::string&& value);
  void set_private_key(int index, const char* value);
  void set_private_key(int index, const void* value, size_t size);
  std::string* add_private_key();
  void add_private_key(const std::string& value);
  void add_private_key(std::string&& value);
  void add_private_key(const char* value);
  void add_private_key(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& private_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_private_key();
  private:
  const std::string& _internal_private_key(int index) const;
  std::string* _internal_add_private_key();
  public:

  // repeated .TW.Cardano.Proto.TxOutput extra_outputs = 10;
  int extra_outputs_size() const;
  private:
  int _internal_extra_outputs_size() const;
  public:
  void clear_extra_outputs();
  ::TW::Cardano::Proto::TxOutput* mutable_extra_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >*
      mutable_extra_outputs();
  private:
  const ::TW::Cardano::Proto::TxOutput& _internal_extra_outputs(int index) const;
  ::TW::Cardano::Proto::TxOutput* _internal_add_extra_outputs();
  public:
  const ::TW::Cardano::Proto::TxOutput& extra_outputs(int index) const;
  ::TW::Cardano::Proto::TxOutput* add_extra_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >&
      extra_outputs() const;

  // .TW.Cardano.Proto.Transfer transfer_message = 3;
  bool has_transfer_message() const;
  private:
  bool _internal_has_transfer_message() const;
  public:
  void clear_transfer_message();
  const ::TW::Cardano::Proto::Transfer& transfer_message() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::Transfer* release_transfer_message();
  ::TW::Cardano::Proto::Transfer* mutable_transfer_message();
  void set_allocated_transfer_message(::TW::Cardano::Proto::Transfer* transfer_message);
  private:
  const ::TW::Cardano::Proto::Transfer& _internal_transfer_message() const;
  ::TW::Cardano::Proto::Transfer* _internal_mutable_transfer_message();
  public:
  void unsafe_arena_set_allocated_transfer_message(
      ::TW::Cardano::Proto::Transfer* transfer_message);
  ::TW::Cardano::Proto::Transfer* unsafe_arena_release_transfer_message();

  // .TW.Cardano.Proto.TransactionPlan plan = 5;
  bool has_plan() const;
  private:
  bool _internal_has_plan() const;
  public:
  void clear_plan();
  const ::TW::Cardano::Proto::TransactionPlan& plan() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::TransactionPlan* release_plan();
  ::TW::Cardano::Proto::TransactionPlan* mutable_plan();
  void set_allocated_plan(::TW::Cardano::Proto::TransactionPlan* plan);
  private:
  const ::TW::Cardano::Proto::TransactionPlan& _internal_plan() const;
  ::TW::Cardano::Proto::TransactionPlan* _internal_mutable_plan();
  public:
  void unsafe_arena_set_allocated_plan(
      ::TW::Cardano::Proto::TransactionPlan* plan);
  ::TW::Cardano::Proto::TransactionPlan* unsafe_arena_release_plan();

  // .TW.Cardano.Proto.RegisterStakingKey register_staking_key = 6;
  bool has_register_staking_key() const;
  private:
  bool _internal_has_register_staking_key() const;
  public:
  void clear_register_staking_key();
  const ::TW::Cardano::Proto::RegisterStakingKey& register_staking_key() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::RegisterStakingKey* release_register_staking_key();
  ::TW::Cardano::Proto::RegisterStakingKey* mutable_register_staking_key();
  void set_allocated_register_staking_key(::TW::Cardano::Proto::RegisterStakingKey* register_staking_key);
  private:
  const ::TW::Cardano::Proto::RegisterStakingKey& _internal_register_staking_key() const;
  ::TW::Cardano::Proto::RegisterStakingKey* _internal_mutable_register_staking_key();
  public:
  void unsafe_arena_set_allocated_register_staking_key(
      ::TW::Cardano::Proto::RegisterStakingKey* register_staking_key);
  ::TW::Cardano::Proto::RegisterStakingKey* unsafe_arena_release_register_staking_key();

  // .TW.Cardano.Proto.Delegate delegate = 7;
  bool has_delegate() const;
  private:
  bool _internal_has_delegate() const;
  public:
  void clear_delegate();
  const ::TW::Cardano::Proto::Delegate& delegate() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::Delegate* release_delegate();
  ::TW::Cardano::Proto::Delegate* mutable_delegate();
  void set_allocated_delegate(::TW::Cardano::Proto::Delegate* delegate);
  private:
  const ::TW::Cardano::Proto::Delegate& _internal_delegate() const;
  ::TW::Cardano::Proto::Delegate* _internal_mutable_delegate();
  public:
  void unsafe_arena_set_allocated_delegate(
      ::TW::Cardano::Proto::Delegate* delegate);
  ::TW::Cardano::Proto::Delegate* unsafe_arena_release_delegate();

  // .TW.Cardano.Proto.Withdraw withdraw = 8;
  bool has_withdraw() const;
  private:
  bool _internal_has_withdraw() const;
  public:
  void clear_withdraw();
  const ::TW::Cardano::Proto::Withdraw& withdraw() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::Withdraw* release_withdraw();
  ::TW::Cardano::Proto::Withdraw* mutable_withdraw();
  void set_allocated_withdraw(::TW::Cardano::Proto::Withdraw* withdraw);
  private:
  const ::TW::Cardano::Proto::Withdraw& _internal_withdraw() const;
  ::TW::Cardano::Proto::Withdraw* _internal_mutable_withdraw();
  public:
  void unsafe_arena_set_allocated_withdraw(
      ::TW::Cardano::Proto::Withdraw* withdraw);
  ::TW::Cardano::Proto::Withdraw* unsafe_arena_release_withdraw();

  // .TW.Cardano.Proto.DeregisterStakingKey deregister_staking_key = 9;
  bool has_deregister_staking_key() const;
  private:
  bool _internal_has_deregister_staking_key() const;
  public:
  void clear_deregister_staking_key();
  const ::TW::Cardano::Proto::DeregisterStakingKey& deregister_staking_key() const;
  PROTOBUF_NODISCARD ::TW::Cardano::Proto::DeregisterStakingKey* release_deregister_staking_key();
  ::TW::Cardano::Proto::DeregisterStakingKey* mutable_deregister_staking_key();
  void set_allocated_deregister_staking_key(::TW::Cardano::Proto::DeregisterStakingKey* deregister_staking_key);
  private:
  const ::TW::Cardano::Proto::DeregisterStakingKey& _internal_deregister_staking_key() const;
  ::TW::Cardano::Proto::DeregisterStakingKey* _internal_mutable_deregister_staking_key();
  public:
  void unsafe_arena_set_allocated_deregister_staking_key(
      ::TW::Cardano::Proto::DeregisterStakingKey* deregister_staking_key);
  ::TW::Cardano::Proto::DeregisterStakingKey* unsafe_arena_release_deregister_staking_key();

  // uint64 ttl = 4;
  void clear_ttl();
  uint64_t ttl() const;
  void set_ttl(uint64_t value);
  private:
  uint64_t _internal_ttl() const;
  void _internal_set_ttl(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.SigningInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput > utxos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> private_key_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput > extra_outputs_;
  ::TW::Cardano::Proto::Transfer* transfer_message_;
  ::TW::Cardano::Proto::TransactionPlan* plan_;
  ::TW::Cardano::Proto::RegisterStakingKey* register_staking_key_;
  ::TW::Cardano::Proto::Delegate* delegate_;
  ::TW::Cardano::Proto::Withdraw* withdraw_;
  ::TW::Cardano::Proto::DeregisterStakingKey* deregister_staking_key_;
  uint64_t ttl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// -------------------------------------------------------------------

class SigningOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.Cardano.Proto.SigningOutput) */ {
 public:
  inline SigningOutput() : SigningOutput(nullptr) {}
  ~SigningOutput() override;
  explicit constexpr SigningOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigningOutput(const SigningOutput& from);
  SigningOutput(SigningOutput&& from) noexcept
    : SigningOutput() {
    *this = ::std::move(from);
  }

  inline SigningOutput& operator=(const SigningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningOutput& operator=(SigningOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigningOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigningOutput* internal_default_instance() {
    return reinterpret_cast<const SigningOutput*>(
               &_SigningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SigningOutput& a, SigningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigningOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigningOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigningOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.Cardano.Proto.SigningOutput";
  }
  protected:
  explicit SigningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedFieldNumber = 1,
    kTxIdFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kErrorFieldNumber = 3,
  };
  // bytes encoded = 1;
  void clear_encoded();
  const std::string& encoded() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded();
  PROTOBUF_NODISCARD std::string* release_encoded();
  void set_allocated_encoded(std::string* encoded);
  private:
  const std::string& _internal_encoded() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded(const std::string& value);
  std::string* _internal_mutable_encoded();
  public:

  // bytes tx_id = 2;
  void clear_tx_id();
  const std::string& tx_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_id();
  PROTOBUF_NODISCARD std::string* release_tx_id();
  void set_allocated_tx_id(std::string* tx_id);
  private:
  const std::string& _internal_tx_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_id(const std::string& value);
  std::string* _internal_mutable_tx_id();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .TW.Common.Proto.SigningError error = 3;
  void clear_error();
  ::TW::Common::Proto::SigningError error() const;
  void set_error(::TW::Common::Proto::SigningError value);
  private:
  ::TW::Common::Proto::SigningError _internal_error() const;
  void _internal_set_error(::TW::Common::Proto::SigningError value);
  public:

  // @@protoc_insertion_point(class_scope:TW.Cardano.Proto.SigningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cardano_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OutPoint

// bytes tx_hash = 1;
inline void OutPoint::clear_tx_hash() {
  tx_hash_.ClearToEmpty();
}
inline const std::string& OutPoint::tx_hash() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.OutPoint.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutPoint::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 tx_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.OutPoint.tx_hash)
}
inline std::string* OutPoint::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.OutPoint.tx_hash)
  return _s;
}
inline const std::string& OutPoint::_internal_tx_hash() const {
  return tx_hash_.Get();
}
inline void OutPoint::_internal_set_tx_hash(const std::string& value) {
  
  tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutPoint::_internal_mutable_tx_hash() {
  
  return tx_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutPoint::release_tx_hash() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.OutPoint.tx_hash)
  return tx_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutPoint::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  tx_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.OutPoint.tx_hash)
}

// uint64 output_index = 2;
inline void OutPoint::clear_output_index() {
  output_index_ = uint64_t{0u};
}
inline uint64_t OutPoint::_internal_output_index() const {
  return output_index_;
}
inline uint64_t OutPoint::output_index() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.OutPoint.output_index)
  return _internal_output_index();
}
inline void OutPoint::_internal_set_output_index(uint64_t value) {
  
  output_index_ = value;
}
inline void OutPoint::set_output_index(uint64_t value) {
  _internal_set_output_index(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.OutPoint.output_index)
}

// -------------------------------------------------------------------

// TokenAmount

// string policy_id = 1;
inline void TokenAmount::clear_policy_id() {
  policy_id_.ClearToEmpty();
}
inline const std::string& TokenAmount::policy_id() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TokenAmount.policy_id)
  return _internal_policy_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenAmount::set_policy_id(ArgT0&& arg0, ArgT... args) {
 
 policy_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TokenAmount.policy_id)
}
inline std::string* TokenAmount::mutable_policy_id() {
  std::string* _s = _internal_mutable_policy_id();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TokenAmount.policy_id)
  return _s;
}
inline const std::string& TokenAmount::_internal_policy_id() const {
  return policy_id_.Get();
}
inline void TokenAmount::_internal_set_policy_id(const std::string& value) {
  
  policy_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenAmount::_internal_mutable_policy_id() {
  
  return policy_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenAmount::release_policy_id() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TokenAmount.policy_id)
  return policy_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenAmount::set_allocated_policy_id(std::string* policy_id) {
  if (policy_id != nullptr) {
    
  } else {
    
  }
  policy_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (policy_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    policy_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TokenAmount.policy_id)
}

// string asset_name = 2;
inline void TokenAmount::clear_asset_name() {
  asset_name_.ClearToEmpty();
}
inline const std::string& TokenAmount::asset_name() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TokenAmount.asset_name)
  return _internal_asset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenAmount::set_asset_name(ArgT0&& arg0, ArgT... args) {
 
 asset_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TokenAmount.asset_name)
}
inline std::string* TokenAmount::mutable_asset_name() {
  std::string* _s = _internal_mutable_asset_name();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TokenAmount.asset_name)
  return _s;
}
inline const std::string& TokenAmount::_internal_asset_name() const {
  return asset_name_.Get();
}
inline void TokenAmount::_internal_set_asset_name(const std::string& value) {
  
  asset_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenAmount::_internal_mutable_asset_name() {
  
  return asset_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenAmount::release_asset_name() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TokenAmount.asset_name)
  return asset_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenAmount::set_allocated_asset_name(std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  asset_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TokenAmount.asset_name)
}

// bytes amount = 3;
inline void TokenAmount::clear_amount() {
  amount_.ClearToEmpty();
}
inline const std::string& TokenAmount::amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TokenAmount.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenAmount::set_amount(ArgT0&& arg0, ArgT... args) {
 
 amount_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TokenAmount.amount)
}
inline std::string* TokenAmount::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TokenAmount.amount)
  return _s;
}
inline const std::string& TokenAmount::_internal_amount() const {
  return amount_.Get();
}
inline void TokenAmount::_internal_set_amount(const std::string& value) {
  
  amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenAmount::_internal_mutable_amount() {
  
  return amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenAmount::release_amount() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TokenAmount.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenAmount::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amount_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TokenAmount.amount)
}

// string asset_name_hex = 4;
inline void TokenAmount::clear_asset_name_hex() {
  asset_name_hex_.ClearToEmpty();
}
inline const std::string& TokenAmount::asset_name_hex() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TokenAmount.asset_name_hex)
  return _internal_asset_name_hex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenAmount::set_asset_name_hex(ArgT0&& arg0, ArgT... args) {
 
 asset_name_hex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TokenAmount.asset_name_hex)
}
inline std::string* TokenAmount::mutable_asset_name_hex() {
  std::string* _s = _internal_mutable_asset_name_hex();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TokenAmount.asset_name_hex)
  return _s;
}
inline const std::string& TokenAmount::_internal_asset_name_hex() const {
  return asset_name_hex_.Get();
}
inline void TokenAmount::_internal_set_asset_name_hex(const std::string& value) {
  
  asset_name_hex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenAmount::_internal_mutable_asset_name_hex() {
  
  return asset_name_hex_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenAmount::release_asset_name_hex() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TokenAmount.asset_name_hex)
  return asset_name_hex_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenAmount::set_allocated_asset_name_hex(std::string* asset_name_hex) {
  if (asset_name_hex != nullptr) {
    
  } else {
    
  }
  asset_name_hex_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_name_hex,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_name_hex_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_name_hex_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TokenAmount.asset_name_hex)
}

// -------------------------------------------------------------------

// TxInput

// .TW.Cardano.Proto.OutPoint out_point = 1;
inline bool TxInput::_internal_has_out_point() const {
  return this != internal_default_instance() && out_point_ != nullptr;
}
inline bool TxInput::has_out_point() const {
  return _internal_has_out_point();
}
inline void TxInput::clear_out_point() {
  if (GetArenaForAllocation() == nullptr && out_point_ != nullptr) {
    delete out_point_;
  }
  out_point_ = nullptr;
}
inline const ::TW::Cardano::Proto::OutPoint& TxInput::_internal_out_point() const {
  const ::TW::Cardano::Proto::OutPoint* p = out_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::OutPoint&>(
      ::TW::Cardano::Proto::_OutPoint_default_instance_);
}
inline const ::TW::Cardano::Proto::OutPoint& TxInput::out_point() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxInput.out_point)
  return _internal_out_point();
}
inline void TxInput::unsafe_arena_set_allocated_out_point(
    ::TW::Cardano::Proto::OutPoint* out_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(out_point_);
  }
  out_point_ = out_point;
  if (out_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.TxInput.out_point)
}
inline ::TW::Cardano::Proto::OutPoint* TxInput::release_out_point() {
  
  ::TW::Cardano::Proto::OutPoint* temp = out_point_;
  out_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::OutPoint* TxInput::unsafe_arena_release_out_point() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TxInput.out_point)
  
  ::TW::Cardano::Proto::OutPoint* temp = out_point_;
  out_point_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::OutPoint* TxInput::_internal_mutable_out_point() {
  
  if (out_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::OutPoint>(GetArenaForAllocation());
    out_point_ = p;
  }
  return out_point_;
}
inline ::TW::Cardano::Proto::OutPoint* TxInput::mutable_out_point() {
  ::TW::Cardano::Proto::OutPoint* _msg = _internal_mutable_out_point();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TxInput.out_point)
  return _msg;
}
inline void TxInput::set_allocated_out_point(::TW::Cardano::Proto::OutPoint* out_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete out_point_;
  }
  if (out_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::OutPoint>::GetOwningArena(out_point);
    if (message_arena != submessage_arena) {
      out_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, out_point, submessage_arena);
    }
    
  } else {
    
  }
  out_point_ = out_point;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TxInput.out_point)
}

// string address = 2;
inline void TxInput::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& TxInput::address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxInput.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxInput::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TxInput.address)
}
inline std::string* TxInput::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TxInput.address)
  return _s;
}
inline const std::string& TxInput::_internal_address() const {
  return address_.Get();
}
inline void TxInput::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxInput::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxInput::release_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TxInput.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TxInput::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TxInput.address)
}

// uint64 amount = 3;
inline void TxInput::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TxInput::_internal_amount() const {
  return amount_;
}
inline uint64_t TxInput::amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxInput.amount)
  return _internal_amount();
}
inline void TxInput::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TxInput::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TxInput.amount)
}

// repeated .TW.Cardano.Proto.TokenAmount token_amount = 4;
inline int TxInput::_internal_token_amount_size() const {
  return token_amount_.size();
}
inline int TxInput::token_amount_size() const {
  return _internal_token_amount_size();
}
inline void TxInput::clear_token_amount() {
  token_amount_.Clear();
}
inline ::TW::Cardano::Proto::TokenAmount* TxInput::mutable_token_amount(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TxInput.token_amount)
  return token_amount_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
TxInput::mutable_token_amount() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TxInput.token_amount)
  return &token_amount_;
}
inline const ::TW::Cardano::Proto::TokenAmount& TxInput::_internal_token_amount(int index) const {
  return token_amount_.Get(index);
}
inline const ::TW::Cardano::Proto::TokenAmount& TxInput::token_amount(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxInput.token_amount)
  return _internal_token_amount(index);
}
inline ::TW::Cardano::Proto::TokenAmount* TxInput::_internal_add_token_amount() {
  return token_amount_.Add();
}
inline ::TW::Cardano::Proto::TokenAmount* TxInput::add_token_amount() {
  ::TW::Cardano::Proto::TokenAmount* _add = _internal_add_token_amount();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TxInput.token_amount)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
TxInput::token_amount() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TxInput.token_amount)
  return token_amount_;
}

// -------------------------------------------------------------------

// TxOutput

// string address = 1;
inline void TxOutput::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& TxOutput::address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxOutput.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxOutput::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TxOutput.address)
}
inline std::string* TxOutput::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TxOutput.address)
  return _s;
}
inline const std::string& TxOutput::_internal_address() const {
  return address_.Get();
}
inline void TxOutput::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxOutput::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxOutput::release_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.TxOutput.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TxOutput::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.TxOutput.address)
}

// uint64 amount = 2;
inline void TxOutput::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TxOutput::_internal_amount() const {
  return amount_;
}
inline uint64_t TxOutput::amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxOutput.amount)
  return _internal_amount();
}
inline void TxOutput::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TxOutput::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TxOutput.amount)
}

// repeated .TW.Cardano.Proto.TokenAmount token_amount = 3;
inline int TxOutput::_internal_token_amount_size() const {
  return token_amount_.size();
}
inline int TxOutput::token_amount_size() const {
  return _internal_token_amount_size();
}
inline void TxOutput::clear_token_amount() {
  token_amount_.Clear();
}
inline ::TW::Cardano::Proto::TokenAmount* TxOutput::mutable_token_amount(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TxOutput.token_amount)
  return token_amount_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
TxOutput::mutable_token_amount() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TxOutput.token_amount)
  return &token_amount_;
}
inline const ::TW::Cardano::Proto::TokenAmount& TxOutput::_internal_token_amount(int index) const {
  return token_amount_.Get(index);
}
inline const ::TW::Cardano::Proto::TokenAmount& TxOutput::token_amount(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TxOutput.token_amount)
  return _internal_token_amount(index);
}
inline ::TW::Cardano::Proto::TokenAmount* TxOutput::_internal_add_token_amount() {
  return token_amount_.Add();
}
inline ::TW::Cardano::Proto::TokenAmount* TxOutput::add_token_amount() {
  ::TW::Cardano::Proto::TokenAmount* _add = _internal_add_token_amount();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TxOutput.token_amount)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
TxOutput::token_amount() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TxOutput.token_amount)
  return token_amount_;
}

// -------------------------------------------------------------------

// TokenBundle

// repeated .TW.Cardano.Proto.TokenAmount token = 1;
inline int TokenBundle::_internal_token_size() const {
  return token_.size();
}
inline int TokenBundle::token_size() const {
  return _internal_token_size();
}
inline void TokenBundle::clear_token() {
  token_.Clear();
}
inline ::TW::Cardano::Proto::TokenAmount* TokenBundle::mutable_token(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TokenBundle.token)
  return token_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
TokenBundle::mutable_token() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TokenBundle.token)
  return &token_;
}
inline const ::TW::Cardano::Proto::TokenAmount& TokenBundle::_internal_token(int index) const {
  return token_.Get(index);
}
inline const ::TW::Cardano::Proto::TokenAmount& TokenBundle::token(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TokenBundle.token)
  return _internal_token(index);
}
inline ::TW::Cardano::Proto::TokenAmount* TokenBundle::_internal_add_token() {
  return token_.Add();
}
inline ::TW::Cardano::Proto::TokenAmount* TokenBundle::add_token() {
  ::TW::Cardano::Proto::TokenAmount* _add = _internal_add_token();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TokenBundle.token)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
TokenBundle::token() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TokenBundle.token)
  return token_;
}

// -------------------------------------------------------------------

// Transfer

// string to_address = 1;
inline void Transfer::clear_to_address() {
  to_address_.ClearToEmpty();
}
inline const std::string& Transfer::to_address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Transfer.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Transfer.to_address)
}
inline std::string* Transfer::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.Transfer.to_address)
  return _s;
}
inline const std::string& Transfer::_internal_to_address() const {
  return to_address_.Get();
}
inline void Transfer::_internal_set_to_address(const std::string& value) {
  
  to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_to_address() {
  
  return to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transfer::release_to_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.Transfer.to_address)
  return to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transfer::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.Transfer.to_address)
}

// string change_address = 2;
inline void Transfer::clear_change_address() {
  change_address_.ClearToEmpty();
}
inline const std::string& Transfer::change_address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Transfer.change_address)
  return _internal_change_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_change_address(ArgT0&& arg0, ArgT... args) {
 
 change_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Transfer.change_address)
}
inline std::string* Transfer::mutable_change_address() {
  std::string* _s = _internal_mutable_change_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.Transfer.change_address)
  return _s;
}
inline const std::string& Transfer::_internal_change_address() const {
  return change_address_.Get();
}
inline void Transfer::_internal_set_change_address(const std::string& value) {
  
  change_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_change_address() {
  
  return change_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transfer::release_change_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.Transfer.change_address)
  return change_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transfer::set_allocated_change_address(std::string* change_address) {
  if (change_address != nullptr) {
    
  } else {
    
  }
  change_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), change_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (change_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    change_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.Transfer.change_address)
}

// uint64 amount = 3;
inline void Transfer::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t Transfer::_internal_amount() const {
  return amount_;
}
inline uint64_t Transfer::amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Transfer.amount)
  return _internal_amount();
}
inline void Transfer::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void Transfer::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Transfer.amount)
}

// .TW.Cardano.Proto.TokenBundle token_amount = 4;
inline bool Transfer::_internal_has_token_amount() const {
  return this != internal_default_instance() && token_amount_ != nullptr;
}
inline bool Transfer::has_token_amount() const {
  return _internal_has_token_amount();
}
inline void Transfer::clear_token_amount() {
  if (GetArenaForAllocation() == nullptr && token_amount_ != nullptr) {
    delete token_amount_;
  }
  token_amount_ = nullptr;
}
inline const ::TW::Cardano::Proto::TokenBundle& Transfer::_internal_token_amount() const {
  const ::TW::Cardano::Proto::TokenBundle* p = token_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::TokenBundle&>(
      ::TW::Cardano::Proto::_TokenBundle_default_instance_);
}
inline const ::TW::Cardano::Proto::TokenBundle& Transfer::token_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Transfer.token_amount)
  return _internal_token_amount();
}
inline void Transfer::unsafe_arena_set_allocated_token_amount(
    ::TW::Cardano::Proto::TokenBundle* token_amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_amount_);
  }
  token_amount_ = token_amount;
  if (token_amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.Transfer.token_amount)
}
inline ::TW::Cardano::Proto::TokenBundle* Transfer::release_token_amount() {
  
  ::TW::Cardano::Proto::TokenBundle* temp = token_amount_;
  token_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::TokenBundle* Transfer::unsafe_arena_release_token_amount() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.Transfer.token_amount)
  
  ::TW::Cardano::Proto::TokenBundle* temp = token_amount_;
  token_amount_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::TokenBundle* Transfer::_internal_mutable_token_amount() {
  
  if (token_amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::TokenBundle>(GetArenaForAllocation());
    token_amount_ = p;
  }
  return token_amount_;
}
inline ::TW::Cardano::Proto::TokenBundle* Transfer::mutable_token_amount() {
  ::TW::Cardano::Proto::TokenBundle* _msg = _internal_mutable_token_amount();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.Transfer.token_amount)
  return _msg;
}
inline void Transfer::set_allocated_token_amount(::TW::Cardano::Proto::TokenBundle* token_amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete token_amount_;
  }
  if (token_amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::TokenBundle>::GetOwningArena(token_amount);
    if (message_arena != submessage_arena) {
      token_amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_amount, submessage_arena);
    }
    
  } else {
    
  }
  token_amount_ = token_amount;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.Transfer.token_amount)
}

// bool use_max_amount = 5;
inline void Transfer::clear_use_max_amount() {
  use_max_amount_ = false;
}
inline bool Transfer::_internal_use_max_amount() const {
  return use_max_amount_;
}
inline bool Transfer::use_max_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Transfer.use_max_amount)
  return _internal_use_max_amount();
}
inline void Transfer::_internal_set_use_max_amount(bool value) {
  
  use_max_amount_ = value;
}
inline void Transfer::set_use_max_amount(bool value) {
  _internal_set_use_max_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Transfer.use_max_amount)
}

// uint64 force_fee = 6;
inline void Transfer::clear_force_fee() {
  force_fee_ = uint64_t{0u};
}
inline uint64_t Transfer::_internal_force_fee() const {
  return force_fee_;
}
inline uint64_t Transfer::force_fee() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Transfer.force_fee)
  return _internal_force_fee();
}
inline void Transfer::_internal_set_force_fee(uint64_t value) {
  
  force_fee_ = value;
}
inline void Transfer::set_force_fee(uint64_t value) {
  _internal_set_force_fee(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Transfer.force_fee)
}

// -------------------------------------------------------------------

// RegisterStakingKey

// string staking_address = 1;
inline void RegisterStakingKey::clear_staking_address() {
  staking_address_.ClearToEmpty();
}
inline const std::string& RegisterStakingKey::staking_address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.RegisterStakingKey.staking_address)
  return _internal_staking_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterStakingKey::set_staking_address(ArgT0&& arg0, ArgT... args) {
 
 staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.RegisterStakingKey.staking_address)
}
inline std::string* RegisterStakingKey::mutable_staking_address() {
  std::string* _s = _internal_mutable_staking_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.RegisterStakingKey.staking_address)
  return _s;
}
inline const std::string& RegisterStakingKey::_internal_staking_address() const {
  return staking_address_.Get();
}
inline void RegisterStakingKey::_internal_set_staking_address(const std::string& value) {
  
  staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterStakingKey::_internal_mutable_staking_address() {
  
  return staking_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterStakingKey::release_staking_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.RegisterStakingKey.staking_address)
  return staking_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterStakingKey::set_allocated_staking_address(std::string* staking_address) {
  if (staking_address != nullptr) {
    
  } else {
    
  }
  staking_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staking_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (staking_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    staking_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.RegisterStakingKey.staking_address)
}

// uint64 deposit_amount = 2;
inline void RegisterStakingKey::clear_deposit_amount() {
  deposit_amount_ = uint64_t{0u};
}
inline uint64_t RegisterStakingKey::_internal_deposit_amount() const {
  return deposit_amount_;
}
inline uint64_t RegisterStakingKey::deposit_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.RegisterStakingKey.deposit_amount)
  return _internal_deposit_amount();
}
inline void RegisterStakingKey::_internal_set_deposit_amount(uint64_t value) {
  
  deposit_amount_ = value;
}
inline void RegisterStakingKey::set_deposit_amount(uint64_t value) {
  _internal_set_deposit_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.RegisterStakingKey.deposit_amount)
}

// -------------------------------------------------------------------

// DeregisterStakingKey

// string staking_address = 1;
inline void DeregisterStakingKey::clear_staking_address() {
  staking_address_.ClearToEmpty();
}
inline const std::string& DeregisterStakingKey::staking_address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.DeregisterStakingKey.staking_address)
  return _internal_staking_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeregisterStakingKey::set_staking_address(ArgT0&& arg0, ArgT... args) {
 
 staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.DeregisterStakingKey.staking_address)
}
inline std::string* DeregisterStakingKey::mutable_staking_address() {
  std::string* _s = _internal_mutable_staking_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.DeregisterStakingKey.staking_address)
  return _s;
}
inline const std::string& DeregisterStakingKey::_internal_staking_address() const {
  return staking_address_.Get();
}
inline void DeregisterStakingKey::_internal_set_staking_address(const std::string& value) {
  
  staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeregisterStakingKey::_internal_mutable_staking_address() {
  
  return staking_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeregisterStakingKey::release_staking_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.DeregisterStakingKey.staking_address)
  return staking_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeregisterStakingKey::set_allocated_staking_address(std::string* staking_address) {
  if (staking_address != nullptr) {
    
  } else {
    
  }
  staking_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staking_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (staking_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    staking_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.DeregisterStakingKey.staking_address)
}

// uint64 undeposit_amount = 2;
inline void DeregisterStakingKey::clear_undeposit_amount() {
  undeposit_amount_ = uint64_t{0u};
}
inline uint64_t DeregisterStakingKey::_internal_undeposit_amount() const {
  return undeposit_amount_;
}
inline uint64_t DeregisterStakingKey::undeposit_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.DeregisterStakingKey.undeposit_amount)
  return _internal_undeposit_amount();
}
inline void DeregisterStakingKey::_internal_set_undeposit_amount(uint64_t value) {
  
  undeposit_amount_ = value;
}
inline void DeregisterStakingKey::set_undeposit_amount(uint64_t value) {
  _internal_set_undeposit_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.DeregisterStakingKey.undeposit_amount)
}

// -------------------------------------------------------------------

// Delegate

// string staking_address = 1;
inline void Delegate::clear_staking_address() {
  staking_address_.ClearToEmpty();
}
inline const std::string& Delegate::staking_address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Delegate.staking_address)
  return _internal_staking_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Delegate::set_staking_address(ArgT0&& arg0, ArgT... args) {
 
 staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Delegate.staking_address)
}
inline std::string* Delegate::mutable_staking_address() {
  std::string* _s = _internal_mutable_staking_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.Delegate.staking_address)
  return _s;
}
inline const std::string& Delegate::_internal_staking_address() const {
  return staking_address_.Get();
}
inline void Delegate::_internal_set_staking_address(const std::string& value) {
  
  staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Delegate::_internal_mutable_staking_address() {
  
  return staking_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Delegate::release_staking_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.Delegate.staking_address)
  return staking_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Delegate::set_allocated_staking_address(std::string* staking_address) {
  if (staking_address != nullptr) {
    
  } else {
    
  }
  staking_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staking_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (staking_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    staking_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.Delegate.staking_address)
}

// bytes pool_id = 2;
inline void Delegate::clear_pool_id() {
  pool_id_.ClearToEmpty();
}
inline const std::string& Delegate::pool_id() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Delegate.pool_id)
  return _internal_pool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Delegate::set_pool_id(ArgT0&& arg0, ArgT... args) {
 
 pool_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Delegate.pool_id)
}
inline std::string* Delegate::mutable_pool_id() {
  std::string* _s = _internal_mutable_pool_id();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.Delegate.pool_id)
  return _s;
}
inline const std::string& Delegate::_internal_pool_id() const {
  return pool_id_.Get();
}
inline void Delegate::_internal_set_pool_id(const std::string& value) {
  
  pool_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Delegate::_internal_mutable_pool_id() {
  
  return pool_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Delegate::release_pool_id() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.Delegate.pool_id)
  return pool_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Delegate::set_allocated_pool_id(std::string* pool_id) {
  if (pool_id != nullptr) {
    
  } else {
    
  }
  pool_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pool_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pool_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pool_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.Delegate.pool_id)
}

// uint64 deposit_amount = 3;
inline void Delegate::clear_deposit_amount() {
  deposit_amount_ = uint64_t{0u};
}
inline uint64_t Delegate::_internal_deposit_amount() const {
  return deposit_amount_;
}
inline uint64_t Delegate::deposit_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Delegate.deposit_amount)
  return _internal_deposit_amount();
}
inline void Delegate::_internal_set_deposit_amount(uint64_t value) {
  
  deposit_amount_ = value;
}
inline void Delegate::set_deposit_amount(uint64_t value) {
  _internal_set_deposit_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Delegate.deposit_amount)
}

// -------------------------------------------------------------------

// Withdraw

// string staking_address = 1;
inline void Withdraw::clear_staking_address() {
  staking_address_.ClearToEmpty();
}
inline const std::string& Withdraw::staking_address() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Withdraw.staking_address)
  return _internal_staking_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Withdraw::set_staking_address(ArgT0&& arg0, ArgT... args) {
 
 staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Withdraw.staking_address)
}
inline std::string* Withdraw::mutable_staking_address() {
  std::string* _s = _internal_mutable_staking_address();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.Withdraw.staking_address)
  return _s;
}
inline const std::string& Withdraw::_internal_staking_address() const {
  return staking_address_.Get();
}
inline void Withdraw::_internal_set_staking_address(const std::string& value) {
  
  staking_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Withdraw::_internal_mutable_staking_address() {
  
  return staking_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Withdraw::release_staking_address() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.Withdraw.staking_address)
  return staking_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Withdraw::set_allocated_staking_address(std::string* staking_address) {
  if (staking_address != nullptr) {
    
  } else {
    
  }
  staking_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staking_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (staking_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    staking_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.Withdraw.staking_address)
}

// uint64 withdraw_amount = 2;
inline void Withdraw::clear_withdraw_amount() {
  withdraw_amount_ = uint64_t{0u};
}
inline uint64_t Withdraw::_internal_withdraw_amount() const {
  return withdraw_amount_;
}
inline uint64_t Withdraw::withdraw_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.Withdraw.withdraw_amount)
  return _internal_withdraw_amount();
}
inline void Withdraw::_internal_set_withdraw_amount(uint64_t value) {
  
  withdraw_amount_ = value;
}
inline void Withdraw::set_withdraw_amount(uint64_t value) {
  _internal_set_withdraw_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.Withdraw.withdraw_amount)
}

// -------------------------------------------------------------------

// TransactionPlan

// uint64 available_amount = 1;
inline void TransactionPlan::clear_available_amount() {
  available_amount_ = uint64_t{0u};
}
inline uint64_t TransactionPlan::_internal_available_amount() const {
  return available_amount_;
}
inline uint64_t TransactionPlan::available_amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.available_amount)
  return _internal_available_amount();
}
inline void TransactionPlan::_internal_set_available_amount(uint64_t value) {
  
  available_amount_ = value;
}
inline void TransactionPlan::set_available_amount(uint64_t value) {
  _internal_set_available_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.available_amount)
}

// uint64 amount = 2;
inline void TransactionPlan::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t TransactionPlan::_internal_amount() const {
  return amount_;
}
inline uint64_t TransactionPlan::amount() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.amount)
  return _internal_amount();
}
inline void TransactionPlan::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void TransactionPlan::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.amount)
}

// uint64 fee = 3;
inline void TransactionPlan::clear_fee() {
  fee_ = uint64_t{0u};
}
inline uint64_t TransactionPlan::_internal_fee() const {
  return fee_;
}
inline uint64_t TransactionPlan::fee() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.fee)
  return _internal_fee();
}
inline void TransactionPlan::_internal_set_fee(uint64_t value) {
  
  fee_ = value;
}
inline void TransactionPlan::set_fee(uint64_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.fee)
}

// uint64 change = 4;
inline void TransactionPlan::clear_change() {
  change_ = uint64_t{0u};
}
inline uint64_t TransactionPlan::_internal_change() const {
  return change_;
}
inline uint64_t TransactionPlan::change() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.change)
  return _internal_change();
}
inline void TransactionPlan::_internal_set_change(uint64_t value) {
  
  change_ = value;
}
inline void TransactionPlan::set_change(uint64_t value) {
  _internal_set_change(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.change)
}

// uint64 deposit = 10;
inline void TransactionPlan::clear_deposit() {
  deposit_ = uint64_t{0u};
}
inline uint64_t TransactionPlan::_internal_deposit() const {
  return deposit_;
}
inline uint64_t TransactionPlan::deposit() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.deposit)
  return _internal_deposit();
}
inline void TransactionPlan::_internal_set_deposit(uint64_t value) {
  
  deposit_ = value;
}
inline void TransactionPlan::set_deposit(uint64_t value) {
  _internal_set_deposit(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.deposit)
}

// uint64 undeposit = 11;
inline void TransactionPlan::clear_undeposit() {
  undeposit_ = uint64_t{0u};
}
inline uint64_t TransactionPlan::_internal_undeposit() const {
  return undeposit_;
}
inline uint64_t TransactionPlan::undeposit() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.undeposit)
  return _internal_undeposit();
}
inline void TransactionPlan::_internal_set_undeposit(uint64_t value) {
  
  undeposit_ = value;
}
inline void TransactionPlan::set_undeposit(uint64_t value) {
  _internal_set_undeposit(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.undeposit)
}

// repeated .TW.Cardano.Proto.TokenAmount available_tokens = 5;
inline int TransactionPlan::_internal_available_tokens_size() const {
  return available_tokens_.size();
}
inline int TransactionPlan::available_tokens_size() const {
  return _internal_available_tokens_size();
}
inline void TransactionPlan::clear_available_tokens() {
  available_tokens_.Clear();
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::mutable_available_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TransactionPlan.available_tokens)
  return available_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
TransactionPlan::mutable_available_tokens() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TransactionPlan.available_tokens)
  return &available_tokens_;
}
inline const ::TW::Cardano::Proto::TokenAmount& TransactionPlan::_internal_available_tokens(int index) const {
  return available_tokens_.Get(index);
}
inline const ::TW::Cardano::Proto::TokenAmount& TransactionPlan::available_tokens(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.available_tokens)
  return _internal_available_tokens(index);
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::_internal_add_available_tokens() {
  return available_tokens_.Add();
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::add_available_tokens() {
  ::TW::Cardano::Proto::TokenAmount* _add = _internal_add_available_tokens();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TransactionPlan.available_tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
TransactionPlan::available_tokens() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TransactionPlan.available_tokens)
  return available_tokens_;
}

// repeated .TW.Cardano.Proto.TokenAmount output_tokens = 6;
inline int TransactionPlan::_internal_output_tokens_size() const {
  return output_tokens_.size();
}
inline int TransactionPlan::output_tokens_size() const {
  return _internal_output_tokens_size();
}
inline void TransactionPlan::clear_output_tokens() {
  output_tokens_.Clear();
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::mutable_output_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TransactionPlan.output_tokens)
  return output_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
TransactionPlan::mutable_output_tokens() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TransactionPlan.output_tokens)
  return &output_tokens_;
}
inline const ::TW::Cardano::Proto::TokenAmount& TransactionPlan::_internal_output_tokens(int index) const {
  return output_tokens_.Get(index);
}
inline const ::TW::Cardano::Proto::TokenAmount& TransactionPlan::output_tokens(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.output_tokens)
  return _internal_output_tokens(index);
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::_internal_add_output_tokens() {
  return output_tokens_.Add();
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::add_output_tokens() {
  ::TW::Cardano::Proto::TokenAmount* _add = _internal_add_output_tokens();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TransactionPlan.output_tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
TransactionPlan::output_tokens() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TransactionPlan.output_tokens)
  return output_tokens_;
}

// repeated .TW.Cardano.Proto.TokenAmount change_tokens = 7;
inline int TransactionPlan::_internal_change_tokens_size() const {
  return change_tokens_.size();
}
inline int TransactionPlan::change_tokens_size() const {
  return _internal_change_tokens_size();
}
inline void TransactionPlan::clear_change_tokens() {
  change_tokens_.Clear();
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::mutable_change_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TransactionPlan.change_tokens)
  return change_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >*
TransactionPlan::mutable_change_tokens() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TransactionPlan.change_tokens)
  return &change_tokens_;
}
inline const ::TW::Cardano::Proto::TokenAmount& TransactionPlan::_internal_change_tokens(int index) const {
  return change_tokens_.Get(index);
}
inline const ::TW::Cardano::Proto::TokenAmount& TransactionPlan::change_tokens(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.change_tokens)
  return _internal_change_tokens(index);
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::_internal_add_change_tokens() {
  return change_tokens_.Add();
}
inline ::TW::Cardano::Proto::TokenAmount* TransactionPlan::add_change_tokens() {
  ::TW::Cardano::Proto::TokenAmount* _add = _internal_add_change_tokens();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TransactionPlan.change_tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TokenAmount >&
TransactionPlan::change_tokens() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TransactionPlan.change_tokens)
  return change_tokens_;
}

// repeated .TW.Cardano.Proto.TxInput utxos = 8;
inline int TransactionPlan::_internal_utxos_size() const {
  return utxos_.size();
}
inline int TransactionPlan::utxos_size() const {
  return _internal_utxos_size();
}
inline void TransactionPlan::clear_utxos() {
  utxos_.Clear();
}
inline ::TW::Cardano::Proto::TxInput* TransactionPlan::mutable_utxos(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TransactionPlan.utxos)
  return utxos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >*
TransactionPlan::mutable_utxos() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TransactionPlan.utxos)
  return &utxos_;
}
inline const ::TW::Cardano::Proto::TxInput& TransactionPlan::_internal_utxos(int index) const {
  return utxos_.Get(index);
}
inline const ::TW::Cardano::Proto::TxInput& TransactionPlan::utxos(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.utxos)
  return _internal_utxos(index);
}
inline ::TW::Cardano::Proto::TxInput* TransactionPlan::_internal_add_utxos() {
  return utxos_.Add();
}
inline ::TW::Cardano::Proto::TxInput* TransactionPlan::add_utxos() {
  ::TW::Cardano::Proto::TxInput* _add = _internal_add_utxos();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TransactionPlan.utxos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >&
TransactionPlan::utxos() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TransactionPlan.utxos)
  return utxos_;
}

// .TW.Common.Proto.SigningError error = 9;
inline void TransactionPlan::clear_error() {
  error_ = 0;
}
inline ::TW::Common::Proto::SigningError TransactionPlan::_internal_error() const {
  return static_cast< ::TW::Common::Proto::SigningError >(error_);
}
inline ::TW::Common::Proto::SigningError TransactionPlan::error() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.error)
  return _internal_error();
}
inline void TransactionPlan::_internal_set_error(::TW::Common::Proto::SigningError value) {
  
  error_ = value;
}
inline void TransactionPlan::set_error(::TW::Common::Proto::SigningError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.TransactionPlan.error)
}

// repeated .TW.Cardano.Proto.TxOutput extra_outputs = 12;
inline int TransactionPlan::_internal_extra_outputs_size() const {
  return extra_outputs_.size();
}
inline int TransactionPlan::extra_outputs_size() const {
  return _internal_extra_outputs_size();
}
inline void TransactionPlan::clear_extra_outputs() {
  extra_outputs_.Clear();
}
inline ::TW::Cardano::Proto::TxOutput* TransactionPlan::mutable_extra_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.TransactionPlan.extra_outputs)
  return extra_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >*
TransactionPlan::mutable_extra_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.TransactionPlan.extra_outputs)
  return &extra_outputs_;
}
inline const ::TW::Cardano::Proto::TxOutput& TransactionPlan::_internal_extra_outputs(int index) const {
  return extra_outputs_.Get(index);
}
inline const ::TW::Cardano::Proto::TxOutput& TransactionPlan::extra_outputs(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.TransactionPlan.extra_outputs)
  return _internal_extra_outputs(index);
}
inline ::TW::Cardano::Proto::TxOutput* TransactionPlan::_internal_add_extra_outputs() {
  return extra_outputs_.Add();
}
inline ::TW::Cardano::Proto::TxOutput* TransactionPlan::add_extra_outputs() {
  ::TW::Cardano::Proto::TxOutput* _add = _internal_add_extra_outputs();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.TransactionPlan.extra_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >&
TransactionPlan::extra_outputs() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.TransactionPlan.extra_outputs)
  return extra_outputs_;
}

// -------------------------------------------------------------------

// SigningInput

// repeated .TW.Cardano.Proto.TxInput utxos = 1;
inline int SigningInput::_internal_utxos_size() const {
  return utxos_.size();
}
inline int SigningInput::utxos_size() const {
  return _internal_utxos_size();
}
inline void SigningInput::clear_utxos() {
  utxos_.Clear();
}
inline ::TW::Cardano::Proto::TxInput* SigningInput::mutable_utxos(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.utxos)
  return utxos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >*
SigningInput::mutable_utxos() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.SigningInput.utxos)
  return &utxos_;
}
inline const ::TW::Cardano::Proto::TxInput& SigningInput::_internal_utxos(int index) const {
  return utxos_.Get(index);
}
inline const ::TW::Cardano::Proto::TxInput& SigningInput::utxos(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.utxos)
  return _internal_utxos(index);
}
inline ::TW::Cardano::Proto::TxInput* SigningInput::_internal_add_utxos() {
  return utxos_.Add();
}
inline ::TW::Cardano::Proto::TxInput* SigningInput::add_utxos() {
  ::TW::Cardano::Proto::TxInput* _add = _internal_add_utxos();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.SigningInput.utxos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxInput >&
SigningInput::utxos() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.SigningInput.utxos)
  return utxos_;
}

// repeated bytes private_key = 2;
inline int SigningInput::_internal_private_key_size() const {
  return private_key_.size();
}
inline int SigningInput::private_key_size() const {
  return _internal_private_key_size();
}
inline void SigningInput::clear_private_key() {
  private_key_.Clear();
}
inline std::string* SigningInput::add_private_key() {
  std::string* _s = _internal_add_private_key();
  // @@protoc_insertion_point(field_add_mutable:TW.Cardano.Proto.SigningInput.private_key)
  return _s;
}
inline const std::string& SigningInput::_internal_private_key(int index) const {
  return private_key_.Get(index);
}
inline const std::string& SigningInput::private_key(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.private_key)
  return _internal_private_key(index);
}
inline std::string* SigningInput::mutable_private_key(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.private_key)
  return private_key_.Mutable(index);
}
inline void SigningInput::set_private_key(int index, const std::string& value) {
  private_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningInput.private_key)
}
inline void SigningInput::set_private_key(int index, std::string&& value) {
  private_key_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningInput.private_key)
}
inline void SigningInput::set_private_key(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  private_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TW.Cardano.Proto.SigningInput.private_key)
}
inline void SigningInput::set_private_key(int index, const void* value, size_t size) {
  private_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TW.Cardano.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::_internal_add_private_key() {
  return private_key_.Add();
}
inline void SigningInput::add_private_key(const std::string& value) {
  private_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.SigningInput.private_key)
}
inline void SigningInput::add_private_key(std::string&& value) {
  private_key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.SigningInput.private_key)
}
inline void SigningInput::add_private_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  private_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TW.Cardano.Proto.SigningInput.private_key)
}
inline void SigningInput::add_private_key(const void* value, size_t size) {
  private_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TW.Cardano.Proto.SigningInput.private_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SigningInput::private_key() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.SigningInput.private_key)
  return private_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SigningInput::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.SigningInput.private_key)
  return &private_key_;
}

// .TW.Cardano.Proto.Transfer transfer_message = 3;
inline bool SigningInput::_internal_has_transfer_message() const {
  return this != internal_default_instance() && transfer_message_ != nullptr;
}
inline bool SigningInput::has_transfer_message() const {
  return _internal_has_transfer_message();
}
inline void SigningInput::clear_transfer_message() {
  if (GetArenaForAllocation() == nullptr && transfer_message_ != nullptr) {
    delete transfer_message_;
  }
  transfer_message_ = nullptr;
}
inline const ::TW::Cardano::Proto::Transfer& SigningInput::_internal_transfer_message() const {
  const ::TW::Cardano::Proto::Transfer* p = transfer_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::Transfer&>(
      ::TW::Cardano::Proto::_Transfer_default_instance_);
}
inline const ::TW::Cardano::Proto::Transfer& SigningInput::transfer_message() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.transfer_message)
  return _internal_transfer_message();
}
inline void SigningInput::unsafe_arena_set_allocated_transfer_message(
    ::TW::Cardano::Proto::Transfer* transfer_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer_message_);
  }
  transfer_message_ = transfer_message;
  if (transfer_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.SigningInput.transfer_message)
}
inline ::TW::Cardano::Proto::Transfer* SigningInput::release_transfer_message() {
  
  ::TW::Cardano::Proto::Transfer* temp = transfer_message_;
  transfer_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::Transfer* SigningInput::unsafe_arena_release_transfer_message() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningInput.transfer_message)
  
  ::TW::Cardano::Proto::Transfer* temp = transfer_message_;
  transfer_message_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::Transfer* SigningInput::_internal_mutable_transfer_message() {
  
  if (transfer_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::Transfer>(GetArenaForAllocation());
    transfer_message_ = p;
  }
  return transfer_message_;
}
inline ::TW::Cardano::Proto::Transfer* SigningInput::mutable_transfer_message() {
  ::TW::Cardano::Proto::Transfer* _msg = _internal_mutable_transfer_message();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.transfer_message)
  return _msg;
}
inline void SigningInput::set_allocated_transfer_message(::TW::Cardano::Proto::Transfer* transfer_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transfer_message_;
  }
  if (transfer_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::Transfer>::GetOwningArena(transfer_message);
    if (message_arena != submessage_arena) {
      transfer_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transfer_message, submessage_arena);
    }
    
  } else {
    
  }
  transfer_message_ = transfer_message;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningInput.transfer_message)
}

// .TW.Cardano.Proto.RegisterStakingKey register_staking_key = 6;
inline bool SigningInput::_internal_has_register_staking_key() const {
  return this != internal_default_instance() && register_staking_key_ != nullptr;
}
inline bool SigningInput::has_register_staking_key() const {
  return _internal_has_register_staking_key();
}
inline void SigningInput::clear_register_staking_key() {
  if (GetArenaForAllocation() == nullptr && register_staking_key_ != nullptr) {
    delete register_staking_key_;
  }
  register_staking_key_ = nullptr;
}
inline const ::TW::Cardano::Proto::RegisterStakingKey& SigningInput::_internal_register_staking_key() const {
  const ::TW::Cardano::Proto::RegisterStakingKey* p = register_staking_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::RegisterStakingKey&>(
      ::TW::Cardano::Proto::_RegisterStakingKey_default_instance_);
}
inline const ::TW::Cardano::Proto::RegisterStakingKey& SigningInput::register_staking_key() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.register_staking_key)
  return _internal_register_staking_key();
}
inline void SigningInput::unsafe_arena_set_allocated_register_staking_key(
    ::TW::Cardano::Proto::RegisterStakingKey* register_staking_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(register_staking_key_);
  }
  register_staking_key_ = register_staking_key;
  if (register_staking_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.SigningInput.register_staking_key)
}
inline ::TW::Cardano::Proto::RegisterStakingKey* SigningInput::release_register_staking_key() {
  
  ::TW::Cardano::Proto::RegisterStakingKey* temp = register_staking_key_;
  register_staking_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::RegisterStakingKey* SigningInput::unsafe_arena_release_register_staking_key() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningInput.register_staking_key)
  
  ::TW::Cardano::Proto::RegisterStakingKey* temp = register_staking_key_;
  register_staking_key_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::RegisterStakingKey* SigningInput::_internal_mutable_register_staking_key() {
  
  if (register_staking_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::RegisterStakingKey>(GetArenaForAllocation());
    register_staking_key_ = p;
  }
  return register_staking_key_;
}
inline ::TW::Cardano::Proto::RegisterStakingKey* SigningInput::mutable_register_staking_key() {
  ::TW::Cardano::Proto::RegisterStakingKey* _msg = _internal_mutable_register_staking_key();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.register_staking_key)
  return _msg;
}
inline void SigningInput::set_allocated_register_staking_key(::TW::Cardano::Proto::RegisterStakingKey* register_staking_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete register_staking_key_;
  }
  if (register_staking_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::RegisterStakingKey>::GetOwningArena(register_staking_key);
    if (message_arena != submessage_arena) {
      register_staking_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_staking_key, submessage_arena);
    }
    
  } else {
    
  }
  register_staking_key_ = register_staking_key;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningInput.register_staking_key)
}

// .TW.Cardano.Proto.Delegate delegate = 7;
inline bool SigningInput::_internal_has_delegate() const {
  return this != internal_default_instance() && delegate_ != nullptr;
}
inline bool SigningInput::has_delegate() const {
  return _internal_has_delegate();
}
inline void SigningInput::clear_delegate() {
  if (GetArenaForAllocation() == nullptr && delegate_ != nullptr) {
    delete delegate_;
  }
  delegate_ = nullptr;
}
inline const ::TW::Cardano::Proto::Delegate& SigningInput::_internal_delegate() const {
  const ::TW::Cardano::Proto::Delegate* p = delegate_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::Delegate&>(
      ::TW::Cardano::Proto::_Delegate_default_instance_);
}
inline const ::TW::Cardano::Proto::Delegate& SigningInput::delegate() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.delegate)
  return _internal_delegate();
}
inline void SigningInput::unsafe_arena_set_allocated_delegate(
    ::TW::Cardano::Proto::Delegate* delegate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delegate_);
  }
  delegate_ = delegate;
  if (delegate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.SigningInput.delegate)
}
inline ::TW::Cardano::Proto::Delegate* SigningInput::release_delegate() {
  
  ::TW::Cardano::Proto::Delegate* temp = delegate_;
  delegate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::Delegate* SigningInput::unsafe_arena_release_delegate() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningInput.delegate)
  
  ::TW::Cardano::Proto::Delegate* temp = delegate_;
  delegate_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::Delegate* SigningInput::_internal_mutable_delegate() {
  
  if (delegate_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::Delegate>(GetArenaForAllocation());
    delegate_ = p;
  }
  return delegate_;
}
inline ::TW::Cardano::Proto::Delegate* SigningInput::mutable_delegate() {
  ::TW::Cardano::Proto::Delegate* _msg = _internal_mutable_delegate();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.delegate)
  return _msg;
}
inline void SigningInput::set_allocated_delegate(::TW::Cardano::Proto::Delegate* delegate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete delegate_;
  }
  if (delegate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::Delegate>::GetOwningArena(delegate);
    if (message_arena != submessage_arena) {
      delegate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delegate, submessage_arena);
    }
    
  } else {
    
  }
  delegate_ = delegate;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningInput.delegate)
}

// .TW.Cardano.Proto.Withdraw withdraw = 8;
inline bool SigningInput::_internal_has_withdraw() const {
  return this != internal_default_instance() && withdraw_ != nullptr;
}
inline bool SigningInput::has_withdraw() const {
  return _internal_has_withdraw();
}
inline void SigningInput::clear_withdraw() {
  if (GetArenaForAllocation() == nullptr && withdraw_ != nullptr) {
    delete withdraw_;
  }
  withdraw_ = nullptr;
}
inline const ::TW::Cardano::Proto::Withdraw& SigningInput::_internal_withdraw() const {
  const ::TW::Cardano::Proto::Withdraw* p = withdraw_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::Withdraw&>(
      ::TW::Cardano::Proto::_Withdraw_default_instance_);
}
inline const ::TW::Cardano::Proto::Withdraw& SigningInput::withdraw() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.withdraw)
  return _internal_withdraw();
}
inline void SigningInput::unsafe_arena_set_allocated_withdraw(
    ::TW::Cardano::Proto::Withdraw* withdraw) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(withdraw_);
  }
  withdraw_ = withdraw;
  if (withdraw) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.SigningInput.withdraw)
}
inline ::TW::Cardano::Proto::Withdraw* SigningInput::release_withdraw() {
  
  ::TW::Cardano::Proto::Withdraw* temp = withdraw_;
  withdraw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::Withdraw* SigningInput::unsafe_arena_release_withdraw() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningInput.withdraw)
  
  ::TW::Cardano::Proto::Withdraw* temp = withdraw_;
  withdraw_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::Withdraw* SigningInput::_internal_mutable_withdraw() {
  
  if (withdraw_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::Withdraw>(GetArenaForAllocation());
    withdraw_ = p;
  }
  return withdraw_;
}
inline ::TW::Cardano::Proto::Withdraw* SigningInput::mutable_withdraw() {
  ::TW::Cardano::Proto::Withdraw* _msg = _internal_mutable_withdraw();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.withdraw)
  return _msg;
}
inline void SigningInput::set_allocated_withdraw(::TW::Cardano::Proto::Withdraw* withdraw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete withdraw_;
  }
  if (withdraw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::Withdraw>::GetOwningArena(withdraw);
    if (message_arena != submessage_arena) {
      withdraw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, withdraw, submessage_arena);
    }
    
  } else {
    
  }
  withdraw_ = withdraw;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningInput.withdraw)
}

// .TW.Cardano.Proto.DeregisterStakingKey deregister_staking_key = 9;
inline bool SigningInput::_internal_has_deregister_staking_key() const {
  return this != internal_default_instance() && deregister_staking_key_ != nullptr;
}
inline bool SigningInput::has_deregister_staking_key() const {
  return _internal_has_deregister_staking_key();
}
inline void SigningInput::clear_deregister_staking_key() {
  if (GetArenaForAllocation() == nullptr && deregister_staking_key_ != nullptr) {
    delete deregister_staking_key_;
  }
  deregister_staking_key_ = nullptr;
}
inline const ::TW::Cardano::Proto::DeregisterStakingKey& SigningInput::_internal_deregister_staking_key() const {
  const ::TW::Cardano::Proto::DeregisterStakingKey* p = deregister_staking_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::DeregisterStakingKey&>(
      ::TW::Cardano::Proto::_DeregisterStakingKey_default_instance_);
}
inline const ::TW::Cardano::Proto::DeregisterStakingKey& SigningInput::deregister_staking_key() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.deregister_staking_key)
  return _internal_deregister_staking_key();
}
inline void SigningInput::unsafe_arena_set_allocated_deregister_staking_key(
    ::TW::Cardano::Proto::DeregisterStakingKey* deregister_staking_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deregister_staking_key_);
  }
  deregister_staking_key_ = deregister_staking_key;
  if (deregister_staking_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.SigningInput.deregister_staking_key)
}
inline ::TW::Cardano::Proto::DeregisterStakingKey* SigningInput::release_deregister_staking_key() {
  
  ::TW::Cardano::Proto::DeregisterStakingKey* temp = deregister_staking_key_;
  deregister_staking_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::DeregisterStakingKey* SigningInput::unsafe_arena_release_deregister_staking_key() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningInput.deregister_staking_key)
  
  ::TW::Cardano::Proto::DeregisterStakingKey* temp = deregister_staking_key_;
  deregister_staking_key_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::DeregisterStakingKey* SigningInput::_internal_mutable_deregister_staking_key() {
  
  if (deregister_staking_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::DeregisterStakingKey>(GetArenaForAllocation());
    deregister_staking_key_ = p;
  }
  return deregister_staking_key_;
}
inline ::TW::Cardano::Proto::DeregisterStakingKey* SigningInput::mutable_deregister_staking_key() {
  ::TW::Cardano::Proto::DeregisterStakingKey* _msg = _internal_mutable_deregister_staking_key();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.deregister_staking_key)
  return _msg;
}
inline void SigningInput::set_allocated_deregister_staking_key(::TW::Cardano::Proto::DeregisterStakingKey* deregister_staking_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete deregister_staking_key_;
  }
  if (deregister_staking_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::DeregisterStakingKey>::GetOwningArena(deregister_staking_key);
    if (message_arena != submessage_arena) {
      deregister_staking_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deregister_staking_key, submessage_arena);
    }
    
  } else {
    
  }
  deregister_staking_key_ = deregister_staking_key;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningInput.deregister_staking_key)
}

// uint64 ttl = 4;
inline void SigningInput::clear_ttl() {
  ttl_ = uint64_t{0u};
}
inline uint64_t SigningInput::_internal_ttl() const {
  return ttl_;
}
inline uint64_t SigningInput::ttl() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.ttl)
  return _internal_ttl();
}
inline void SigningInput::_internal_set_ttl(uint64_t value) {
  
  ttl_ = value;
}
inline void SigningInput::set_ttl(uint64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningInput.ttl)
}

// .TW.Cardano.Proto.TransactionPlan plan = 5;
inline bool SigningInput::_internal_has_plan() const {
  return this != internal_default_instance() && plan_ != nullptr;
}
inline bool SigningInput::has_plan() const {
  return _internal_has_plan();
}
inline void SigningInput::clear_plan() {
  if (GetArenaForAllocation() == nullptr && plan_ != nullptr) {
    delete plan_;
  }
  plan_ = nullptr;
}
inline const ::TW::Cardano::Proto::TransactionPlan& SigningInput::_internal_plan() const {
  const ::TW::Cardano::Proto::TransactionPlan* p = plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::Cardano::Proto::TransactionPlan&>(
      ::TW::Cardano::Proto::_TransactionPlan_default_instance_);
}
inline const ::TW::Cardano::Proto::TransactionPlan& SigningInput::plan() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.plan)
  return _internal_plan();
}
inline void SigningInput::unsafe_arena_set_allocated_plan(
    ::TW::Cardano::Proto::TransactionPlan* plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  plan_ = plan;
  if (plan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.Cardano.Proto.SigningInput.plan)
}
inline ::TW::Cardano::Proto::TransactionPlan* SigningInput::release_plan() {
  
  ::TW::Cardano::Proto::TransactionPlan* temp = plan_;
  plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TW::Cardano::Proto::TransactionPlan* SigningInput::unsafe_arena_release_plan() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningInput.plan)
  
  ::TW::Cardano::Proto::TransactionPlan* temp = plan_;
  plan_ = nullptr;
  return temp;
}
inline ::TW::Cardano::Proto::TransactionPlan* SigningInput::_internal_mutable_plan() {
  
  if (plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::Cardano::Proto::TransactionPlan>(GetArenaForAllocation());
    plan_ = p;
  }
  return plan_;
}
inline ::TW::Cardano::Proto::TransactionPlan* SigningInput::mutable_plan() {
  ::TW::Cardano::Proto::TransactionPlan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.plan)
  return _msg;
}
inline void SigningInput::set_allocated_plan(::TW::Cardano::Proto::TransactionPlan* plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plan_;
  }
  if (plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TW::Cardano::Proto::TransactionPlan>::GetOwningArena(plan);
    if (message_arena != submessage_arena) {
      plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan, submessage_arena);
    }
    
  } else {
    
  }
  plan_ = plan;
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningInput.plan)
}

// repeated .TW.Cardano.Proto.TxOutput extra_outputs = 10;
inline int SigningInput::_internal_extra_outputs_size() const {
  return extra_outputs_.size();
}
inline int SigningInput::extra_outputs_size() const {
  return _internal_extra_outputs_size();
}
inline void SigningInput::clear_extra_outputs() {
  extra_outputs_.Clear();
}
inline ::TW::Cardano::Proto::TxOutput* SigningInput::mutable_extra_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningInput.extra_outputs)
  return extra_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >*
SigningInput::mutable_extra_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TW.Cardano.Proto.SigningInput.extra_outputs)
  return &extra_outputs_;
}
inline const ::TW::Cardano::Proto::TxOutput& SigningInput::_internal_extra_outputs(int index) const {
  return extra_outputs_.Get(index);
}
inline const ::TW::Cardano::Proto::TxOutput& SigningInput::extra_outputs(int index) const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningInput.extra_outputs)
  return _internal_extra_outputs(index);
}
inline ::TW::Cardano::Proto::TxOutput* SigningInput::_internal_add_extra_outputs() {
  return extra_outputs_.Add();
}
inline ::TW::Cardano::Proto::TxOutput* SigningInput::add_extra_outputs() {
  ::TW::Cardano::Proto::TxOutput* _add = _internal_add_extra_outputs();
  // @@protoc_insertion_point(field_add:TW.Cardano.Proto.SigningInput.extra_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::Cardano::Proto::TxOutput >&
SigningInput::extra_outputs() const {
  // @@protoc_insertion_point(field_list:TW.Cardano.Proto.SigningInput.extra_outputs)
  return extra_outputs_;
}

// -------------------------------------------------------------------

// SigningOutput

// bytes encoded = 1;
inline void SigningOutput::clear_encoded() {
  encoded_.ClearToEmpty();
}
inline const std::string& SigningOutput::encoded() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningOutput.encoded)
  return _internal_encoded();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_encoded(ArgT0&& arg0, ArgT... args) {
 
 encoded_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningOutput.encoded)
}
inline std::string* SigningOutput::mutable_encoded() {
  std::string* _s = _internal_mutable_encoded();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningOutput.encoded)
  return _s;
}
inline const std::string& SigningOutput::_internal_encoded() const {
  return encoded_.Get();
}
inline void SigningOutput::_internal_set_encoded(const std::string& value) {
  
  encoded_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_encoded() {
  
  return encoded_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_encoded() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningOutput.encoded)
  return encoded_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_encoded(std::string* encoded) {
  if (encoded != nullptr) {
    
  } else {
    
  }
  encoded_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoded_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningOutput.encoded)
}

// bytes tx_id = 2;
inline void SigningOutput::clear_tx_id() {
  tx_id_.ClearToEmpty();
}
inline const std::string& SigningOutput::tx_id() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningOutput.tx_id)
  return _internal_tx_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_tx_id(ArgT0&& arg0, ArgT... args) {
 
 tx_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningOutput.tx_id)
}
inline std::string* SigningOutput::mutable_tx_id() {
  std::string* _s = _internal_mutable_tx_id();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningOutput.tx_id)
  return _s;
}
inline const std::string& SigningOutput::_internal_tx_id() const {
  return tx_id_.Get();
}
inline void SigningOutput::_internal_set_tx_id(const std::string& value) {
  
  tx_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_tx_id() {
  
  return tx_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_tx_id() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningOutput.tx_id)
  return tx_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_tx_id(std::string* tx_id) {
  if (tx_id != nullptr) {
    
  } else {
    
  }
  tx_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningOutput.tx_id)
}

// .TW.Common.Proto.SigningError error = 3;
inline void SigningOutput::clear_error() {
  error_ = 0;
}
inline ::TW::Common::Proto::SigningError SigningOutput::_internal_error() const {
  return static_cast< ::TW::Common::Proto::SigningError >(error_);
}
inline ::TW::Common::Proto::SigningError SigningOutput::error() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningOutput.error)
  return _internal_error();
}
inline void SigningOutput::_internal_set_error(::TW::Common::Proto::SigningError value) {
  
  error_ = value;
}
inline void SigningOutput::set_error(::TW::Common::Proto::SigningError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningOutput.error)
}

// string error_message = 4;
inline void SigningOutput::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& SigningOutput::error_message() const {
  // @@protoc_insertion_point(field_get:TW.Cardano.Proto.SigningOutput.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigningOutput::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TW.Cardano.Proto.SigningOutput.error_message)
}
inline std::string* SigningOutput::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:TW.Cardano.Proto.SigningOutput.error_message)
  return _s;
}
inline const std::string& SigningOutput::_internal_error_message() const {
  return error_message_.Get();
}
inline void SigningOutput::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigningOutput::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigningOutput::release_error_message() {
  // @@protoc_insertion_point(field_release:TW.Cardano.Proto.SigningOutput.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigningOutput::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TW.Cardano.Proto.SigningOutput.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Cardano
}  // namespace TW

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Cardano_2eproto
